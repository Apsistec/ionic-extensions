export const isMarkAllowedInRange = (doc, ranges, type) => {
    for (let i = 0; i < ranges.length; i++) {
        const { $from, $to } = ranges[i];
        let can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
        doc.nodesBetween($from.pos, $to.pos, node => {
            if (can) {
                return false;
            }
            can = node.inlineContent && node.type.allowsMarkType(type);
            return;
        });
        if (can) {
            return can;
        }
    }
    return false;
};
export const isMarkExcluded = (type, marks) => {
    if (marks) {
        return marks.some(mark => mark.type !== type && mark.type.excludes(type));
    }
    return false;
};
const not = (fn) => (arg) => !fn(arg);
const ɵ0 = not;
export const removeBlockMarks = (state, marks) => {
    const { selection, schema } = state;
    let { tr } = state;
    // Marks might not exist in Schema
    const marksToRemove = marks.filter(Boolean);
    if (marksToRemove.length === 0) {
        return undefined;
    }
    /** Saves an extra dispatch */
    let blockMarksExists = false;
    const hasMark = (mark) => marksToRemove.indexOf(mark.type) > -1;
    /**
     * When you need to toggle the selection
     * when another type which does not allow alignment is applied
     */
    state.doc.nodesBetween(selection.from, selection.to, (node, pos) => {
        if (node.type === schema.nodes.paragraph && node.marks.some(hasMark)) {
            blockMarksExists = true;
            const resolvedPos = state.doc.resolve(pos);
            const withoutBlockMarks = node.marks.filter(not(hasMark));
            tr = tr.setNodeMarkup(resolvedPos.pos, undefined, node.attrs, withoutBlockMarks);
        }
    });
    return blockMarksExists ? tr : undefined;
};
/**
 * Removes marks from nodes in the current selection that are not supported
 */
export const sanitizeSelectionMarks = (state) => {
    let tr;
    const { $from, $to } = state.tr.selection;
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
        node.marks.forEach(mark => {
            if (!node.type.allowsMarkType(mark.type)) {
                const filteredMarks = node.marks.filter(m => m.type !== mark.type);
                const position = pos > 0 ? pos - 1 : 0;
                tr = (tr || state.tr).setNodeMarkup(position, undefined, node.attrs, filteredMarks);
            }
        });
    });
    return tr;
};
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFyay11dGlscy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bjby5tbW9ucy9pb25pYy1leHRlbnNpb25zL2h0bWwtZWRpdG9yLyIsInNvdXJjZXMiOlsicHJvc2VtaXJyb3IvbWFyay11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRyxDQUNoQyxHQUFTLEVBQ1QsTUFBNkIsRUFDN0IsSUFBYyxFQUNQLEVBQUU7SUFDVCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNwQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQyxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUNwRSxHQUFHLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRTtZQUN4QyxJQUFJLEdBQUcsRUFBRTtnQkFDTCxPQUFPLEtBQUssQ0FBQzthQUNoQjtZQUNELEdBQUcsR0FBRyxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzNELE9BQU87UUFDWCxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksR0FBRyxFQUFFO1lBQ0wsT0FBTyxHQUFHLENBQUM7U0FDZDtLQUNKO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLENBQzFCLElBQWMsRUFDZCxLQUEwQixFQUNuQixFQUFFO0lBQ1Qs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QUMsQ0FBQyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ25FLE1BQU0sUUFBUSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdkMsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxhQUFhLENBQy9CLFFBQVEsRUFDUixTQUFTLEVBQ1QsSUFBSSxDQUFDLEtBQUssRUFDVixhQUFhLENBQ2hCLENBQUM7YUFDTDtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLEVBQUUsQ0FBQztBQUNkLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIE1hcmssIE1hcmtUeXBlIH0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQgeyBTZWxlY3Rpb25SYW5nZSwgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5cbmV4cG9ydCBjb25zdCBpc01hcmtBbGxvd2VkSW5SYW5nZSA9IChcbiAgICBkb2M6IE5vZGUsXG4gICAgcmFuZ2VzOiBBcnJheTxTZWxlY3Rpb25SYW5nZT4sXG4gICAgdHlwZTogTWFya1R5cGUsXG4pOiBib29sZWFuID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgbGV0IGNhbiA9ICRmcm9tLmRlcHRoID09PSAwID8gZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSkgOiBmYWxzZTtcbiAgICAgICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbiA9IG5vZGUuaW5saW5lQ29udGVudCAmJiBub2RlLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FuKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc01hcmtFeGNsdWRlZCA9IChcbiAgICB0eXBlOiBNYXJrVHlwZSxcbiAgICBtYXJrcz86IEFycmF5PE1hcms+IHwgbnVsbCxcbik6IGJvb2xlYW4gPT4ge1xuICAgIGlmIChtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3Muc29tZShtYXJrID0+IG1hcmsudHlwZSAhPT0gdHlwZSAmJiBtYXJrLnR5cGUuZXhjbHVkZXModHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBub3QgPSA8VD4oZm46ICgoYXJnczogVCkgPT4gYm9vbGVhbikpID0+IChhcmc6IFQpID0+ICFmbihhcmcpO1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlQmxvY2tNYXJrcyA9IChcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gICAgbWFya3M6IEFycmF5PE1hcmtUeXBlIHwgdW5kZWZpbmVkPixcbik6IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgc2NoZW1hIH0gPSBzdGF0ZTtcbiAgICBsZXQgeyB0ciB9ID0gc3RhdGU7XG5cbiAgICAvLyBNYXJrcyBtaWdodCBub3QgZXhpc3QgaW4gU2NoZW1hXG4gICAgY29uc3QgbWFya3NUb1JlbW92ZSA9IG1hcmtzLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAobWFya3NUb1JlbW92ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKiogU2F2ZXMgYW4gZXh0cmEgZGlzcGF0Y2ggKi9cbiAgICBsZXQgYmxvY2tNYXJrc0V4aXN0cyA9IGZhbHNlO1xuXG4gICAgY29uc3QgaGFzTWFyayA9IChtYXJrOiBNYXJrKSA9PiBtYXJrc1RvUmVtb3ZlLmluZGV4T2YobWFyay50eXBlKSA+IC0xO1xuICAgIC8qKlxuICAgICAqIFdoZW4geW91IG5lZWQgdG8gdG9nZ2xlIHRoZSBzZWxlY3Rpb25cbiAgICAgKiB3aGVuIGFub3RoZXIgdHlwZSB3aGljaCBkb2VzIG5vdCBhbGxvdyBhbGlnbm1lbnQgaXMgYXBwbGllZFxuICAgICAqL1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oc2VsZWN0aW9uLmZyb20sIHNlbGVjdGlvbi50bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBzY2hlbWEubm9kZXMucGFyYWdyYXBoICYmIG5vZGUubWFya3Muc29tZShoYXNNYXJrKSkge1xuICAgICAgICAgICAgYmxvY2tNYXJrc0V4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgICAgICBjb25zdCB3aXRob3V0QmxvY2tNYXJrcyA9IG5vZGUubWFya3MuZmlsdGVyKG5vdChoYXNNYXJrKSk7XG4gICAgICAgICAgICB0ciA9IHRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQb3MucG9zLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBub2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgIHdpdGhvdXRCbG9ja01hcmtzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBibG9ja01hcmtzRXhpc3RzID8gdHIgOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgbWFya3MgZnJvbSBub2RlcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24gdGhhdCBhcmUgbm90IHN1cHBvcnRlZFxuICovXG5leHBvcnQgY29uc3Qgc2FuaXRpemVTZWxlY3Rpb25NYXJrcyA9IChcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4pOiBUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgbGV0IHRyOiBUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnRyLnNlbGVjdGlvbjtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG5vZGUubWFya3MuZmlsdGVyKG0gPT4gbS50eXBlICE9PSBtYXJrLnR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zID4gMCA/IHBvcyAtIDEgOiAwO1xuICAgICAgICAgICAgICAgIHRyID0gKHRyIHx8IHN0YXRlLnRyKS5zZXROb2RlTWFya3VwKFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZE1hcmtzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cjtcbn07XG4iXX0=