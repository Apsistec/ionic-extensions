import { shallowEqual } from "fast-equals";
function markApplies(doc, from, to, type) {
    let applies = false;
    doc.nodesBetween(from, to, (node, pos, parent) => {
        if (applies) {
            return false;
        }
        applies = node.isInline && parent.type.allowsMarkType(type);
    });
    return applies;
}
// return true iff all nodes in range have the mark with the same attrs
function rangeHasMark(doc, from, to, type, attrs) {
    let hasMark = null;
    doc.nodesBetween(from, to, node => {
        for (let i = 0; i < node.marks.length; i++) {
            const markMatch = node.marks[i].type === type && (!attrs || shallowEqual(node.marks[i].attrs, attrs));
            hasMark = (markMatch && (hasMark === null || hasMark === true));
        }
        return hasMark;
    });
    return !!hasMark;
}
export function toggleInlineMark(markType, attrs) {
    return function (state, dispatch) {
        const { empty, from, to, $from } = state.selection;
        if (!markApplies(state.doc, from, to, markType)) {
            console.log("not applies");
            return false;
        }
        if (dispatch) {
            if (empty) {
                const markInSet = markType.isInSet(state.storedMarks || $from.marks());
                if (markInSet && (!attrs || shallowEqual(markInSet.attrs, attrs))) {
                    dispatch(state.tr.removeStoredMark(markType));
                }
                else {
                    dispatch(state.tr.addStoredMark(markType.create(attrs)));
                }
            }
            else {
                if (rangeHasMark(state.doc, from, to, markType, attrs)) {
                    dispatch(state.tr.removeMark(from, to, markType).scrollIntoView());
                }
                else {
                    dispatch(state.tr.addMark(from, to, markType.create(attrs)).scrollIntoView());
                }
            }
        }
        return true;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vZ2xlLWlubGluZS1tYXJrLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNvLm1tb25zL2lvbmljLWV4dGVuc2lvbnMvaHRtbC1lZGl0b3IvIiwic291cmNlcyI6WyJwcm9zZW1pcnJvci9jb21tYW5kcy90b29nbGUtaW5saW5lLW1hcmsudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUl6QyxTQUFTLFdBQVcsQ0FBQyxHQUFTLEVBQUUsSUFBWSxFQUFFLEVBQVUsRUFBRSxJQUFjO0lBRXBFLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztJQUVwQixHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUFFO1FBRTdDLElBQUksT0FBTyxFQUFFO1lBQ1QsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRSxDQUFDLENBQUMsQ0FBQztJQUVILE9BQU8sT0FBTyxDQUFDO0FBQ25CLENBQUM7QUFFRCx1RUFBdUU7QUFDdkUsU0FBUyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUs7SUFFNUMsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBRW5CLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRTtRQUU5QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDeEMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFLLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDdEcsT0FBTyxHQUFHLENBQUMsU0FBUyxJQUFJLENBQUMsT0FBTyxLQUFLLElBQUksSUFBSSxPQUFPLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNuRTtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDO0FBQ3JCLENBQUM7QUFFRCxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsUUFBa0IsRUFBRSxLQUE0QjtJQUU3RSxPQUFPLFVBQVMsS0FBSyxFQUFFLFFBQVE7UUFFM0IsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7UUFFbkQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLEVBQUU7WUFDN0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUMzQixPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUVELElBQUksUUFBUSxFQUFFO1lBRVYsSUFBSSxLQUFLLEVBQUU7Z0JBRVAsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxJQUFJLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUV2RSxJQUFJLFNBQVMsSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLFlBQVksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUU7b0JBQy9ELFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7aUJBQ2pEO3FCQUFNO29CQUNILFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDNUQ7YUFFSjtpQkFBTTtnQkFFSCxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxFQUFFO29CQUNwRCxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO2lCQUN0RTtxQkFBTTtvQkFDSCxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztpQkFDakY7YUFDSjtTQUNKO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQyxDQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7c2hhbGxvd0VxdWFsfSBmcm9tIFwiZmFzdC1lcXVhbHNcIjtcbmltcG9ydCB7TWFya1R5cGUsIE5vZGV9IGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuaW1wb3J0IHtDb21tYW5kfSBmcm9tIFwiLi4vY29tbWFuZFwiO1xuXG5mdW5jdGlvbiBtYXJrQXBwbGllcyhkb2M6IE5vZGUsIGZyb206IG51bWJlciwgdG86IG51bWJlciwgdHlwZTogTWFya1R5cGUpIHtcblxuICAgIGxldCBhcHBsaWVzID0gZmFsc2U7XG5cbiAgICBkb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQpID0+IHtcblxuICAgICAgICBpZiAoYXBwbGllcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbGllcyA9IG5vZGUuaXNJbmxpbmUgJiYgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBwbGllcztcbn1cblxuLy8gcmV0dXJuIHRydWUgaWZmIGFsbCBub2RlcyBpbiByYW5nZSBoYXZlIHRoZSBtYXJrIHdpdGggdGhlIHNhbWUgYXR0cnNcbmZ1bmN0aW9uIHJhbmdlSGFzTWFyayhkb2MsIGZyb20sIHRvLCB0eXBlLCBhdHRycykge1xuXG4gICAgbGV0IGhhc01hcmsgPSBudWxsO1xuXG4gICAgZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrTWF0Y2ggPSBub2RlLm1hcmtzW2ldLnR5cGUgPT09IHR5cGUgJiYgKCFhdHRycyB8fCBzaGFsbG93RXF1YWwobm9kZS5tYXJrc1tpXS5hdHRycywgYXR0cnMpKTtcbiAgICAgICAgICAgIGhhc01hcmsgPSAobWFya01hdGNoICYmIChoYXNNYXJrID09PSBudWxsIHx8IGhhc01hcmsgPT09IHRydWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNNYXJrO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICEhaGFzTWFyaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUlubGluZU1hcmsobWFya1R5cGU6IE1hcmtUeXBlLCBhdHRycz86IHtba2V5OiBzdHJpbmddOiBhbnl9KTogQ29tbWFuZCB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG5cbiAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSwgdG8sICRmcm9tIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKCFtYXJrQXBwbGllcyhzdGF0ZS5kb2MsIGZyb20sIHRvLCBtYXJrVHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm90IGFwcGxpZXNcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcblxuICAgICAgICAgICAgaWYgKGVtcHR5KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrSW5TZXQgPSBtYXJrVHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRmcm9tLm1hcmtzKCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hcmtJblNldCAmJiAoIWF0dHJzIHx8IHNoYWxsb3dFcXVhbChtYXJrSW5TZXQuYXR0cnMsIGF0dHJzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKGF0dHJzKSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmIChyYW5nZUhhc01hcmsoc3RhdGUuZG9jLCBmcm9tLCB0bywgbWFya1R5cGUsIGF0dHJzKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVNYXJrKGZyb20sIHRvLCBtYXJrVHlwZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuYWRkTWFyayhmcm9tLCB0bywgbWFya1R5cGUuY3JlYXRlKGF0dHJzKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cblxuIl19