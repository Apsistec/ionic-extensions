/**
 * Toggles block mark based on the return type of `getAttrs`.
 * This is similar to ProseMirror"s `getAttrs` from `AttributeSpec`
 * return `false` to remove the mark.
 * return `undefined for no-op.
 * return an `object` to update the mark.
 */
export const toggleBlockMark = (markType, getAttrs, allowedBlocks) => (state, dispatch) => {
    let markApplied = false;
    const tr = state.tr;
    const toggleBlockMarkOnRange = (from, to, tr) => {
        state.doc.nodesBetween(from, to, (node, pos, parent) => {
            if (!node.type.isBlock) {
                return false;
            }
            if ((!allowedBlocks || (Array.isArray(allowedBlocks) ? allowedBlocks.indexOf(node.type) > -1 : allowedBlocks(state.schema, node, parent))) &&
                parent.type.allowsMarkType(markType)) {
                const oldMarks = node.marks.filter(mark => mark.type === markType);
                const prevAttrs = oldMarks.length ? oldMarks[0].attrs : undefined;
                const newAttrs = getAttrs(prevAttrs, node);
                if (newAttrs !== undefined) {
                    tr.setNodeMarkup(pos, node.type, node.attrs, node.marks
                        .filter(mark => !markType.excludes(mark.type))
                        .concat(newAttrs === false ? [] : markType.create(newAttrs)));
                    markApplied = true;
                }
            }
            return;
        });
    };
    const { from, to } = state.selection;
    toggleBlockMarkOnRange(from, to, tr);
    if (markApplied && tr.docChanged) {
        if (dispatch) {
            dispatch(tr.scrollIntoView());
        }
        return true;
    }
    return false;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vZ2xlLWJsb2NrLW1hcmsuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY28ubW1vbnMvaW9uaWMtZXh0ZW5zaW9ucy9odG1sLWVkaXRvci8iLCJzb3VyY2VzIjpbInByb3NlbWlycm9yL2NvbW1hbmRzL3Rvb2dsZS1ibG9jay1tYXJrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUlBOzs7Ozs7R0FNRztBQUNILE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxDQUMzQixRQUFrQixFQUNsQixRQUFtRSxFQUNuRSxhQUVpRSxFQUMxRCxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLEVBQUU7SUFDOUIsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDO0lBQ3hCLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUM7SUFFcEIsTUFBTSxzQkFBc0IsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFVLEVBQUUsRUFBZSxFQUFFLEVBQUU7UUFFekUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFFbkQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNwQixPQUFPLEtBQUssQ0FBQzthQUNoQjtZQUVELElBQ0ksQ0FBQyxDQUFDLGFBQWEsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDdEksTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQ3RDO2dCQUVFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsQ0FBQztnQkFFbkUsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQVcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO2dCQUN6RSxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUUzQyxJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7b0JBRXhCLEVBQUUsQ0FBQyxhQUFhLENBQ1osR0FBRyxFQUNILElBQUksQ0FBQyxJQUFJLEVBQ1QsSUFBSSxDQUFDLEtBQUssRUFDVixJQUFJLENBQUMsS0FBSzt5QkFDTCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO3lCQUM3QyxNQUFNLENBQUMsUUFBUSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQ25FLENBQUM7b0JBRUYsV0FBVyxHQUFHLElBQUksQ0FBQztpQkFDdEI7YUFDSjtZQUVELE9BQU87UUFFWCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsQ0FBQztJQUVGLE1BQU0sRUFBQyxJQUFJLEVBQUUsRUFBRSxFQUFDLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztJQUNuQyxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRXJDLElBQUksV0FBVyxJQUFJLEVBQUUsQ0FBQyxVQUFVLEVBQUU7UUFDOUIsSUFBSSxRQUFRLEVBQUU7WUFDVixRQUFRLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUM7U0FDakM7UUFDRCxPQUFPLElBQUksQ0FBQztLQUNmO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtNYXJrVHlwZSwgTm9kZSBhcyBQTU5vZGUsIE5vZGVUeXBlLCBTY2hlbWF9IGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuaW1wb3J0IHtUcmFuc2FjdGlvbn0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5pbXBvcnQge0NvbW1hbmR9IGZyb20gXCIuLi9jb21tYW5kXCI7XG5cbi8qKlxuICogVG9nZ2xlcyBibG9jayBtYXJrIGJhc2VkIG9uIHRoZSByZXR1cm4gdHlwZSBvZiBgZ2V0QXR0cnNgLlxuICogVGhpcyBpcyBzaW1pbGFyIHRvIFByb3NlTWlycm9yXCJzIGBnZXRBdHRyc2AgZnJvbSBgQXR0cmlidXRlU3BlY2BcbiAqIHJldHVybiBgZmFsc2VgIHRvIHJlbW92ZSB0aGUgbWFyay5cbiAqIHJldHVybiBgdW5kZWZpbmVkIGZvciBuby1vcC5cbiAqIHJldHVybiBhbiBgb2JqZWN0YCB0byB1cGRhdGUgdGhlIG1hcmsuXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVCbG9ja01hcmsgPSA8VCA9IG9iamVjdD4oXG4gICAgbWFya1R5cGU6IE1hcmtUeXBlLFxuICAgIGdldEF0dHJzOiAoKHByZXZBdHRycz86IFQsIG5vZGU/OiBQTU5vZGUpID0+IFQgfCB1bmRlZmluZWQgfCBmYWxzZSksXG4gICAgYWxsb3dlZEJsb2Nrcz86XG4gICAgICAgIHwgQXJyYXk8Tm9kZVR5cGU+XG4gICAgICAgIHwgKChzY2hlbWE6IFNjaGVtYSwgbm9kZTogUE1Ob2RlLCBwYXJlbnQ6IFBNTm9kZSkgPT4gYm9vbGVhbiksXG4pOiBDb21tYW5kID0+IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgbWFya0FwcGxpZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuXG4gICAgY29uc3QgdG9nZ2xlQmxvY2tNYXJrT25SYW5nZSA9IChmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIHRyOiBUcmFuc2FjdGlvbikgPT4ge1xuXG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUudHlwZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKCFhbGxvd2VkQmxvY2tzIHx8IChBcnJheS5pc0FycmF5KGFsbG93ZWRCbG9ja3MpID8gYWxsb3dlZEJsb2Nrcy5pbmRleE9mKG5vZGUudHlwZSkgPiAtMSA6IGFsbG93ZWRCbG9ja3Moc3RhdGUuc2NoZW1hLCBub2RlLCBwYXJlbnQpKSkgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrVHlwZSlcbiAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkTWFya3MgPSBub2RlLm1hcmtzLmZpbHRlcihtYXJrID0+IG1hcmsudHlwZSA9PT0gbWFya1R5cGUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkF0dHJzID0gb2xkTWFya3MubGVuZ3RoID8gKG9sZE1hcmtzWzBdLmF0dHJzIGFzIFQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0F0dHJzID0gZ2V0QXR0cnMocHJldkF0dHJzLCBub2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdBdHRycyAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1hcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihtYXJrID0+ICFtYXJrVHlwZS5leGNsdWRlcyhtYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobmV3QXR0cnMgPT09IGZhbHNlID8gW10gOiBtYXJrVHlwZS5jcmVhdGUobmV3QXR0cnMpKSxcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBtYXJrQXBwbGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHtmcm9tLCB0b30gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdG9nZ2xlQmxvY2tNYXJrT25SYW5nZShmcm9tLCB0bywgdHIpO1xuXG4gICAgaWYgKG1hcmtBcHBsaWVkICYmIHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuIl19