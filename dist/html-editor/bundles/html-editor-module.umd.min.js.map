{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@co.mmons/ionic-extensions/html-editor/alignment.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/toogle-block-mark.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/marks/font-size.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/marks/alignment.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/nodes/youtube.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/schema.ts","ng://@co.mmons/ionic-extensions/html-editor/alignment-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/alignment/commands.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/selection/find-block-marks.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/keymap.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/views/youtube.ts","ng://@co.mmons/ionic-extensions/html-editor/scroll.ts","ng://@co.mmons/ionic-extensions/html-editor/editor.ts","ng://@co.mmons/ionic-extensions/html-editor/heading-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/link-type.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-marks-in-selection.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-marks.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-node-start-end.ts","ng://@co.mmons/ionic-extensions/html-editor/link-modal.ts","ng://@co.mmons/ionic-extensions/html-editor/insert-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/filter.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/is-empty-selection-at-start.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list/transforms/lift-following-list.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list/utils/get-list-lift-target.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-cut-before.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list-commands.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/is-first-child-of-parent.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list/transforms/lift-selection-list.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/mark-utils.ts","ng://@co.mmons/ionic-extensions/html-editor/list-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/font-sizes.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/toogle-inline-mark.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/is-active.ts","ng://@co.mmons/ionic-extensions/html-editor/text-format-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/toolbar.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/selection/is-block-mark-active.ts","ng://@co.mmons/ionic-extensions/html-editor/index.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","pop","push","__values","o","m","__read","ar","error","__spread","concat","Alignment","alignment","_alignments","MessageRef","alignments","slice","left","right","center","justify","toggleBlockMark","markType","getAttrs","allowedBlocks","state","dispatch","markApplied","tr","_a","selection","from","to","doc","nodesBetween","node","pos","parent","type","isBlock","isArray","indexOf","schema","allowsMarkType","oldMarks","marks","filter","mark","prevAttrs","attrs","undefined","newAttrs","setNodeMarkup","excludes","create","toggleBlockMarkOnRange","docChanged","scrollIntoView","fontSize","group","parseDOM","tag","dom","size","getAttribute","toDOM","style","data-font-size","align","data-align","youtube","id","default","start","inline","draggable","data-youtube","info","split","nodes","content","paragraph","blockquote","basicNodes","horizontalRule","horizontal_rule","heading","text","hardBreak","hard_break","bulletList","assign","orderedList","listItem","link","basicMarks","em","strong","underline","Schema","AlignmentMenu","popoverController","prototype","toggleAligment","_this","command","_b","editor","view","dismiss","ngOnInit","active","_c","findBlockMarks","ionViewWillLeave","focus","PopoverController","Input","Component","template","mac","navigator","test","platform","buildKeymap","mapKeys","keys","bind","cmd","mapped","undo","redo","undoInputRule","joinUp","joinDown","lift","selectParentNode","toggleMark","splitListItem","br_1","replaceSelectionWith","createYoutubeIframe","iframe","document","createElement","height","width","src","frameBorder","allow","allowFullscreen","YoutubeNodeView","eventManager","position","overflow","marginTop","setAttribute","appendChild","overlay","top","display","justifyContent","button","classList","add","deleteUnlisten","addEventListener","deleteNode","icon","slot","removeSelectedNode","selectNode","deselectNode","remove","update","destroy","stopEvent","event","ignoreMutation","findScrollParent","element","scrollHeight","clientHeight","overflowY","window","getComputedStyle","assignedSlot","parentElement","parentRect","getBoundingClientRect","rect","bottom","top_1","offsetTop","offsetParent","scrollTo","scrollToCaret","range","range0","getSelection","getRangeAt","startContainer","offset","startOffset","createRange","setStart","setEnd","styles","lineHeight","parseInt","delta","caretTopPoint","top_2","behavior","HtmlEditor","formControl","item","eventUnlisteners","change","EventEmitter","selectionChange","valueAccessor","HtmlEditor_1","idGenerator","itemInputWrapper","nativeElement","DOMSerializer","fromSchema","serializeFragment","tmp","innerText","prepareOutputValue","uninitializedValue","html","EditorState","plugins","editorDoc","updateState","silentChanges","querySelectorAll","forEach","params","innerHTML","prepareInputValue","setDisabledState","isDisabled","disabled","writeValue","registerOnChange","fn","controlOnChange","registerOnTouched","controlOnTouched","scrollParent","preventScroll","domAtPos","nodeType","Node","TEXT_NODE","querySelector","editorInitialized","editorFocused","focused","updateItemClasses","editorBlured","handleScroll","DOMParser","parse","resetControlCss","classes","ion-untouched","untouched","ion-touched","touched","ion-pristine","pristine","ion-dirty","dirty","ion-valid","valid","ion-invalid","elements","elements_1","elements_1_1","fixItemOverflow","item_1","waitTill","shadowRoot","editorTransaction","transaction","readonlyChanged","readonly","ngAfterViewInit","ngAfterContentChecked","ngOnDestroy","unlisten","keymap","baseKeymap","gapCursor","history","EditorView","dispatchTransaction","handleScrollToSelection","nodeViews","ngOnChanges","changes","ElementRef","EventManager","NgControl","Optional","IonItem","HostBinding","Output","selector","HeadingMenu","toggleHeading","activeHeading","setBlockType","level","findParentNodeOfType","DefaultLinkType","_super","inputComponent","inputType","inputValidators","urlValidator","inputLabel","Validators","email","inputHint","__","constructor","__extends","uri","fromLink","www","tel","sms","other","LinkType","toString","urlValidatorRegex","control","invalidUrl","findMarksInSelection","deepEqual","findMarks","findNodeStartEnd","$pos","textOffset","end","child","index","nodeSize","LinkModal","modalController","present","component","LinkModal_1","componentProps","close","unlink","empty","tr_1","isText","removeMark","ok","formHelper","validateAll","form","linkType_1","controls","tr_2","addMark","href","typeChanged","markAsDirty","updateValueAndValidity","sleep","parseLink","prefixes","http:","https:","tel:","sms:","mailto:","lowerCasedUri","trim","toLowerCase","prefix","startsWith","substring","linkValidator","required","validators","validators_1","validators_1_1","validator","ionViewDidEnter","types","FormGroup","FormControl","existingType","existingLink","setValidators","typeChangesSubscription","valueChanges","subscribe","MARKS","parsed","existing","unsubscribe","ModalController","ViewChild","FormHelper","static","InsertMenu","insertLink","insertYoutube","inputView","youtubeInput","setFocus","parseYoutube","replace","splice","param","applyYoutube","cancel","role","ionViewDidLeave","predicates","some","pred","isEmptySelectionAtStart","$from","parentOffset","GapCursor","liftListItem","$to","blockRange","childCount","firstChild","depth","endOfList","ReplaceAroundStep","Slice","Fragment","copy","NodeRange","liftTarget","getListLiftTarget","resPos","isRangeOfType","maxDepth","findAncestorPosition","current","Math","min","after","getAncestorNodesBetween","nestableBlocks","newPos","before","name","compose","func","funcs","_i","allFuncs","raw","reduceRight","memo","findCutBefore","spec","isolating","deletePreviousEmptyListItem","$cut","nodeBefore","delete","joinToPreviousListItem","codeBlock","isGapCursorShown","nodeAfter","$lastNode","nodeBeforePos","findPositionOfNodeBefore","list","append","createChecked","replaceWith","$postCut","mapping","map","join","isInsideListItem","hasParentNodeOfType","canToJoinToPreviousListItem","$before","canOutdent","baseCommand.chainCommands","outdentList","$start","$end","$join","mergeLists","baseListCommand.liftListItem","indentList","initialIndentationLevel","currentIndentationLevel","currentPos","resolvedPos","numberNestedLists","canSink","baseListCommand.sinkListItem","liftListItems","isTextblock","sel","NodeSelection","count","toggleList","listType","fromNode","endNode","rootListDepth","lifted","listDepth","textContent","TextSelection","liftFollowingList","listCol","paragraph_1","liftSelectionList","setSelection","isSameLine","startPos","endPos","nodeAt","adjustSelectionInList","isRangeOfSingleType","grandgrandParent","isInsideList","filteredMarks","sanitizeSelectionMarks","baseCommand.autoJoin","baseListCommand.wrapInList","toggleListCommand","ListMenu","activeUnnumberedList","findParentNode","predicate","hasMarkup","activeNumberedList","FontSize","_sizes","toUpperCase","sizes","small","large","toggleInlineMark","applies","isInline","markApplies","console","log","markInSet","isInSet","storedMarks","shallowEqual","addStoredMark","removeStoredMark","hasMark","markMatch","rangeHasMark","isMarkActive","TextFormatMenu","toggle","resetFontSize","toggleFontSize","boldActivated","italicActivated","underlineActivated","activeFontSize","_d","_e","e_2","_f","Toolbar","activeFeatures","showMenu","menu","components","insert","showBackdrop","is","editLink","editorSelectionChanged","canUndo","undoDepth","canRedo","redoDepth","types_1","types_1_1","types_2","types_2_1","anyMarkActive","isBlockMarkActive","selectionSubscription","Platform","HtmlEditorModule","NgModule","imports","CommonModule","IonicModule","IntlModule","SelectModule","FormsModule","ReactiveFormsModule","FormHelperModule","ButtonsModule","MatchMediaModule","SpinnerModule","declarations","exports","entryComponents"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {MessageRef} from \"@co.mmons/js-intl\";\n\nexport class Alignment {\n\n    private static _alignments: Alignment[] = [];\n\n    static alignments() {\n        return Alignment._alignments.slice();\n    }\n\n    static readonly left = new Alignment(\"left\");\n    static readonly right = new Alignment(\"right\");\n    static readonly center = new Alignment(\"center\");\n    static readonly justify = new Alignment(\"justify\");\n\n    private constructor(public readonly alignment: string) {\n\n        Alignment._alignments.push(this);\n\n        this.label = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"alignmentMenu/\" + alignment);\n    }\n\n    readonly label: MessageRef;\n}\n","import {MarkType, Node as PMNode, NodeType, Schema} from \"prosemirror-model\";\nimport {Transaction} from \"prosemirror-state\";\nimport {Command} from \"../command\";\n\n/**\n * Toggles block mark based on the return type of `getAttrs`.\n * This is similar to ProseMirror\"s `getAttrs` from `AttributeSpec`\n * return `false` to remove the mark.\n * return `undefined for no-op.\n * return an `object` to update the mark.\n */\nexport const toggleBlockMark = <T = object>(\n    markType: MarkType,\n    getAttrs: ((prevAttrs?: T, node?: PMNode) => T | undefined | false),\n    allowedBlocks?:\n        | Array<NodeType>\n        | ((schema: Schema, node: PMNode, parent: PMNode) => boolean),\n): Command => (state, dispatch) => {\n    let markApplied = false;\n    const tr = state.tr;\n\n    const toggleBlockMarkOnRange = (from: number, to: number, tr: Transaction) => {\n\n        state.doc.nodesBetween(from, to, (node, pos, parent) => {\n\n            if (!node.type.isBlock) {\n                return false;\n            }\n\n            if (\n                (!allowedBlocks || (Array.isArray(allowedBlocks) ? allowedBlocks.indexOf(node.type) > -1 : allowedBlocks(state.schema, node, parent))) &&\n                parent.type.allowsMarkType(markType)\n            ) {\n\n                const oldMarks = node.marks.filter(mark => mark.type === markType);\n\n                const prevAttrs = oldMarks.length ? (oldMarks[0].attrs as T) : undefined;\n                const newAttrs = getAttrs(prevAttrs, node);\n\n                if (newAttrs !== undefined) {\n\n                    tr.setNodeMarkup(\n                        pos,\n                        node.type,\n                        node.attrs,\n                        node.marks\n                            .filter(mark => !markType.excludes(mark.type))\n                            .concat(newAttrs === false ? [] : markType.create(newAttrs)),\n                    );\n\n                    markApplied = true;\n                }\n            }\n\n            return;\n\n        });\n    };\n\n    const {from, to} = state.selection;\n    toggleBlockMarkOnRange(from, to, tr);\n\n    if (markApplied && tr.docChanged) {\n        if (dispatch) {\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n\n    return false;\n};\n","import {MarkSpec} from \"prosemirror-model\";\n\nexport const fontSize: MarkSpec = {\n    excludes: \"fontSize\",\n    group: \"fontSize\",\n    attrs: {\n        fontSize: {},\n    },\n    parseDOM: [\n        {\n            tag: \"span[data-font-size]\",\n            getAttrs: dom => {\n                const size = (dom as Element).getAttribute(\"data-font-size\");\n                return size ? {fontSize: size} : false;\n            },\n        },\n    ],\n    toDOM(mark) {\n        return [\n            \"span\",\n            {style: `font-size: ${mark.attrs.fontSize}`, \"data-font-size\": mark.attrs.fontSize},\n            0\n        ];\n    },\n};\n","import {MarkSpec} from \"prosemirror-model\";\n\nexport const alignment: MarkSpec = {\n    excludes: \"alignment\",\n    group: \"alignment\",\n    attrs: {\n        align: {},\n    },\n    parseDOM: [\n        {\n            tag: \"div[data-align]\",\n            getAttrs: dom => {\n                const align = (dom as Element).getAttribute(\"data-align\");\n                return align ? {align} : false;\n            },\n        },\n    ],\n    toDOM(mark) {\n        return [\n            \"div\",\n            {\n                style: `text-align: ${mark.attrs.align}`,\n                \"data-align\": mark.attrs.align,\n            },\n            0\n        ];\n    },\n};\n","import {NodeSpec} from \"prosemirror-model\";\n\nexport const youtube: NodeSpec = {\n    attrs: {id: {default: \"\"}, start: {default: 0}},\n    inline: false,\n    group: \"block\",\n    draggable: false,\n\n    toDOM: (node) => {\n\n        return [\n            \"div\",\n            {\"data-youtube\": node.attrs.id + (node.attrs.start ? \",\" + node.attrs.start : \"\")},\n            \"youtube\"\n        ];\n    },\n\n    parseDOM: [\n        {\n            tag: \"div[data-youtube]\",\n            getAttrs: (dom) => {\n\n                // @ts-ignore\n                const info = dom.getAttribute(\"data-youtube\").split(\",\");\n\n                return {\n                    id: info[0],\n                    start: info.length > 1 ? info[1] : 0\n                };\n            },\n        }\n    ]\n};\n","import {MarkSpec, NodeSpec, Schema} from \"prosemirror-model\";\nimport {marks as basicMarks, nodes as basicNodes} from \"prosemirror-schema-basic\";\nimport {bulletList, listItem, orderedList} from \"prosemirror-schema-list\";\nimport {fontSize} from \"./marks/font-size\";\nimport {alignment} from \"./marks/alignment\";\nimport {youtube} from \"./nodes/youtube\";\n\nexport const nodes = {\n    doc: {\n        content: \"block+\",\n        marks: \"alignment\",\n    },\n\n    paragraph: {\n        content: \"inline*\",\n        marks: \"alignment strong underline em fontSize link\",\n        group: \"block\",\n        parseDOM: [{tag: \"p\"}],\n        toDOM() { return [\"p\", 0]; }\n    } as NodeSpec,\n\n    blockquote: basicNodes.blockquote,\n    horizontalRule: basicNodes.horizontal_rule,\n    heading: basicNodes.heading,\n    text: basicNodes.text,\n    hardBreak: basicNodes.hard_break,\n\n    bulletList: Object.assign({}, bulletList, {\n        content: \"listItem+\",\n        group: \"block\"\n    }) as NodeSpec,\n\n    orderedList: Object.assign({}, orderedList, {\n        content: \"listItem+\",\n        group: \"block\"\n    }) as NodeSpec,\n\n    listItem: Object.assign({}, listItem, {\n        content: \"paragraph block*\",\n        marks: \"alignment\"\n    }) as NodeSpec,\n\n    youtube\n};\n\nexport const marks = {\n    link: basicMarks.link,\n    em: basicMarks.em,\n    strong: basicMarks.strong,\n    alignment,\n    fontSize: fontSize,\n\n    underline: {\n        parseDOM: [{tag: \"u\"}, {style: \"text-decoration=underline\"}],\n        toDOM() {\n            return [\"u\", 0];\n        }\n    } as MarkSpec\n};\n\nexport const schema = new Schema<keyof typeof nodes, keyof typeof marks>({nodes: nodes, marks: marks});\n\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {Alignment} from \"./alignment\";\nimport {HtmlEditor} from \"./editor\";\nimport {changeAlignment} from \"./prosemirror/alignment/commands\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findBlockMarks} from \"./prosemirror/utils/selection/find-block-marks\";\n\n@Component({\n    styles: [`\n        :host ion-list { margin: 0px; padding: 0px; }\n        :host ion-item:last-child { --border-width: 0px; }\n    `],\n    template: `\n        <ion-list lines=\"full\">\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleAligment(alignment)\" *ngFor=\"let alignment of Alignment.alignments()\">\n                <ion-label>{{alignment.label | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"active === alignment.alignment\"></ion-icon>\n                <ion-icon src=\"assets/html-editor/align-{{alignment.alignment}}.svg\" slot=\"start\"></ion-icon>\n            </ion-item>\n\n        </ion-list>\n    `\n})\nexport class AlignmentMenu implements OnInit {\n\n    Alignment = Alignment;\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    active: string;\n\n    toggleAligment(alignment: Alignment) {\n\n        const command = changeAlignment(<any>alignment.alignment);\n\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n\n        this.active = undefined;\n\n        for (const mark of findBlockMarks(this.editor.state, schema.marks.alignment)) {\n\n            // zaznaczonych wiele blocków z różnym wyrównaniem\n            if (this.active && this.active !== mark.attrs.align) {\n                this.active = undefined;\n                break;\n            }\n\n            this.active = mark.attrs.align;\n        }\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {EditorState, Transaction} from \"prosemirror-state\";\nimport {Command, CommandDispatch} from \"../command\";\nimport {toggleBlockMark} from \"../commands/toogle-block-mark\";\nimport {AlignmentState} from \"./alignment-state\";\n\n/**\n * Iterates over the commands one after the other,\n * passes the tr through and dispatches the cumulated transaction\n */\nexport const cascadeCommands = (cmds: Array<Command>) => (\n    state: EditorState,\n    dispatch?: CommandDispatch,\n) => {\n    const {tr: baseTr} = state;\n    let shouldDispatch = false;\n\n    const onDispatchAction = (tr: Transaction) => {\n        tr.steps.forEach(st => {\n            baseTr.step(st);\n        });\n        shouldDispatch = true;\n    };\n\n    cmds.forEach(cmd => {\n        cmd(state, onDispatchAction);\n    });\n\n    if (dispatch && shouldDispatch) {\n        dispatch(baseTr);\n        return true;\n    }\n    return false;\n};\n\nexport const isAlignable = (align?: AlignmentState): Command => (state, dispatch) => {\n\n    const {\n        nodes: {paragraph, heading},\n        marks: {alignment},\n    } = state.schema;\n\n    return toggleBlockMark(\n        alignment,\n        () => (!align ? undefined : align === \"left\" ? false : {align}),\n        [paragraph, heading],\n    )(state, dispatch);\n};\n\nexport const changeAlignment = (align?: AlignmentState): Command => (state, dispatch) => {\n\n    const {\n        nodes: {paragraph, heading},\n        marks: {alignment}\n    } = state.schema;\n\n    return toggleBlockMark(alignment,\n        () => (!align ? undefined : align === \"left\" ? false : {align}),\n        [paragraph, heading],\n    )(state, dispatch);\n};\n","import {Mark, MarkType} from \"prosemirror-model\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport function findBlockMarks(state: EditorState, markType: MarkType) {\n\n    const marks: Mark[] = [];\n\n    const {from, to} = state.selection;\n\n    state.doc.nodesBetween(from, to, (node, pos, parent) => {\n\n        if (!node.type.isBlock) {\n            return false;\n        }\n\n        for (const mark of node.marks) {\n            if (mark.type === markType) {\n                marks.push(mark);\n            }\n        }\n\n    });\n\n\n    return marks;\n}\n","import {joinDown, joinUp, lift, selectParentNode, toggleMark} from \"prosemirror-commands\";\nimport {redo, undo} from \"prosemirror-history\";\nimport {undoInputRule} from \"prosemirror-inputrules\";\nimport {Schema} from \"prosemirror-model\";\nimport {splitListItem} from \"prosemirror-schema-list\";\n\nconst mac = typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n\nexport function buildKeymap(schema: Schema, mapKeys?: any) {\n\n    const keys = {};\n    let type: any;\n\n    function bind(key, cmd) {\n\n        if (mapKeys) {\n            const mapped = mapKeys[key];\n\n            if (mapped === false) {\n                return;\n            }\n\n            if (mapped) {\n                key = mapped;\n            }\n        }\n\n        keys[key] = cmd;\n    }\n\n\n    bind(\"Mod-z\", undo);\n    bind(\"Shift-Mod-z\", redo);\n    bind(\"Backspace\", undoInputRule);\n    if (!mac) {\n        bind(\"Mod-y\", redo);\n    }\n\n    bind(\"Alt-ArrowUp\", joinUp);\n    bind(\"Alt-ArrowDown\", joinDown);\n    bind(\"Mod-BracketLeft\", lift);\n    bind(\"Escape\", selectParentNode);\n\n    if (type = schema.marks.strong) {\n        bind(\"Mod-b\", toggleMark(type));\n        bind(\"Mod-B\", toggleMark(type));\n    }\n\n    if (type = schema.marks.em) {\n        bind(\"Mod-i\", toggleMark(type));\n        bind(\"Mod-I\", toggleMark(type));\n    }\n\n    if (type = schema.marks.underline) {\n        bind(\"Mod-u\", toggleMark(type));\n        bind(\"Mod-U\", toggleMark(type));\n    }\n\n    if (type = schema.nodes.listItem) {\n        bind(\"Enter\", splitListItem(type));\n    }\n\n    if (type = schema.nodes.hardBreak) {\n\n        const br = type;\n\n        const cmd = (state, dispatch) => {\n            dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());\n            return true;\n        };\n\n        bind(\"Mod-Enter\", cmd);\n        bind(\"Shift-Enter\", cmd);\n\n        if (mac) {\n            bind(\"Ctrl-Enter\", cmd);\n        }\n    }\n\n    return keys;\n}\n","import {EventManager} from \"@angular/platform-browser\";\nimport {Node} from \"prosemirror-model\";\nimport {removeSelectedNode} from \"prosemirror-utils\";\nimport {EditorView, NodeView} from \"prosemirror-view\";\n\nexport function createYoutubeIframe(id: string, start?: string) {\n\n    const iframe = document.createElement(\"iframe\");\n    iframe.height = \"200px\";\n    iframe.width = \"100%\";\n    iframe.src = `https://www.youtube.com/embed/${id}${start ? \"?start=\" + start : \"\"}`;\n    iframe.frameBorder = \"0\";\n    iframe.allow = \"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\";\n    iframe.allowFullscreen = true;\n\n    return iframe;\n}\n\n// https://www.youtube.com/watch?v=m3V7_Ov52sY\nexport class YoutubeNodeView implements NodeView {\n\n    constructor(node: Node, protected view: EditorView, eventManager: EventManager) {\n\n        this.dom = document.createElement(\"div\");\n        this.dom.style.position = \"relative\";\n        this.dom.style.overflow = \"hidden\";\n        this.dom.style.height = \"200px\";\n        this.dom.style.marginTop = \"16px\";\n        this.dom.setAttribute(\"no-blur\", \"\");\n\n        this.dom.appendChild(createYoutubeIframe(node.attrs.id, node.attrs.start));\n\n        const overlay = this.dom.appendChild(document.createElement(\"div\"));\n        overlay.style.position = \"absolute\";\n        overlay.style.left = \"0px\";\n        overlay.style.top = \"0px\";\n        overlay.style.width = \"100%\";\n        overlay.style.height = \"200px\";\n        overlay.style.display = \"flex\";\n        overlay.style.justifyContent = \"center\";\n\n        const button = overlay.appendChild(document.createElement(\"ion-button\"));\n        button.classList.add(\"ionx--interactive\");\n        button.setAttribute(\"color\", \"primary\");\n        this.deleteUnlisten = eventManager.addEventListener(button, \"click\", () => this.deleteNode());\n\n        const icon = document.createElement(\"ion-icon\");\n        icon.setAttribute(\"name\", \"trash\");\n        icon.slot = \"icon-only\";\n        button.appendChild(icon);\n    }\n\n    private deleteUnlisten: Function;\n\n    dom: HTMLElement;\n\n    private deleteNode() {\n        this.view.dispatch(removeSelectedNode(this.view.state.tr));\n    }\n\n    selectNode() {\n        this.dom.classList.add(\"ionx--selected\");\n    }\n\n    deselectNode() {\n        this.dom.classList.remove(\"ionx--selected\");\n    }\n\n    update(node: Node) {\n        return false;\n    }\n\n    destroy() {\n\n        if (this.deleteUnlisten) {\n            this.deleteUnlisten();\n        }\n    }\n\n    stopEvent(event: Event) {\n        return false;\n    }\n\n    ignoreMutation() {\n        return true;\n    }\n}\n","export function findScrollParent(element: HTMLElement): HTMLElement {\n\n    if (!element) {\n        return;\n    }\n\n    if (element.scrollHeight >= element.clientHeight) {\n        const overflowY = window.getComputedStyle(element).overflowY;\n        if (overflowY !== \"visible\" && overflowY !== \"hidden\") {\n            return element;\n        }\n    }\n\n    if (element.assignedSlot) {\n        const p = findScrollParent(element.assignedSlot.parentElement);\n        if (p) {\n            return p;\n        }\n    }\n\n    return findScrollParent(element.parentElement);\n}\n\nexport function scrollIntoView(element: HTMLElement, parent: HTMLElement) {\n\n    if (parent) {\n\n        const parentRect = parent.getBoundingClientRect();\n        const rect = element.getBoundingClientRect();\n\n        if (!(rect.top > parentRect.top && rect.top <= parentRect.bottom && rect.bottom < parentRect.height)) {\n\n            let top = element.offsetTop - 100;\n\n            if (element.offsetParent) {\n                let offsetParent = element.offsetParent as HTMLElement;\n                while (offsetParent !== parent && !!offsetParent) {\n                    top += offsetParent.offsetTop;\n                    offsetParent = offsetParent.offsetParent as HTMLElement;\n                }\n            }\n\n            parent.scrollTo({top: top});\n        }\n\n        return;\n    }\n\n    element.scrollIntoView();\n}\n\nexport function scrollToCaret(parent: HTMLElement) {\n\n    if (parent) {\n\n        const parentRect = parent.getBoundingClientRect();\n        const rect = caretTopPoint();\n        rect.top -= 100;\n\n        if (!(rect.top > parentRect.top && rect.top <= parentRect.bottom)) {\n\n            let top = rect.top - parentRect.top;\n            parent.scrollTo({top: top, behavior: \"auto\"});\n        }\n\n        return;\n    }\n\n}\n\nexport function caretTopPoint(): {left: number, top: number} {\n\n    const selection = document.getSelection();\n    const range0 = selection.getRangeAt(0);\n\n    let rect: {left: number, top: number};\n    let range: Range;\n\n    // supposed to be textNode in most cases\n    // but div[contenteditable] when empty\n    const node = range0.startContainer as Element;\n\n    const offset = range0.startOffset;\n    if (offset > 0) {\n\n        // new range, don't influence DOM state\n        range = document.createRange();\n        range.setStart(node, (offset - 1));\n        range.setEnd(node, offset);\n\n        // https://developer.mozilla.org/en-US/docs/Web/API/range.getBoundingClientRect\n        // IE9, Safari?(but look good in Safari 8)\n        rect = range.getBoundingClientRect();\n\n        return {left: rect[\"right\"], top: rect.top};\n\n    } else if (offset < node[\"length\"]) {\n\n        range = document.createRange();\n        // similar but select next on letter\n        range.setStart(node, offset);\n        range.setEnd(node, (offset + 1));\n        rect = range.getBoundingClientRect();\n\n        return {left: rect.left, top: rect.top};\n\n    } else {\n        // textNode has length\n\n        // https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect\n        rect = node.getBoundingClientRect();\n        const styles = getComputedStyle(node);\n        const lineHeight = parseInt(styles.lineHeight);\n        const fontSize = parseInt(styles.fontSize);\n\n        // roughly half the whitespace... but not exactly\n        const delta = (lineHeight - fontSize) / 2;\n\n        return {left: rect.left, top: (rect.top + delta)};\n    }\n\n}\n","import {AfterContentChecked, AfterViewInit, Component, ElementRef, EventEmitter, HostBinding, Input, OnChanges, OnDestroy, OnInit, Optional, Output, SimpleChanges} from \"@angular/core\";\nimport {ControlValueAccessor, NgControl} from \"@angular/forms\";\nimport {EventManager} from \"@angular/platform-browser\";\nimport {waitTill} from \"@co.mmons/js-utils/core\";\nimport {IonItem} from \"@ionic/angular\";\nimport {baseKeymap} from \"prosemirror-commands\";\nimport {gapCursor} from \"prosemirror-gapcursor\";\nimport {history} from \"prosemirror-history\";\nimport {keymap} from \"prosemirror-keymap\";\nimport {DOMParser, DOMSerializer, Schema} from \"prosemirror-model\";\nimport {EditorState, Plugin, Transaction} from \"prosemirror-state\";\nimport {EditorView} from \"prosemirror-view\";\nimport {HtmlEditorFeatures} from \"./editor-features\";\nimport {buildKeymap} from \"./prosemirror/keymap\";\nimport {schema} from \"./prosemirror/schema\";\nimport {createYoutubeIframe, YoutubeNodeView} from \"./prosemirror/views/youtube\";\nimport {findScrollParent, scrollIntoView, scrollToCaret} from \"./scroll\";\n\n@Component({\n    selector: \"ionx-html-editor\",\n    template: `\n        <ionx-html-editor-toolbar [style.display]=\"readonly ? 'none' : ''\"></ionx-html-editor-toolbar>\n    `,\n    styleUrls: [\"editor.scss\"]\n})\nexport class HtmlEditor implements OnInit, AfterViewInit, ControlValueAccessor, AfterContentChecked, OnDestroy, OnChanges {\n\n    private static idGenerator: number = 0;\n\n    constructor(\n        private element: ElementRef<HTMLElement>,\n        public eventManager: EventManager,\n        @Optional() private formControl: NgControl,\n        @Optional() private item: IonItem\n    ) {\n\n        if (formControl) {\n            this.formControl.valueAccessor = this;\n        }\n\n        this.id = \"ionx-trix-editor\" + (HtmlEditor.idGenerator++);\n        this.itemInputWrapper = !!this.item;\n\n        this.element.nativeElement.setAttribute(\"no-blur\", \"\");\n    }\n\n    private eventUnlisteners: Function[] = [];\n\n    readonly id: string;\n\n    @HostBinding(\"class.ionx-item-input-wrapper\")\n    /*private*/ itemInputWrapper: boolean;\n\n    @Input()\n    features: HtmlEditorFeatures;\n\n    @Input()\n    disabled: boolean;\n\n    @Input()\n    readonly: boolean;\n\n    /**\n     * Value, that should be set when editor is fully initialized.\n     */\n    private uninitializedValue: any;\n\n    private controlOnChange: Function;\n\n    private controlOnTouched: Function;\n\n    private focused: boolean;\n\n    private silentChanges: boolean;\n\n    view: EditorView;\n\n    get state() {\n        return this.view.state;\n    }\n\n    private schema: Schema;\n\n    private plugins: Plugin[];\n\n    private scrollParent: HTMLElement;\n\n    @Output()\n    readonly change: EventEmitter<any> = new EventEmitter();\n\n    @Output()\n    readonly selectionChange: EventEmitter<any> = new EventEmitter();\n\n    @Input()\n    public set value(html: string) {\n\n        if (this.view) {\n\n            const state = EditorState.create({\n                schema: this.view.state.schema,\n                plugins: this.view.state.plugins,\n                doc: this.editorDoc(html || \"<div></div>\")\n            });\n\n            this.view.updateState(state);\n\n        } else {\n            this.uninitializedValue = html;\n        }\n\n        this.silentChanges = false;\n    }\n\n    public get value(): string {\n        if (this.view) {\n            const value = DOMSerializer.fromSchema(this.schema).serializeFragment(this.state.doc.content);\n            const tmp = document.createElement(\"div\");\n            tmp.appendChild(value);\n\n            if (!tmp.innerText) {\n                return null;\n            } else {\n                return this.prepareOutputValue(tmp);\n            }\n\n        } else {\n            return this.uninitializedValue;\n        }\n    }\n\n    get nativeElement(): HTMLElement {\n        return this.element.nativeElement;\n    }\n\n    private prepareOutputValue(value: HTMLElement) {\n\n        value.querySelectorAll(\"div[data-youtube]\").forEach((node: HTMLElement) => {\n            const params = node.getAttribute(\"data-youtube\").split(\",\");\n            node.appendChild(createYoutubeIframe(params[0], params.length > 1 ? params[1] : undefined));\n        });\n\n        return value.innerHTML;\n    }\n\n    private prepareInputValue(value: HTMLElement) {\n\n    }\n\n    setDisabledState(isDisabled: boolean): void {\n        this.disabled = !!isDisabled;\n    }\n\n    writeValue(value: any) {\n        this.silentChanges = true;\n        this.value = value;\n    }\n\n    registerOnChange(fn: Function): void {\n        this.controlOnChange = fn;\n    }\n\n    registerOnTouched(fn: Function): void {\n        this.controlOnTouched = fn;\n    }\n\n    focus() {\n\n        if (!this.scrollParent) {\n            this.scrollParent = findScrollParent(this.element.nativeElement);\n        }\n\n        (this.view.dom as HTMLElement).focus({preventScroll: true});\n\n        const pos = this.view.domAtPos(this.view.state.selection.to);\n        if (pos.node) {\n            if (pos.node.nodeType === Node.TEXT_NODE) {\n                scrollToCaret(this.scrollParent);\n            } else {\n                scrollIntoView(this.view.dom.querySelector(\".ionx--selected\") || pos.node as HTMLElement, this.scrollParent);\n            }\n        }\n    }\n\n    // @ts-ignore\n    private async editorInitialized(event: Event) {\n\n        if (this.uninitializedValue) {\n            // this.trixEditor.loadHTML(this.uninitializedValue);\n        }\n\n        // this.trixEditorController.toolbarController.applyKeyboardCommand = this.applyKeyboardCommand.bind(this);\n    }\n\n    // @ts-ignore\n    private editorFocused(event: Event) {\n\n        if (this.controlOnTouched) {\n            this.controlOnTouched(true);\n        }\n\n        this.focused = true;\n        this.updateItemClasses();\n    }\n\n    // @ts-ignore\n    private editorBlured(event: Event) {\n        this.focused = false;\n        this.updateItemClasses();\n    }\n\n    private handleScroll(view: EditorView) {\n\n        if (!this.scrollParent) {\n            this.scrollParent = findScrollParent(this.element.nativeElement);\n        }\n\n        const pos = view.domAtPos(view.state.selection.to);\n        if (pos.node) {\n            if (pos.node.nodeType === Node.TEXT_NODE) {\n                scrollToCaret(this.scrollParent);\n            } else {\n                scrollIntoView(view.dom.querySelector(\".ionx--selected\") || pos.node as HTMLElement, this.scrollParent);\n            }\n        }\n\n        return false;\n    }\n\n    private editorDoc(html: string) {\n\n        const node = document.createElement(\"div\");\n        node.innerHTML = html;\n        this.prepareInputValue(node);\n\n        return DOMParser.fromSchema(this.schema).parse(node);\n    }\n\n    private resetControlCss() {\n\n        const classes = {\n            \"ion-untouched\": this.formControl.untouched,\n            \"ion-touched\": this.formControl.touched,\n            \"ion-pristine\": this.formControl.pristine,\n            \"ion-dirty\": this.formControl.dirty,\n            \"ion-valid\": this.formControl.valid,\n            \"ion-invalid\": !this.formControl.valid\n        };\n\n        const elements: HTMLElement[] = [];\n        elements.push(this.element.nativeElement);\n\n        if (this.item) {\n            elements.push(this.item[\"el\"]);\n        }\n\n        for (const e of elements) {\n            for (const c in classes) {\n                if (classes[c]) {\n                    e.classList.add(c);\n                } else {\n                    e.classList.remove(c);\n                }\n            }\n        }\n    }\n\n    private updateItemClasses() {\n\n        if (!this.item) {\n            return;\n        }\n\n        const item: HTMLElement = this.item[\"el\"];\n\n        if (this.disabled) {\n            item.classList.remove(\"item-interactive\");\n        } else {\n            item.classList.add(\"item-interactive\");\n        }\n\n        if (this.focused) {\n            item.classList.add(\"item-has-focus\");\n        } else {\n            item.classList.remove(\"item-has-focus\");\n        }\n    }\n\n    private async fixItemOverflow() {\n\n        if (this.item) {\n            const item: HTMLElement = this.item[\"el\"];\n            await waitTill(() => !!item.shadowRoot && !!item.shadowRoot.querySelector(\".item-inner\"));\n\n            item.style.overflow = \"initial\";\n\n            const style = document.createElement(\"style\");\n            style.innerHTML = `.item-native, .item-inner, .input-wrapper { overflow: initial !important; }`;\n            item.shadowRoot.appendChild(style);\n        }\n\n    }\n\n    private editorTransaction(transaction: Transaction) {\n\n        (this.view.dom as HTMLElement).focus({preventScroll: true});\n\n        this.view.updateState(this.view.state.apply(transaction));\n\n        this.focus();\n\n        this.selectionChange.next();\n\n        if (transaction.docChanged) {\n            this.change.next();\n\n            if (this.controlOnChange && !this.silentChanges) {\n                this.controlOnChange(this.value);\n            }\n        }\n\n        this.silentChanges = false;\n    }\n\n    private readonlyChanged() {\n\n        if (this.view) {\n            this.view.dom[\"contentEditable\"] = !this.readonly && !this.disabled ? \"true\" : \"false\";\n        }\n\n    }\n\n    ngAfterViewInit(): void {\n        this.fixItemOverflow();\n        this.updateItemClasses();\n    }\n\n    ngAfterContentChecked() {\n        this.resetControlCss();\n    }\n\n    ngOnDestroy() {\n\n        for (const unlisten of this.eventUnlisteners) {\n            unlisten();\n        }\n\n        this.view.destroy();\n        this.view = undefined;\n    }\n\n    ngOnInit() {\n\n        this.schema = schema;\n\n        this.plugins = [\n            keymap(buildKeymap(schema)),\n            keymap(baseKeymap),\n            gapCursor(),\n            history()\n        ];\n\n        const state = EditorState.create({\n            schema: this.schema,\n            plugins: this.plugins,\n            doc: this.editorDoc(this.uninitializedValue ? this.uninitializedValue : \"<div></div>\")\n        });\n\n        this.view = new EditorView(this.element.nativeElement, {\n            state: state,\n            dispatchTransaction: (transaction) => this.editorTransaction(transaction),\n            handleScrollToSelection: (view) => this.handleScroll(view),\n\n            nodeViews: {\n                youtube: (node, view) => new YoutubeNodeView(node, view, this.eventManager)\n            }\n        });\n\n        this.silentChanges = false;\n\n        if (this.readonly || this.disabled) {\n            this.readonlyChanged();\n        }\n    }\n\n    ngOnChanges(changes: SimpleChanges): void {\n\n        if (changes[\"readonly\"] || changes[\"disabled\"]) {\n            this.readonlyChanged();\n        }\n\n    }\n}\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {HtmlEditor} from \"./editor\";\nimport {schema} from \"./prosemirror/schema\";\nimport {setBlockType} from \"prosemirror-commands\";\nimport {findParentNodeOfType} from \"prosemirror-utils\";\n\n@Component({\n    styles: [\n        `:host ion-list { margin: 0px; padding: 0px }`,\n        `:host ion-item:last-child { --border-width: 0px; }`,\n    ],\n    template: `\n        <ion-list lines=\"full\">\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(0)\" *ngIf=\"activeHeading > 0\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#Plain text\" | intlMessage}}</ion-label>\n            </ion-item>\n            \n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(1)\">\n                <ion-label style=\"font-size: 130%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 1</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 1\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(2)\">\n                <ion-label style=\"font-size: 125%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 2</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 2\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(3)\">\n                <ion-label style=\"font-size: 120%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 3</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 3\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(4)\">\n                <ion-label style=\"font-size: 115%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 4</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 4\"></ion-icon>\n            </ion-item>\n            \n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(5)\">\n                <ion-label style=\"font-size: 110%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 5</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 5\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(6)\">\n                <ion-label style=\"font-size: 105%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 6</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 6\"></ion-icon>\n            </ion-item>\n            \n        </ion-list>\n    `\n})\nexport class HeadingMenu implements OnInit {\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    activeHeading: number;\n\n    @Input()\n    editor: HtmlEditor;\n\n\n    toggleHeading(heading: number) {\n\n        if (heading > 0 && this.activeHeading !== heading) {\n\n            const command = setBlockType(schema.nodes.heading, {level: heading});\n            if (command(this.editor.state)) {\n                command(this.editor.state, (tr) => {\n                    this.editor.view.dispatch(tr);\n                });\n            }\n\n        } else {\n            setBlockType(schema.nodes.paragraph)(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n\n        const active = findParentNodeOfType(schema.nodes.heading)(this.editor.state.selection);\n        if (active) {\n            this.activeHeading = active.node.attrs.level;\n        }\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {AbstractControl, ValidationErrors, ValidatorFn, Validators} from \"@angular/forms\";\nimport {MessageRef} from \"@co.mmons/js-intl\";\n\nexport abstract class LinkType {\n\n    protected constructor(public readonly type: string) {\n    }\n\n    abstract get label(): MessageRef;\n\n    abstract get inputType(): string;\n\n    abstract get inputComponent(): any;\n\n    abstract get inputValidators(): ValidatorFn[];\n\n    abstract get inputHint(): MessageRef;\n\n    abstract get inputLabel(): MessageRef;\n\n    abstract uri(fromLink: string): string;\n\n    toString() {\n        return this.type;\n    }\n}\n\nexport class DefaultLinkType extends LinkType {\n\n    static readonly www = new DefaultLinkType(\"www\");\n    static readonly email = new DefaultLinkType(\"email\");\n    static readonly tel = new DefaultLinkType(\"tel\");\n    static readonly sms = new DefaultLinkType(\"sms\");\n    static readonly other = new DefaultLinkType(\"other\");\n\n    constructor(type: string) {\n        super(type);\n\n        this.label = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/type/\" + type);\n\n        if (type === \"www\") {\n            this.inputType = \"url\";\n        } else if (type === \"other\") {\n            this.inputType = \"text\";\n        } else if (type === \"sms\") {\n            this.inputType = \"sms\";\n        } else {\n            this.inputType = type;\n        }\n\n        if (type === \"www\") {\n            this.inputValidators = [urlValidator];\n            this.inputLabel = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/Web page url\");\n        }\n\n        if (type === \"email\") {\n            this.inputValidators = [Validators.email];\n            this.inputLabel = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/E-mail address\");\n        }\n\n        if (type === \"tel\" || type === \"sms\") {\n            this.inputLabel = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/Phone number\");\n            this.inputHint = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/phoneNumberHint\");\n        }\n    }\n\n\n    readonly label: MessageRef;\n\n    readonly inputType: string;\n\n    readonly inputValidators: ValidatorFn[];\n\n    readonly inputComponent = undefined;\n\n    readonly inputLabel: MessageRef;\n\n    readonly inputHint: MessageRef;\n\n    uri(fromLink: string) {\n\n        if (this.type === \"www\" || this.type === \"other\") {\n            return fromLink;\n        } else if (this.type === \"tel\") {\n            return `tel:${fromLink}`;\n        } else if (this.type === \"sms\") {\n            return `sms:${fromLink}`;\n        } else if (this.type === \"email\") {\n            return `mailto:${fromLink}`;\n        }\n\n        return fromLink;\n    }\n\n}\n\nconst urlValidatorRegex = /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i;\n\nfunction urlValidator(control: AbstractControl): ValidationErrors {\n\n    const value = control.value;\n\n    if (urlValidatorRegex.test(value)) {\n        return undefined;\n    }\n\n    return {\n        invalidUrl: new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/invalidUrlError\")\n    };\n}\n","import {findMarks} from \"./find-marks\";\nimport {MarkType} from \"prosemirror-model\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport function findMarksInSelection(state: EditorState, markType: MarkType, attrs?: {[key: string]: any}) {\n    const doc = state.doc;\n    const {from, to} = state.selection;\n    return findMarks(doc, from, to, markType, attrs);\n}\n","import {deepEqual} from \"fast-equals\";\nimport {Mark, MarkType, Node} from \"prosemirror-model\";\n\nexport function findMarks(doc: Node, from: number, to: number, markType: MarkType, attrs?: {[key: string]: any}) {\n\n    const marks: Mark[] = [];\n\n    doc.nodesBetween(from, to, node => {\n\n        for (let i = 0; i < node.marks.length; i++) {\n            if (node.marks[i].type === markType && (!attrs || deepEqual(node.marks[i].attrs, attrs))) {\n                marks.push(node.marks[i]);\n            }\n        }\n\n    });\n\n    return marks;\n}\n","import {Node} from \"prosemirror-model\";\n\nexport function findNodeStartEnd(doc: Node, pos: number) {\n\n    const $pos = doc.resolve(pos);\n    const start = pos - $pos.textOffset;\n    const end = start + $pos.parent.child($pos.index()).nodeSize;\n\n    return {start, end};\n}\n","import {Component, Input, OnDestroy, OnInit, ViewChild} from \"@angular/core\";\nimport {AbstractControl, FormControl, FormGroup, ValidationErrors, Validators} from \"@angular/forms\";\nimport {FormHelper} from \"@co.mmons/ionic-extensions/form-helper\";\nimport {sleep, waitTill} from \"@co.mmons/js-utils/core\";\nimport {unsubscribe} from \"@co.mmons/rxjs-utils\";\nimport {ModalController} from \"@ionic/angular\";\nimport {toggleMark} from \"prosemirror-commands\";\nimport {Subscription} from \"rxjs\";\nimport {HtmlEditor} from \"./editor\";\nimport {DefaultLinkType, LinkType} from \"./link-type\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findMarksInSelection} from \"./prosemirror/utils/find-marks-in-selection\";\nimport {findNodeStartEnd} from \"./prosemirror/utils/find-node-start-end\";\n\n@Component({\n    templateUrl: \"link-modal.html\",\n    styles: [\n        `:host ion-item:not(.ion-dirty) { --highlight-height: 0px; }`\n    ]\n})\nexport class LinkModal implements OnDestroy, OnInit {\n\n    static async present(modalController: ModalController, editor: HtmlEditor) {\n\n        const modal = await modalController.create({component: LinkModal, componentProps: {editor: editor}});\n        modal.present();\n    }\n\n    constructor(private modalController: ModalController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    existing: boolean;\n\n    private existingType: LinkType;\n\n    private existingLink: string;\n\n    types: LinkType[];\n\n    form: FormGroup;\n\n    @ViewChild(FormHelper, {static: false})\n    formHelper: FormHelper;\n\n    async close() {\n        await this.modalController.dismiss();\n        this.editor.focus();\n    }\n\n    async unlink() {\n\n        await this.modalController.dismiss();\n\n        const selection = this.editor.state.selection;\n\n        if (selection.empty) {\n\n            const tr = this.editor.state.tr;\n\n            tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n                if (node.isText) {\n                    const $pos = tr.doc.resolve(pos);\n                    const start = pos - $pos.textOffset;\n                    const end = start + $pos.parent.child($pos.index()).nodeSize;\n\n                    tr.removeMark(start, end, schema.marks.link);\n                }\n            });\n\n            this.editor.view.dispatch(tr);\n\n        } else {\n            toggleMark(schema.marks.link)(this.editor.state, tr => this.editor.view.dispatch(tr));\n        }\n    }\n\n    async ok() {\n        this.formHelper.validateAll(\"dirty\");\n\n        if (this.form.valid) {\n            await this.modalController.dismiss();\n\n            const linkType = this.form.controls.type.value as LinkType;\n            const selection = this.editor.state.selection;\n\n            const tr = this.editor.state.tr;\n\n            if (selection.empty) {\n\n                tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n                    if (node.isText) {\n                        const {start, end} = findNodeStartEnd(tr.doc, pos);\n                        tr.addMark(start, end, schema.mark(schema.marks.link, {href: linkType.uri(this.form.controls.link.value)}));\n                    }\n                });\n\n            } else {\n\n                // usuwamy poprzedni link\n                tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n                    if (node.isText) {\n                        const {start, end} = findNodeStartEnd(tr.doc, pos);\n                        tr.removeMark(start, end, schema.marks.link);\n                    }\n                });\n\n                tr.addMark(selection.from, selection.to, schema.mark(schema.marks.link, {href: linkType.uri(this.form.controls.link.value)}));\n            }\n\n            this.editor.view.dispatch(tr);\n        }\n    }\n\n    private async typeChanged() {\n\n        if (this.form.controls.link.value) {\n            this.form.controls.link.markAsDirty();\n            this.form.controls.link.updateValueAndValidity();\n        }\n\n        await sleep(50); // we must wait for closing type selector\n\n        if (this.formHelper) {\n            this.formHelper.focus(\"link\", false);\n        }\n    }\n\n    private parseLink(uri: string): {type: LinkType, link: string} {\n\n        const prefixes = {\n            \"http:\": DefaultLinkType.www,\n            \"https:\": DefaultLinkType.www,\n            \"tel:\": DefaultLinkType.tel,\n            \"sms:\": DefaultLinkType.sms,\n            \"mailto:\": DefaultLinkType.email\n        };\n\n        const lowerCasedUri = uri.trim().toLowerCase();\n\n        for (const prefix of Object.keys(prefixes)) {\n            if (lowerCasedUri.startsWith(prefix)) {\n\n                const link = {type: prefixes[prefix], link: uri.trim()};\n\n                if (prefixes[prefix] !== DefaultLinkType.www) {\n                    link.link = uri.substring(prefix.length).trim();\n                }\n\n                return link;\n            }\n        }\n\n        return {type: DefaultLinkType.other, link: uri};\n    }\n\n    private linkValidator(control: AbstractControl): ValidationErrors {\n\n        const required = Validators.required(control);\n        if (required) {\n            return required;\n        }\n\n        const type = this.form.controls.type.value as LinkType;\n        const validators = type.inputValidators;\n\n        if (validators) {\n            for (const validator of validators) {\n                const r = validator(control);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n    }\n\n    async ionViewDidEnter() {\n\n        this.types = [DefaultLinkType.www, DefaultLinkType.email, DefaultLinkType.tel, DefaultLinkType.sms, DefaultLinkType.other];\n\n        this.form = new FormGroup({\n            type: new FormControl(this.existingType || DefaultLinkType.www),\n            link: new FormControl(this.existingLink)\n        });\n\n        this.form.controls.link.setValidators(control => this.linkValidator(control));\n\n        this.typeChangesSubscription = this.form.controls[\"type\"].valueChanges.subscribe(() => this.typeChanged());\n        this.typeChanged();\n\n        await waitTill(() => !!this.formHelper);\n\n        this.formHelper.focus(\"link\", false);\n    }\n\n    async ionViewWillLeave() {\n        this.editor.focus();\n    }\n\n    ngOnInit() {\n\n        MARKS: for (const mark of findMarksInSelection(this.editor.state, schema.marks.link)) {\n            const parsed = this.parseLink(mark.attrs.href);\n            if (parsed) {\n                this.existingType = parsed.type;\n                this.existingLink = parsed.link;\n                this.existing = true;\n                break MARKS;\n            }\n        }\n    }\n\n    private typeChangesSubscription: Subscription;\n\n    ngOnDestroy() {\n        unsubscribe(this.typeChangesSubscription);\n    }\n\n}\n","import {Component, Input, OnInit, ViewChild} from \"@angular/core\";\nimport {sleep, waitTill} from \"@co.mmons/js-utils/core\";\nimport {IonInput, ModalController, PopoverController} from \"@ionic/angular\";\nimport {OverlayEventDetail} from \"@ionic/core\";\nimport {HtmlEditor} from \"./editor\";\nimport {LinkModal} from \"./link-modal\";\n\n@Component({\n    styles: [\n        `:host ion-list { margin: 0px; padding: 0px }`,\n        `:host ion-item:last-child { --border-width: 0px; }`,\n        `:host ion-item { --highlight-height: 0px; }`\n    ],\n    template: `\n        <ion-list lines=\"full\">\n            \n            <ng-template [ngIf]=\"!inputView\">\n                \n                <ion-item button=\"true\" detail=\"false\" (click)=\"insertLink()\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#link/Link\" | intlMessage}}</ion-label>\n                    <ion-icon name=\"link\" slot=\"start\"></ion-icon>\n                </ion-item>\n    \n                <ion-item button=\"true\" detail=\"false\" (click)=\"insertYoutube()\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#youtube/YouTube video\" | intlMessage}}</ion-label>\n                    <ion-icon name=\"logo-youtube\" slot=\"start\"></ion-icon>\n                </ion-item>\n                \n            </ng-template>\n            \n            <ng-template [ngIf]=\"inputView == 'youtube'\">\n\n                <ion-item>\n                    <ion-icon name=\"logo-youtube\" slot=\"start\"></ion-icon>\n                    <ion-input #youtubeInput [placeholder]=\"'@co.mmons/ionic-extensions/html-editor#youtube/Paste YouTube video url' | intlMessage\" (keydown.enter)=\"applyYoutube()\"></ion-input>\n                </ion-item>\n                \n                <ion-item>\n                    <ionx-buttons slot=\"end\">\n                        <ion-button fill=\"clear\" color=\"dark\" (click)=\"cancel()\">\n                            <ion-label>{{\"@co.mmons/js-intl#Cancel\" | intlMessage}}</ion-label>\n                        </ion-button>\n                        \n                        <ion-button fill=\"clear\" color=\"primary\" (click)=\"applyYoutube()\">\n                            <ion-label>{{\"@co.mmons/js-intl#Ok\" | intlMessage}}</ion-label>\n                        </ion-button>\n                    </ionx-buttons>\n                </ion-item>\n    \n            </ng-template>\n            \n        </ion-list>\n    `\n})\nexport class InsertMenu implements OnInit {\n\n    // @ts-ignore\n    constructor(private popoverController: PopoverController, private modalController: ModalController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    inputView: \"youtube\";\n\n    // @ts-ignore\n    private editorLastSelection: [number, number];\n\n\n    async insertLink() {\n\n        this.popoverController.dismiss(undefined, \"link\");\n\n        LinkModal.present(this.modalController, this.editor);\n    }\n\n    @ViewChild(\"youtubeInput\", {static: false})\n    private youtubeInput: IonInput;\n\n    async insertYoutube() {\n\n        this.inputView = \"youtube\";\n\n        await waitTill(() => !!this.youtubeInput, undefined, 2000);\n        this.youtubeInput.setFocus();\n    }\n\n    // @ts-ignore\n    private parseYoutube(value: string): {id: string, start?: string} {\n        // https://www.youtube.com/watch?v=NqMgaHUNSQc\n        // https://youtu.be/NqMgaHUNSQc\n        // https://www.youtube.com/embed/NqMgaHUNSQc\n        // https://www.youtube-nocookie.com/embed/NqMgaHUNSQc\n        // https://youtu.be/NqMgaHUNSQc?t=17\n\n        value = value.replace(\"-nocookie.com/\", \".com/\");\n        value = value.replace(\"/embed/\", \"/\");\n        value = value.replace(\"youtu.be/\", \"youtube.com/\");\n        value = value.replace(\"watch?v=\", \"\");\n        value = value.replace(\"?\", \"&\");\n\n        const info = {id: undefined, start: undefined};\n\n        if (value.indexOf(\"youtube.com/\") > -1) {\n            value = value.split(\"youtube.com/\").splice(1, 1)[0];\n\n            for (const param of value.split(\"&\")) {\n                if (param.indexOf(\"=\") < 0) {\n                    info.id = param;\n                } else if (param.startsWith(\"t=\")) {\n                    info.start = param.substring(2);\n                } else if (param.startsWith(\"start=\")) {\n                    info.start = param.substring(6);\n                }\n            }\n\n        } else  {\n        }\n\n        if (info.id) {\n            return info;\n        }\n    }\n\n\n    applyYoutube() {\n\n\n        const info = this.parseYoutube(this.youtubeInput.value as string);\n        if (info) {\n            const tr = this.editor.state.tr.replaceSelectionWith(this.editor.state.schema.nodes.youtube.create({id: info.id, start: info.start || 0}));\n            this.editor.view.dispatch(tr);\n        }\n\n        this.popoverController.dismiss(undefined, \"youtube\");\n    }\n\n    cancel() {\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n    }\n\n    async ionViewWillLeave(event: OverlayEventDetail<any>) {\n\n        if (!this.inputView && !event.role) {\n            this.editor.focus();\n        }\n    }\n\n    async ionViewDidLeave(event: OverlayEventDetail<any>) {\n\n        if (this.inputView) {\n            await sleep(50);\n            this.editor.focus();\n\n        } else if (!event.role) {\n            this.editor.focus();\n        }\n    }\n}\n","import {Command} from \"../command\";\nimport {Predicate} from \"../predicate\";\n\nexport const filter = (predicates: Predicate[] | Predicate, cmd: Command): Command => {\n\n    return function(state, dispatch, view): boolean {\n        if (!Array.isArray(predicates)) {\n            predicates = [predicates];\n        }\n\n        if (predicates.some(pred => !pred(state, view))) {\n            return false;\n        }\n\n        return cmd(state, dispatch, view) || false;\n    };\n};\n","import {GapCursor} from \"prosemirror-gapcursor\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport const isEmptySelectionAtStart = (state: EditorState): boolean => {\n    const {empty, $from} = state.selection;\n    return (\n        empty &&\n        ($from.parentOffset === 0 || state.selection instanceof GapCursor)\n    );\n};\n\n","import {Fragment, NodeRange, Slice} from \"prosemirror-model\";\nimport {EditorState, Selection, TextSelection, Transaction,} from \"prosemirror-state\";\nimport {liftTarget, ReplaceAroundStep} from \"prosemirror-transform\";\n\nfunction liftListItem(\n    state: EditorState,\n    selection: Selection,\n    tr: Transaction,\n): Transaction {\n    const { $from, $to } = selection;\n    const nodeType = state.schema.nodes.listItem;\n    let range = $from.blockRange(\n        $to,\n        node =>\n            !!node.childCount &&\n            !!node.firstChild &&\n            node.firstChild.type === nodeType,\n    );\n    if (\n        !range ||\n        range.depth < 2 ||\n        $from.node(range.depth - 1).type !== nodeType\n    ) {\n        return tr;\n    }\n    const end = range.end;\n    const endOfList = $to.end(range.depth);\n    if (end < endOfList) {\n        tr.step(\n            new ReplaceAroundStep(\n                end - 1,\n                endOfList,\n                end,\n                endOfList,\n                new Slice(\n                    Fragment.from(nodeType.create(undefined, range.parent.copy())),\n                    1,\n                    0,\n                ),\n                1,\n                true,\n            ),\n        );\n\n        range = new NodeRange(\n            tr.doc.resolve($from.pos),\n            tr.doc.resolve(endOfList),\n            range.depth,\n        );\n    }\n    return tr.lift(range, liftTarget(range) as number).scrollIntoView();\n}\n\nexport function liftFollowingList(\n    state: EditorState,\n    from: number,\n    to: number,\n    rootListDepth: number,\n    tr: Transaction,\n): Transaction {\n    const { listItem } = state.schema.nodes;\n    let lifted = false;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!lifted && node.type === listItem && pos > from) {\n            lifted = true;\n            let listDepth = rootListDepth + 3;\n            while (listDepth > rootListDepth + 2) {\n                const start = tr.doc.resolve(tr.mapping.map(pos));\n                listDepth = start.depth;\n                const end = tr.doc.resolve(\n                    tr.mapping.map(pos + node.textContent.length),\n                );\n                const sel = new TextSelection(start, end);\n                tr = liftListItem(state, sel, tr);\n            }\n        }\n    });\n    return tr;\n}\n","import {ResolvedPos, Schema} from \"prosemirror-model\";\n\n// This will return (depth - 1) for root list parent of a list.\nexport const getListLiftTarget = (\n    schema: Schema,\n    resPos: ResolvedPos,\n): number => {\n    let target = resPos.depth;\n    const { bulletList, orderedList, listItem } = schema.nodes;\n    for (let i = resPos.depth; i > 0; i--) {\n        const node = resPos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            target = i;\n        }\n        if (\n            node.type !== bulletList &&\n            node.type !== orderedList &&\n            node.type !== listItem\n        ) {\n            break;\n        }\n    }\n    return target - 1;\n};\n","import { toggleMark } from \"prosemirror-commands\";\nimport {GapCursor} from \"prosemirror-gapcursor\";\nimport {\n    Fragment,\n    Mark as PMMark,\n    MarkType,\n    Node,\n    NodeType,\n    ResolvedPos,\n    Slice,\n    Schema,\n    NodeRange,\n    Mark,\n} from \"prosemirror-model\";\nimport { EditorView } from \"prosemirror-view\";\nimport {\n    EditorState,\n    NodeSelection,\n    Selection,\n    TextSelection,\n    Transaction,\n} from \"prosemirror-state\";\nimport { liftTarget, findWrapping } from \"prosemirror-transform\";\nimport { hasParentNodeOfType } from \"prosemirror-utils\";\nimport { isNodeEmpty } from \"./document-utils\";\n\nexport {\n    isEmptyParagraph,\n    hasVisibleContent,\n    isNodeEmpty,\n    isEmptyDocument,\n    getStepRange,\n    findFarthestParentNode,\n    isSelectionEndOfParagraph,\n    nodesBetweenChanged,\n} from \"./document-utils\";\n\n\nexport const ZeroWidthSpace = \"\\u200b\";\n\nfunction validateNode(_node: Node): boolean {\n    return false;\n}\n\nfunction isMarkTypeCompatibleWithMark(\n    markType: MarkType,\n    mark: PMMark,\n): boolean {\n    return !mark.type.excludes(markType) && !markType.excludes(mark.type);\n}\n\nfunction isMarkTypeAllowedInNode(\n    markType: MarkType,\n    state: EditorState,\n): boolean {\n    return toggleMark(markType)(state);\n}\n\nfunction closest(\n    node: HTMLElement | null | undefined,\n    s: string,\n): HTMLElement | null {\n    let el = node as HTMLElement;\n    if (!el) {\n        return null;\n    }\n    if (!document.documentElement || !document.documentElement.contains(el)) {\n        return null;\n    }\n    const matches = el.matches ? \"matches\" : \"msMatchesSelector\";\n\n    do {\n        // @ts-ignore\n        if (el[matches] && el[matches](s)) {\n            return el;\n        }\n        el = (el.parentElement || el.parentNode) as HTMLElement;\n    } while (el !== null && el.nodeType === 1);\n    return null;\n}\n\nexport const isImage = (fileType?: string): boolean => {\n    return (\n        !!fileType &&\n        (fileType.indexOf(\"image/\") > -1 || fileType.indexOf(\"video/\") > -1)\n    );\n};\n\nexport function canMoveUp(state: EditorState): boolean {\n    const { selection, doc } = state;\n\n    /**\n     * If there\"s a media element on the selection,\n     * add text blocks with arrow navigation.\n     * Also, the selection could be media | mediaGroup.\n     */\n    if (selection instanceof NodeSelection) {\n        if (selection.node.type.name === \"media\") {\n            /** Weird way of checking if the previous element is a paragraph */\n            const mediaAncestorNode = doc.nodeAt(selection.anchor - 3);\n            return !!(\n                mediaAncestorNode && mediaAncestorNode.type.name === \"paragraph\"\n            );\n        } else if (selection.node.type.name === \"mediaGroup\") {\n            const mediaGroupAncestorNode = selection.$anchor.nodeBefore;\n            return !!(\n                mediaGroupAncestorNode &&\n                mediaGroupAncestorNode.type.name === \"paragraph\"\n            );\n        }\n    }\n\n    if (selection instanceof TextSelection) {\n        if (!selection.empty) {\n            return true;\n        }\n    }\n\n    return !atTheBeginningOfDoc(state);\n}\n\nexport function canMoveDown(state: EditorState): boolean {\n    const { selection, doc } = state;\n\n    /**\n     * If there\"s a media element on the selection,\n     * add text blocks with arrow navigation.\n     * Also, the selection could be media | mediaGroup.\n     */\n    if (selection instanceof NodeSelection) {\n        if (selection.node.type.name === \"media\") {\n            const nodeAfter = doc.nodeAt(selection.$head.after());\n            return !!(nodeAfter && nodeAfter.type.name === \"paragraph\");\n        } else if (selection.node.type.name === \"mediaGroup\") {\n            return !(\n                selection.$head.parentOffset === selection.$anchor.parent.content.size\n            );\n        }\n    }\n    if (selection instanceof TextSelection) {\n        if (!selection.empty) {\n            return true;\n        }\n    }\n\n    return !atTheEndOfDoc(state);\n}\n\nexport function isSelectionInsideLastNodeInDocument(\n    selection: Selection,\n): boolean {\n    const docNode = selection.$anchor.node(0);\n    const rootNode = selection.$anchor.node(1);\n\n    return docNode.lastChild === rootNode;\n}\n\nexport function atTheEndOfDoc(state: EditorState): boolean {\n    const { selection, doc } = state;\n    return doc.nodeSize - selection.$to.pos - 2 === selection.$to.depth;\n}\n\nexport function atTheBeginningOfDoc(state: EditorState): boolean {\n    const { selection } = state;\n    return selection.$from.pos === selection.$from.depth;\n}\n\nexport function atTheEndOfBlock(state: EditorState): boolean {\n    const { selection } = state;\n    const { $to } = selection;\n    if (selection instanceof GapCursor) {\n        return false;\n    }\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n        return true;\n    }\n    return endPositionOfParent($to) === $to.pos + 1;\n}\n\nexport function atTheBeginningOfBlock(state: EditorState): boolean {\n    const { selection } = state;\n    const { $from } = selection;\n    if (selection instanceof GapCursor) {\n        return false;\n    }\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n        return true;\n    }\n    return startPositionOfParent($from) === $from.pos;\n}\n\nexport function startPositionOfParent(resolvedPos: ResolvedPos): number {\n    return resolvedPos.start(resolvedPos.depth);\n}\n\nexport function endPositionOfParent(resolvedPos: ResolvedPos): number {\n    return resolvedPos.end(resolvedPos.depth) + 1;\n}\n\nexport function getCursor(selection: Selection): ResolvedPos | undefined {\n    return (selection as TextSelection).$cursor || undefined;\n}\n\n/**\n * Check if a mark is allowed at the current selection / cursor based on a given state.\n * This method looks at both the currently active marks on the transaction, as well as\n * the node and marks at the current selection to determine if the given mark type is\n * allowed.\n */\nexport function isMarkTypeAllowedInCurrentSelection(\n    markType: MarkType,\n    state: EditorState,\n) {\n\n    if (!isMarkTypeAllowedInNode(markType, state)) {\n        return false;\n    }\n\n    const { empty, $cursor, ranges } = state.selection as TextSelection;\n    if (empty && !$cursor) {\n        return false;\n    }\n\n    const isCompatibleMarkType = (mark: PMMark) =>\n        isMarkTypeCompatibleWithMark(markType, mark);\n\n    // Handle any new marks in the current transaction\n    if (\n        state.tr.storedMarks &&\n        !state.tr.storedMarks.every(isCompatibleMarkType)\n    ) {\n        return false;\n    }\n\n    if ($cursor) {\n        return $cursor.marks().every(isCompatibleMarkType);\n    }\n\n    // Check every node in a selection - ensuring that it is compatible with the current mark type\n    return ranges.every(({ $from, $to }) => {\n        let allowedInActiveMarks =\n            $from.depth === 0 ? state.doc.marks.every(isCompatibleMarkType) : true;\n\n        state.doc.nodesBetween($from.pos, $to.pos, node => {\n            allowedInActiveMarks =\n                allowedInActiveMarks && node.marks.every(isCompatibleMarkType);\n        });\n\n        return allowedInActiveMarks;\n    });\n}\n\n/**\n * Step through block-nodes between $from and $to and returns false if a node is\n * found that isn\"t of the specified type\n */\nexport function isRangeOfType(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n    nodeType: NodeType,\n): boolean {\n    return (\n        getAncestorNodesBetween(doc, $from, $to).filter(\n            node => node.type !== nodeType,\n        ).length === 0\n    );\n}\n\nexport function createSliceWithContent(content: string, state: EditorState) {\n    return new Slice(Fragment.from(state.schema.text(content)), 0, 0);\n}\n\n/**\n * Determines if content inside a selection can be joined with the next block.\n * We need this check since the built-in method for \"joinDown\" will join a orderedList with bulletList.\n */\nexport function canJoinDown(\n    selection: Selection,\n    doc: any,\n    nodeType: NodeType,\n): boolean {\n    return checkNodeDown(selection, doc, node => node.type === nodeType);\n}\n\nexport function checkNodeDown(\n    selection: Selection,\n    doc: Node,\n    filter: (node: Node) => boolean,\n): boolean {\n    const res = doc.resolve(\n        selection.$to.after(findAncestorPosition(doc, selection.$to).depth),\n    );\n    return res.nodeAfter ? filter(res.nodeAfter) : false;\n}\n\nexport const setNodeSelection = (view: EditorView, pos: number) => {\n    const { state, dispatch } = view;\n\n    if (!isFinite(pos)) {\n        return;\n    }\n\n    const tr = state.tr.setSelection(NodeSelection.create(state.doc, pos));\n    dispatch(tr);\n};\n\nexport function setTextSelection(\n    view: EditorView,\n    anchor: number,\n    head?: number,\n) {\n    const { state } = view;\n    const tr = state.tr.setSelection(\n        TextSelection.create(state.doc, anchor, head),\n    );\n    view.dispatch(tr);\n}\n\n/**\n * Determines if content inside a selection can be joined with the previous block.\n * We need this check since the built-in method for \"joinUp\" will join a orderedList with bulletList.\n */\nexport function canJoinUp(\n    selection: Selection,\n    doc: any,\n    nodeType: NodeType,\n): boolean {\n    const res = doc.resolve(\n        selection.$from.before(findAncestorPosition(doc, selection.$from).depth),\n    );\n    return res.nodeBefore && res.nodeBefore.type === nodeType;\n}\n\n/**\n * Returns all top-level ancestor-nodes between $from and $to\n */\nexport function getAncestorNodesBetween(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n): Node[] {\n    const nodes = Array<Node>();\n    const maxDepth = findAncestorPosition(doc, $from).depth;\n    let current = doc.resolve($from.start(maxDepth));\n\n    while (current.pos <= $to.start($to.depth)) {\n        const depth = Math.min(current.depth, maxDepth);\n        const node = current.node(depth);\n\n        if (node) {\n            nodes.push(node);\n        }\n\n        if (depth === 0) {\n            break;\n        }\n\n        let next: ResolvedPos = doc.resolve(current.after(depth));\n        if (next.start(depth) >= doc.nodeSize - 2) {\n            break;\n        }\n\n        if (next.depth !== current.depth) {\n            next = doc.resolve(next.pos + 2);\n        }\n\n        if (next.depth) {\n            current = doc.resolve(next.start(next.depth));\n        } else {\n            current = doc.resolve(next.end(next.depth));\n        }\n    }\n\n    return nodes;\n}\n\n/**\n * Finds all \"selection-groups\" within a range. A selection group is based on ancestors.\n *\n * Example:\n * Given the following document and selection ({<} = start of selection and {>} = end)\n *  doc\n *    blockquote\n *      ul\n *        li\n *        li{<}\n *        li\n *     p\n *     p{>}\n *\n * The output will be two selection-groups. One within the ul and one with the two paragraphs.\n */\nexport function getGroupsInRange(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n    isNodeValid: (node: Node) => boolean = validateNode,\n): Array<{ $from: ResolvedPos; $to: ResolvedPos }> {\n    const groups = Array<{ $from: ResolvedPos; $to: ResolvedPos }>();\n    const commonAncestor = hasCommonAncestor(doc, $from, $to);\n    const fromAncestor = findAncestorPosition(doc, $from);\n\n    if (\n        commonAncestor ||\n        (fromAncestor.depth === 1 && isNodeValid($from.node(1)))\n    ) {\n        groups.push({ $from, $to });\n    } else {\n        let current = $from;\n\n        while (current.pos < $to.pos) {\n            let ancestorPos = findAncestorPosition(doc, current);\n            while (ancestorPos.depth > 1) {\n                ancestorPos = findAncestorPosition(doc, ancestorPos);\n            }\n\n            const endPos = doc.resolve(\n                Math.min(\n                    // should not be smaller then start position in case of an empty paragraph for example.\n                    Math.max(\n                        ancestorPos.start(ancestorPos.depth),\n                        ancestorPos.end(ancestorPos.depth) - 3,\n                    ),\n                    $to.pos,\n                ),\n            );\n\n            groups.push({\n                $from: current,\n                $to: endPos,\n            });\n\n            current = doc.resolve(Math.min(endPos.after(1) + 1, doc.nodeSize - 2));\n        }\n    }\n\n    return groups;\n}\n\n/**\n * Traverse the document until an \"ancestor\" is found. Any nestable block can be an ancestor.\n */\nexport function findAncestorPosition(doc: Node, pos: any): any {\n    const nestableBlocks = [\"blockquote\", \"bulletList\", \"orderedList\"];\n\n    if (pos.depth === 1) {\n        return pos;\n    }\n\n    let node: Node | undefined = pos.node(pos.depth);\n    let newPos = pos;\n    while (pos.depth >= 1) {\n        pos = doc.resolve(pos.before(pos.depth));\n        node = pos.node(pos.depth);\n\n        if (node && nestableBlocks.indexOf(node.type.name) !== -1) {\n            newPos = pos;\n        }\n    }\n\n    return newPos;\n}\n\n/**\n * Determine if two positions have a common ancestor.\n */\nexport function hasCommonAncestor(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n): boolean {\n    let current;\n    let target;\n\n    if ($from.depth > $to.depth) {\n        current = findAncestorPosition(doc, $from);\n        target = findAncestorPosition(doc, $to);\n    } else {\n        current = findAncestorPosition(doc, $to);\n        target = findAncestorPosition(doc, $from);\n    }\n\n    while (current.depth > target.depth && current.depth > 1) {\n        current = findAncestorPosition(doc, current);\n    }\n\n    return current.node(current.depth) === target.node(target.depth);\n}\n\n/**\n * Takes a selection $from and $to and lift all text nodes from their parents to document-level\n */\nexport function liftSelection(\n    tr: Transaction,\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n) {\n    let startPos = $from.start($from.depth);\n    let endPos = $to.end($to.depth);\n    const target = Math.max(0, findAncestorPosition(doc, $from).depth - 1);\n\n    tr.doc.nodesBetween(startPos, endPos, (node, pos) => {\n        if (\n            node.isText || // Text node\n            (node.isTextblock && !node.textContent) // Empty paragraph\n        ) {\n            const res = tr.doc.resolve(tr.mapping.map(pos));\n            const sel = new NodeSelection(res);\n            const range = sel.$from.blockRange(sel.$to);\n\n            if (liftTarget(range as NodeRange) !== undefined) {\n                tr.lift(range, target);\n            }\n        }\n    });\n\n    startPos = tr.mapping.map(startPos);\n    endPos = tr.mapping.map(endPos);\n    endPos = tr.doc.resolve(endPos).end(tr.doc.resolve(endPos).depth); // We want to select the entire node\n\n    tr.setSelection(\n        new TextSelection(tr.doc.resolve(startPos), tr.doc.resolve(endPos)),\n    );\n\n    return {\n        tr: tr,\n        $from: tr.doc.resolve(startPos),\n        $to: tr.doc.resolve(endPos),\n    };\n}\n\n/**\n * Lift nodes in block to one level above.\n */\nexport function liftSiblingNodes(view: EditorView) {\n    const { tr } = view.state;\n    const { $from, $to } = view.state.selection;\n    const blockStart = tr.doc.resolve($from.start($from.depth - 1));\n    const blockEnd = tr.doc.resolve($to.end($to.depth - 1));\n    const range = blockStart.blockRange(blockEnd);\n    view.dispatch(tr.lift(range as NodeRange, blockStart.depth - 1));\n}\n\n/**\n * Lift sibling nodes to document-level and select them.\n */\nexport function liftAndSelectSiblingNodes(view: EditorView): Transaction {\n    const { tr } = view.state;\n    const { $from, $to } = view.state.selection;\n    const blockStart = tr.doc.resolve($from.start($from.depth - 1));\n    const blockEnd = tr.doc.resolve($to.end($to.depth - 1));\n    // TODO: [ts30] handle void and null properly\n    const range = blockStart.blockRange(blockEnd) as NodeRange;\n    tr.setSelection(new TextSelection(blockStart, blockEnd));\n    tr.lift(range as NodeRange, blockStart.depth - 1);\n    return tr;\n}\n\nexport function wrapIn(\n    nodeType: NodeType,\n    tr: Transaction,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n): Transaction {\n    const range = $from.blockRange($to) as any;\n    const wrapping = range && (findWrapping(range, nodeType) as any);\n    if (wrapping) {\n        tr = tr.wrap(range, wrapping).scrollIntoView();\n    }\n    return tr;\n}\n\n/**\n * Repeating string for multiple times\n */\nexport function stringRepeat(text: string, length: number): string {\n    let result = \"\";\n    for (let x = 0; x < length; x++) {\n        result += text;\n    }\n    return result;\n}\n\n/**\n * A replacement for `Array.from` until it becomes widely implemented.\n */\nexport function arrayFrom(obj: any): any[] {\n    return Array.prototype.slice.call(obj);\n}\n\n/**\n * Replacement for Element.closest, until it becomes widely implemented\n * Returns the ancestor element of a particular type if exists or null\n */\nexport function closestElement(\n    node: HTMLElement | null | undefined,\n    s: string,\n): HTMLElement | null {\n    return closest(node, s);\n}\n\n/*\n * From Modernizr\n * Returns the kind of transitionevent available for the element\n */\nexport function whichTransitionEvent<TransitionEventName extends string>() {\n    const el = document.createElement(\"fakeelement\");\n    const transitions: Record<string, string> = {\n        transition: \"transitionend\",\n        MozTransition: \"transitionend\",\n        OTransition: \"oTransitionEnd\",\n        WebkitTransition: \"webkitTransitionEnd\",\n    };\n\n    for (const t in transitions) {\n        if (el.style[t as keyof CSSStyleDeclaration] !== undefined) {\n            // Use a generic as the return type because TypeScript doesnt know\n            // about cross browser features, so we cast here to align to the\n            // standard Event spec and propagate the type properly to the callbacks\n            // of `addEventListener` and `removeEventListener`.\n            return transitions[t] as TransitionEventName;\n        }\n    }\n\n    return;\n}\n\n/**\n * Function will create a list of wrapper blocks present in a selection.\n */\nfunction getSelectedWrapperNodes(state: EditorState): NodeType[] {\n    const nodes: Array<NodeType> = [];\n    if (state.selection) {\n        const { $from, $to } = state.selection;\n        const {\n            blockquote,\n            panel,\n            orderedList,\n            bulletList,\n            listItem,\n            codeBlock,\n        } = state.schema.nodes;\n        state.doc.nodesBetween($from.pos, $to.pos, node => {\n            if (\n                (node.isBlock &&\n                    [blockquote, panel, orderedList, bulletList, listItem].indexOf(\n                        node.type,\n                    ) >= 0) ||\n                node.type === codeBlock\n            ) {\n                nodes.push(node.type);\n            }\n        });\n    }\n    return nodes;\n}\n\n/**\n * Function will check if changing block types: Paragraph, Heading is enabled.\n */\nexport function areBlockTypesDisabled(state: EditorState): boolean {\n    const nodesTypes: NodeType[] = getSelectedWrapperNodes(state);\n    const { panel } = state.schema.nodes;\n    return nodesTypes.filter(type => type !== panel).length > 0;\n}\n\nexport const isTemporary = (id: string): boolean => {\n    return id.indexOf(\"temporary:\") === 0;\n};\n\n\nexport const isEmptyNode = (schema: Schema) => {\n    const {\n        doc,\n        paragraph,\n        codeBlock,\n        blockquote,\n        panel,\n        heading,\n        listItem,\n        bulletList,\n        orderedList,\n        taskList,\n        taskItem,\n        decisionList,\n        decisionItem,\n        media,\n        mediaGroup,\n        mediaSingle,\n    } = schema.nodes;\n    const innerIsEmptyNode = (node: Node): boolean => {\n        switch (node.type) {\n            case media:\n            case mediaGroup:\n            case mediaSingle:\n                return false;\n            case paragraph:\n            case codeBlock:\n            case heading:\n            case taskItem:\n            case decisionItem:\n                return node.content.size === 0;\n            case blockquote:\n            case panel:\n            case listItem:\n                return (\n                    node.content.size === 2 && innerIsEmptyNode(node.content.firstChild)\n                );\n            case bulletList:\n            case orderedList:\n                return (\n                    node.content.size === 4 && innerIsEmptyNode(node.content.firstChild)\n                );\n            case taskList:\n            case decisionList:\n                return (\n                    node.content.size === 2 && innerIsEmptyNode(node.content.firstChild)\n                );\n            case doc:\n                let isEmpty = true;\n                node.content.forEach(child => {\n                    isEmpty = isEmpty && innerIsEmptyNode(child);\n                });\n                return isEmpty;\n            default:\n                return isNodeEmpty(node);\n        }\n    };\n    return innerIsEmptyNode;\n};\n\nexport const insideTable = (state: EditorState): Boolean => {\n    const { table, tableCell } = state.schema.nodes;\n\n    return hasParentNodeOfType([table, tableCell])(state.selection);\n};\n\nexport const insideTableCell = (state: EditorState) => {\n    const { tableCell, tableHeader } = state.schema.nodes;\n    return hasParentNodeOfType([tableCell, tableHeader])(state.selection);\n};\n\nexport const isElementInTableCell = (\n    element: HTMLElement | null,\n): HTMLElement | null => {\n    return closest(element, \"td\") || closest(element, \"th\");\n};\n\nexport const isLastItemMediaGroup = (node: Node): boolean => {\n    const { content } = node;\n    return !!content.lastChild && content.lastChild.type.name === \"mediaGroup\";\n};\n\nexport const isInListItem = (state: EditorState): boolean => {\n    return hasParentNodeOfType(state.schema.nodes.listItem)(state.selection);\n};\n\nexport const hasOpenEnd = (slice: Slice): boolean => {\n    return slice.openStart > 0 || slice.openEnd > 0;\n};\n\nexport function filterChildrenBetween(\n    doc: Node,\n    from: number,\n    to: number,\n    predicate: (node: Node, pos: number, parent: Node) => boolean | undefined,\n) {\n    const results = [] as { node: Node; pos: number }[];\n    doc.nodesBetween(from, to, (node, pos, parent) => {\n        if (predicate(node, pos, parent)) {\n            results.push({ node, pos });\n        }\n    });\n    return results;\n}\n\nexport function dedupe<T>(\n    list: T[] = [],\n    iteratee?: (p: T) => T[keyof T] | T,\n): T[] {\n    const transformed = iteratee ? list.map(iteratee) : list;\n\n    return transformed\n        .map((item, index, list) => (list.indexOf(item) === index ? item : null))\n        .reduce<T[]>(\n            (acc, item, index) => (!!item ? acc.concat(list[index]) : acc),\n            [],\n        );\n}\n\nexport const isTextSelection = (\n    selection: Selection,\n): selection is TextSelection => selection instanceof TextSelection;\n\n/** Helper type for single arg function */\ntype Func<A, B> = (a: A) => B;\ntype FuncN<A extends any[], B> = (...args: A) => B;\n\n/**\n * Compose 1 to n functions.\n * @param func first function\n * @param funcs additional functions\n */\nexport function compose<\n    F1 extends Func<any, any>,\n    FN extends Array<Func<any, any>>,\n    R extends FN extends []\n        ? F1\n        : FN extends [Func<infer A, any>]\n            ? (a: A) => ReturnType<F1>\n            : FN extends [any, Func<infer A, any>]\n                ? (a: A) => ReturnType<F1>\n                : FN extends [any, any, Func<infer A, any>]\n                    ? (a: A) => ReturnType<F1>\n                    : FN extends [any, any, any, Func<infer A, any>]\n                        ? (a: A) => ReturnType<F1>\n                        : FN extends [any, any, any, any, Func<infer A, any>]\n                            ? (a: A) => ReturnType<F1>\n                            : Func<any, ReturnType<F1>> // Doubtful we\"d ever want to pipe this many functions, but in the off chance someone does, we can still infer the return type\n    >(func: F1, ...funcs: FN): R {\n    const allFuncs = [func, ...funcs];\n    return function composed(raw: any) {\n        return allFuncs.reduceRight((memo, func) => func(memo), raw);\n    } as R;\n}\n\nexport function pipe(): <R>(a: R) => R;\n\nexport function pipe<F extends Function>(f: F): F;\n\n// one function\nexport function pipe<F1 extends FuncN<any, any>>(\n    f1: F1,\n): (...args: Parameters<F1>) => ReturnType<F1>;\n\n// two function\nexport function pipe<\n    F1 extends FuncN<any, any>,\n    F2 extends Func<ReturnType<F1>, any>\n    >(f1: F1, f2: F2): (...args: Parameters<F1>) => ReturnType<F2>;\n\n// three function\nexport function pipe<\n    F1 extends FuncN<any, any>,\n    F2 extends Func<ReturnType<F1>, any>,\n    F3 extends Func<ReturnType<F2>, any>\n    >(f1: F1, f2: F2, f3: F3): (...args: Parameters<F1>) => ReturnType<F3>;\n// If needed add more than 3 function\n// Generic\nexport function pipe<\n    F1 extends FuncN<any, any>,\n    F2 extends Func<ReturnType<F1>, any>,\n    F3 extends Func<ReturnType<F2>, any>,\n    FN extends Array<Func<any, any>>\n    >(f1: F1, f2: F2, f3: F3, ...fn: FN): (...args: Parameters<F1>) => any;\n\n// rest\nexport function pipe(...fns: Function[]) {\n    if (fns.length === 0) {\n        return (a: any) => a;\n    }\n\n    if (fns.length === 1) {\n        return fns[0];\n    }\n\n    return fns.reduce((prevFn, nextFn) => (...args: any[]) =>\n        nextFn(prevFn(...args)),\n    );\n}\n\nexport const normaliseNestedLayout = (state: EditorState, node: Node) => {\n    if (state.selection.$from.depth > 1) {\n        if (node.attrs.layout && node.attrs.layout !== \"default\") {\n            return node.type.createChecked(\n                {\n                    ...node.attrs,\n                    layout: \"default\",\n                },\n                node.content,\n                node.marks,\n            );\n        }\n\n        // If its a breakout layout, we can remove the mark\n        // Since default isn\"t a valid breakout mode.\n        const breakoutMark: Mark = state.schema.marks.breakout;\n        if (breakoutMark && breakoutMark.isInSet(node.marks)) {\n            const newMarks = breakoutMark.removeFromSet(node.marks);\n            return node.type.createChecked(node.attrs, node.content, newMarks);\n        }\n    }\n\n    return node;\n};\n","// https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js#L90\n// Keep going left up the tree, without going across isolating boundaries, until we\n// can go along the tree at that same level\n//\n// You can think of this as, if you could construct each document like we do in the tests,\n// return the position of the first ) backwards from the current selection.\nimport {ResolvedPos} from \"prosemirror-model\";\n\nexport function findCutBefore($pos: ResolvedPos): ResolvedPos | null {\n\n    // parent is non-isolating, so we can look across this boundary\n    if (!$pos.parent.type.spec.isolating) {\n        // search up the tree from the pos\"s *parent*\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            // starting from the inner most node\"s parent, find out\n            // if we\"re not its first child\n            if ($pos.index(i) > 0) {\n                return $pos.doc.resolve($pos.before(i + 1));\n            }\n\n            if ($pos.node(i).type.spec.isolating) {\n                break;\n            }\n        }\n    }\n\n    return null;\n}\n","import * as baseCommand from \"prosemirror-commands\";\nimport {GapCursor} from \"prosemirror-gapcursor\";\nimport {Fragment, Node, NodeRange, NodeType, ResolvedPos, Slice} from \"prosemirror-model\";\nimport * as baseListCommand from \"prosemirror-schema-list\";\nimport {EditorState, NodeSelection, TextSelection, Transaction} from \"prosemirror-state\";\nimport {liftTarget, ReplaceAroundStep} from \"prosemirror-transform\";\nimport {findPositionOfNodeBefore, hasParentNodeOfType} from \"prosemirror-utils\";\nimport {EditorView} from \"prosemirror-view\";\nimport {Command} from \"./command\";\nimport {filter} from \"./commands/filter\";\nimport {isEmptySelectionAtStart} from \"./commands/is-empty-selection-at-start\";\nimport {isFirstChildOfParent} from \"./commands/is-first-child-of-parent\";\nimport {hasVisibleContent, isNodeEmpty} from \"./document-utils\";\nimport {liftFollowingList} from \"./list/transforms/lift-following-list\";\nimport {liftSelectionList} from \"./list/transforms/lift-selection-list\";\nimport {sanitizeSelectionMarks} from \"./mark-utils\";\nimport {compose, isRangeOfType} from \"./utils\";\nimport {findCutBefore} from \"./utils/find-cut-before\";\n\nconst maxIndentation = 5;\n\nconst deletePreviousEmptyListItem: Command = (state, dispatch) => {\n    const { $from } = state.selection;\n    const { listItem } = state.schema.nodes;\n\n    const $cut = findCutBefore($from);\n    if (!$cut || !$cut.nodeBefore || !($cut.nodeBefore.type === listItem)) {\n        return false;\n    }\n\n    const previousListItemEmpty = $cut.nodeBefore.childCount === 1 && $cut.nodeBefore.firstChild && $cut.nodeBefore.firstChild.nodeSize <= 2;\n\n    if (previousListItemEmpty) {\n        const { tr } = state;\n\n        if (dispatch) {\n            dispatch(\n                tr\n                    .delete($cut.pos - $cut.nodeBefore.nodeSize, $from.pos)\n                    .scrollIntoView(),\n            );\n        }\n        return true;\n    }\n\n    return false;\n};\n\nconst joinToPreviousListItem: Command = (state, dispatch) => {\n    const { $from } = state.selection;\n    const {\n        paragraph,\n        listItem,\n        codeBlock,\n        bulletList,\n        orderedList,\n    } = state.schema.nodes;\n    const isGapCursorShown = state.selection instanceof GapCursor;\n    const $cutPos = isGapCursorShown ? state.doc.resolve($from.pos + 1) : $from;\n    const $cut = findCutBefore($cutPos);\n    if (!$cut) {\n        return false;\n    }\n\n    // see if the containing node is a list\n    if (\n        $cut.nodeBefore &&\n        [bulletList, orderedList].indexOf($cut.nodeBefore.type) > -1\n    ) {\n        // and the node after this is a paragraph or a codeBlock\n        if (\n            $cut.nodeAfter &&\n            ($cut.nodeAfter.type === paragraph || $cut.nodeAfter.type === codeBlock)\n        ) {\n            // find the nearest paragraph that precedes this node\n            let $lastNode = $cut.doc.resolve($cut.pos - 1);\n\n            while ($lastNode.parent.type !== paragraph) {\n                $lastNode = state.doc.resolve($lastNode.pos - 1);\n            }\n\n            let { tr } = state;\n            if (isGapCursorShown) {\n                const nodeBeforePos = findPositionOfNodeBefore(tr.selection);\n                if (typeof nodeBeforePos !== \"number\") {\n                    return false;\n                }\n                // append the codeblock to the list node\n                const list = $cut.nodeBefore.copy(\n                    $cut.nodeBefore.content.append(\n                        Fragment.from(listItem.createChecked({}, $cut.nodeAfter)),\n                    ),\n                );\n                tr.replaceWith(\n                    nodeBeforePos,\n                    $from.pos + $cut.nodeAfter.nodeSize,\n                    list,\n                );\n            } else {\n                // take the text content of the paragraph and insert after the paragraph up until before the the cut\n                tr = state.tr.step(\n                    new ReplaceAroundStep(\n                        $lastNode.pos,\n                        $cut.pos + $cut.nodeAfter.nodeSize,\n                        $cut.pos + 1,\n                        $cut.pos + $cut.nodeAfter.nodeSize - 1,\n                        state.tr.doc.slice($lastNode.pos, $cut.pos),\n                        0,\n                        true,\n                    ),\n                );\n            }\n\n            // find out if there\"s now another list following and join them\n            // as in, [list, p, list] => [list with p, list], and we want [joined list]\n            const $postCut = tr.doc.resolve(\n                tr.mapping.map($cut.pos + $cut.nodeAfter.nodeSize),\n            );\n            if (\n                $postCut.nodeBefore &&\n                $postCut.nodeAfter &&\n                $postCut.nodeBefore.type === $postCut.nodeAfter.type &&\n                [bulletList, orderedList].indexOf($postCut.nodeBefore.type) > -1\n            ) {\n                tr = tr.join($postCut.pos);\n            }\n\n            if (dispatch) {\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n\n    return false;\n};\n\nconst isInsideListItem = (state: EditorState): boolean => {\n    const { $from } = state.selection;\n    const { listItem, paragraph } = state.schema.nodes;\n\n    if (state.selection instanceof GapCursor) {\n        return $from.parent.type === listItem;\n    }\n\n    return (\n        hasParentNodeOfType(listItem)(state.selection) &&\n        $from.parent.type === paragraph\n    );\n};\n\nconst canToJoinToPreviousListItem = (state: EditorState): boolean => {\n    const { $from } = state.selection;\n    const { bulletList, orderedList } = state.schema.nodes;\n\n    const $before = state.doc.resolve($from.pos - 1);\n    let nodeBefore = $before ? $before.nodeBefore : null;\n\n    if (state.selection instanceof GapCursor) {\n        nodeBefore = $from.nodeBefore;\n    }\n\n    return (\n        !!nodeBefore && [bulletList, orderedList].indexOf(nodeBefore.type) > -1\n    );\n};\n\nconst canOutdent = (state: EditorState): boolean => {\n    const { parent } = state.selection.$from;\n    const { listItem, paragraph } = state.schema.nodes;\n\n    if (state.selection instanceof GapCursor) {\n        return parent.type === listItem;\n    }\n\n    return (\n        parent.type === paragraph && hasParentNodeOfType(listItem)(state.selection)\n    );\n};\n\nexport const enterKeyCommand: Command = (state, dispatch): boolean => {\n    const { selection } = state;\n    if (selection.empty) {\n        const { $from } = selection;\n        const { listItem, codeBlock } = state.schema.nodes;\n        const node = $from.node($from.depth);\n        const wrapper = $from.node($from.depth - 1);\n\n        if (wrapper && wrapper.type === listItem) {\n            /** Check if the wrapper has any visible content */\n            const wrapperHasContent = hasVisibleContent(wrapper);\n            if (isNodeEmpty(node) && !wrapperHasContent) {\n                return outdentList()(state, dispatch);\n            } else if (!hasParentNodeOfType(codeBlock)(selection)) {\n                return splitListItem(listItem)(state, dispatch);\n            }\n        }\n    }\n    return false;\n};\n\nexport const backspaceKeyCommand = baseCommand.chainCommands(\n    // if we\"re at the start of a list item, we need to either backspace\n    // directly to an empty list item above, or outdent this node\n    filter(\n        [\n            isEmptySelectionAtStart,\n\n            // list items might have multiple paragraphs; only do this at the first one\n            isFirstChildOfParent,\n            canOutdent,\n        ],\n        baseCommand.chainCommands(deletePreviousEmptyListItem, outdentList()),\n    ),\n\n    // if we\"re just inside a paragraph node (or gapcursor is shown) and backspace, then try to join\n    // the text to the previous list item, if one exists\n    filter(\n        [isEmptySelectionAtStart, canToJoinToPreviousListItem],\n        joinToPreviousListItem,\n    ),\n);\n\n/**\n * Implemetation taken and modified for our needs from PM\n * @param itemType Node\n * Splits the list items, specific implementation take from PM\n */\nfunction splitListItem(itemType: NodeType): Command {\n    return function(state, dispatch) {\n        const ref = state.selection as NodeSelection;\n        const $from = ref.$from;\n        const $to = ref.$to;\n        const node = ref.node;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        const grandParent = $from.node(-1);\n        if (grandParent.type !== itemType) {\n            return false;\n        }\n        /** --> The following line changed from the original PM implementation to allow list additions with multiple paragraphs */\n        if (\n            (grandParent.content as any).content.length <= 1 &&\n            $from.parent.content.size === 0 &&\n            !(grandParent.content.size === 0)\n        ) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if (\n                $from.depth === 2 ||\n                $from.node(-3).type !== itemType ||\n                $from.index(-2) !== $from.node(-2).childCount - 1\n            ) {\n                return false;\n            }\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                const keepItem = $from.index(-1) > 0;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (\n                    let d = $from.depth - (keepItem ? 1 : 2);\n                    d >= $from.depth - 3;\n                    d--\n                ) {\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                }\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                const tr$1 = state.tr.replace(\n                    $from.before(keepItem ? undefined : -1),\n                    $from.after(-3),\n                    new Slice(wrap, keepItem ? 3 : 2, 2),\n                );\n                tr$1.setSelection(\n                    (state.selection.constructor as any).near(\n                        tr$1.doc.resolve($from.pos + (keepItem ? 3 : 2)),\n                    ),\n                );\n                dispatch(tr$1.scrollIntoView());\n            }\n            return true;\n        }\n        const nextType =\n            $to.pos === $from.end()\n                ? grandParent.contentMatchAt(0).defaultType\n                : undefined;\n        const tr = state.tr.delete($from.pos, $to.pos);\n        const types = nextType && [undefined, { type: nextType }];\n\n        if (dispatch) {\n            dispatch(tr.split($from.pos, 2, types as any).scrollIntoView());\n        }\n        return true;\n    };\n}\n\n/**\n * Merge closest bullet list blocks into one\n */\nfunction mergeLists(listItem: NodeType, range: NodeRange) {\n    return (command: Command): Command => {\n        return (state, dispatch) =>\n            command(state, tr => {\n                /* we now need to handle the case that we lifted a sublist out,\n                 * and any listItems at the current level get shifted out to\n                 * their own new list; e.g.:\n                 *\n                 * unorderedList\n                 *  listItem(A)\n                 *  listItem\n                 *    unorderedList\n                 *      listItem(B)\n                 *  listItem(C)\n                 *\n                 * becomes, after unindenting the first, top level listItem, A:\n                 *\n                 * content of A\n                 * unorderedList\n                 *  listItem(B)\n                 * unorderedList\n                 *  listItem(C)\n                 *\n                 * so, we try to merge these two lists if they\"re of the same type, to give:\n                 *\n                 * content of A\n                 * unorderedList\n                 *  listItem(B)\n                 *  listItem(C)\n                 */\n\n                const $start: ResolvedPos = state.doc.resolve(range.start);\n                const $end: ResolvedPos = state.doc.resolve(range.end);\n                const $join = tr.doc.resolve(tr.mapping.map(range.end - 1));\n\n                if (\n                    $join.nodeBefore &&\n                    $join.nodeAfter &&\n                    $join.nodeBefore.type === $join.nodeAfter.type\n                ) {\n                    if (\n                        $end.nodeAfter &&\n                        $end.nodeAfter.type === listItem &&\n                        $end.parent.type === $start.parent.type\n                    ) {\n                        tr.join($join.pos);\n                    }\n                }\n\n                if (dispatch) {\n                    dispatch(tr.scrollIntoView());\n                }\n            });\n    };\n}\n\nexport function outdentList(): Command {\n    return function(state, dispatch) {\n        const { listItem } = state.schema.nodes;\n        const { $from, $to } = state.selection;\n        if (isInsideListItem(state)) {\n            // if we\"re backspacing at the start of a list item, unindent it\n            // take the the range of nodes we might be lifting\n\n            // the predicate is for when you\"re backspacing a top level list item:\n            // we don\"t want to go up past the doc node, otherwise the range\n            // to clear will include everything\n            const range = $from.blockRange(\n                $to,\n                node => node.childCount > 0 && node.firstChild && node.firstChild.type === listItem,\n            );\n\n            if (!range) {\n                return false;\n            }\n            return compose(\n                mergeLists(listItem, range), // 2. Check if I need to merge nearest list\n                baseListCommand.liftListItem, // 1. First lift list item\n            )(listItem)(state, dispatch);\n        }\n\n        return false;\n    };\n}\n\n/**\n * Check if we can sink the list.\n *\n * @returns true if we can sink the list, false if we reach the max indentation level\n */\nfunction canSink(initialIndentationLevel: number, state: EditorState): boolean {\n    /*\n        - Keep going forward in document until indentation of the node is < than the initial\n        - If indentation is EVER > max indentation, return true and don\"t sink the list\n        */\n    let currentIndentationLevel: number;\n    let currentPos = state.tr.selection.$to.pos;\n    do {\n        const resolvedPos = state.doc.resolve(currentPos);\n        currentIndentationLevel = numberNestedLists(\n            resolvedPos,\n            state.schema.nodes,\n        );\n        if (currentIndentationLevel > maxIndentation) {\n            // Cancel sink list.\n            // If current indentation less than the initial, it won\"t be\n            // larger than the max, and the loop will terminate at end of this iteration\n            return false;\n        }\n        currentPos++;\n    } while (currentIndentationLevel >= initialIndentationLevel);\n\n    return true;\n}\n\nexport function indentList(): Command {\n    return function(state, dispatch) {\n        const { listItem } = state.schema.nodes;\n        if (isInsideListItem(state)) {\n            // Record initial list indentation\n            const initialIndentationLevel = numberNestedLists(\n                state.selection.$from,\n                state.schema.nodes,\n            );\n\n            if (canSink(initialIndentationLevel, state)) {\n                compose(\n                    baseListCommand.sinkListItem,\n                )(listItem)(state, dispatch);\n            }\n            return true;\n        }\n        return false;\n    };\n}\n\nexport function liftListItems(): Command {\n    return function(state, dispatch) {\n        const { tr } = state;\n        const { $from, $to } = state.selection;\n\n        tr.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            // Following condition will ensure that block types paragraph, heading, codeBlock, blockquote, panel are lifted.\n            // isTextblock is true for paragraph, heading, codeBlock.\n            if (\n                node.isTextblock ||\n                node.type.name === \"blockquote\" ||\n                node.type.name === \"panel\"\n            ) {\n                const sel = new NodeSelection(tr.doc.resolve(tr.mapping.map(pos)));\n                const range = sel.$from.blockRange(sel.$to);\n\n                if (!range || sel.$from.parent.type !== state.schema.nodes.listItem) {\n                    return false;\n                }\n\n                const target = range && liftTarget(range);\n\n                if (target === undefined || target === null) {\n                    return false;\n                }\n\n                tr.lift(range, target);\n            }\n            return;\n        });\n\n        if (dispatch) {\n            dispatch(tr);\n        }\n\n        return true;\n    };\n}\n\n/**\n * Sometimes a selection in the editor can be slightly offset, for example:\n * it\"s possible for a selection to start or end at an empty node at the very end of\n * a line. This isn\"t obvious by looking at the editor and it\"s likely not what the\n * user intended - so we need to adjust the selection a bit in scenarios like that.\n */\nexport function adjustSelectionInList(\n    doc: Node,\n    selection: TextSelection,\n): TextSelection {\n    const { $from, $to } = selection;\n\n    const isSameLine = $from.pos === $to.pos;\n\n    let startPos = $from.pos;\n    const endPos = $to.pos;\n\n    if (isSameLine && startPos === doc.nodeSize - 3) {\n        // Line is empty, don\"t do anything\n        return selection;\n    }\n\n    // Selection started at the very beginning of a line and therefor points to the previous line.\n    if ($from.nodeBefore && !isSameLine) {\n        startPos++;\n        let node = doc.nodeAt(startPos);\n        while (!node || (node && !node.isText)) {\n            startPos++;\n            node = doc.nodeAt(startPos);\n        }\n    }\n\n    if (endPos === startPos) {\n        return new TextSelection(doc.resolve(startPos));\n    }\n\n    return new TextSelection(doc.resolve(startPos), doc.resolve(endPos));\n}\n\n// Get the depth of the nearest ancestor list\nexport const rootListDepth = (\n    pos: ResolvedPos,\n    nodes: Record<string, NodeType>,\n) => {\n    const { bulletList, orderedList, listItem } = nodes;\n    let depth;\n    for (let i = pos.depth - 1; i > 0; i--) {\n        const node = pos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            depth = i;\n        }\n        if (\n            node.type !== bulletList &&\n            node.type !== orderedList &&\n            node.type !== listItem\n        ) {\n            break;\n        }\n    }\n    return depth;\n};\n\n// Returns the number of nested lists that are ancestors of the given selection\nexport const numberNestedLists = (\n    resolvedPos: ResolvedPos,\n    nodes: Record<string, NodeType>,\n) => {\n    const { bulletList, orderedList } = nodes;\n    let count = 0;\n    for (let i = resolvedPos.depth - 1; i > 0; i--) {\n        const node = resolvedPos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            count += 1;\n        }\n    }\n    return count;\n};\n\nexport const toggleList = (\n    state: EditorState,\n    dispatch: (tr: Transaction) => void,\n    view: EditorView,\n    listType: \"bulletList\" | \"orderedList\",\n): boolean => {\n    const { selection } = state;\n    const fromNode = selection.$from.node(selection.$from.depth - 2);\n    const endNode = selection.$to.node(selection.$to.depth - 2);\n    if (\n        !fromNode ||\n        fromNode.type.name !== listType ||\n        (!endNode || endNode.type.name !== listType)\n    ) {\n        return toggleListCommand(listType)(state, dispatch, view);\n    } else {\n        const depth = rootListDepth(selection.$to, state.schema.nodes);\n        let tr = liftFollowingList(\n            state,\n            selection.$to.pos,\n            selection.$to.end(depth),\n            depth || 0,\n            state.tr,\n        );\n        tr = liftSelectionList(state, tr);\n        dispatch(tr);\n        return true;\n    }\n};\n\n/**\n * Check of is selection is inside a list of the specified type\n */\nexport function isInsideList(\n    state: EditorState,\n    listType: \"bulletList\" | \"orderedList\",\n) {\n    const { $from } = state.selection;\n    const parent = $from.node(-2);\n    const grandgrandParent = $from.node(-3);\n\n    return (\n        (parent && parent.type === state.schema.nodes[listType]) ||\n        (grandgrandParent && grandgrandParent.type === state.schema.nodes[listType])\n    );\n}\n\nexport function toggleListCommand(\n    listType: \"bulletList\" | \"orderedList\",\n): Command {\n    return function(state, dispatch, view) {\n        if (dispatch) {\n            dispatch(\n                state.tr.setSelection(\n                    adjustSelectionInList(state.doc, state.selection as TextSelection),\n                ),\n            );\n        }\n\n        if (!view) {\n            return false;\n        }\n\n        state = view.state;\n\n        const { $from, $to } = state.selection;\n        const isRangeOfSingleType = isRangeOfType(\n            state.doc,\n            $from,\n            $to,\n            state.schema.nodes[listType],\n        );\n\n        if (isInsideList(state, listType) && isRangeOfSingleType) {\n            // Untoggles list\n            return liftListItems()(state, dispatch);\n        } else {\n            // Converts list type e.g. bullet_list -> ordered_list if needed\n            if (!isRangeOfSingleType) {\n                liftListItems()(state, dispatch);\n                state = view.state;\n            }\n\n            // Remove any invalid marks that are not supported\n            const tr = sanitizeSelectionMarks(state);\n            if (tr) {\n                if (dispatch) {\n                    dispatch(tr);\n                }\n                state = view.state;\n            }\n            // Wraps selection in list\n            return wrapInList(state.schema.nodes[listType])(state, dispatch);\n        }\n    };\n}\n\nexport function toggleBulletList(view: EditorView) {\n    return toggleList(view.state, view.dispatch, view, \"bulletList\");\n}\n\nexport function toggleOrderedList(view: EditorView) {\n    return toggleList(view.state, view.dispatch, view, \"orderedList\");\n}\n\nexport function wrapInList(nodeType: NodeType): Command {\n    return baseCommand.autoJoin(\n        baseListCommand.wrapInList(nodeType),\n        (before, after) => before.type === after.type && before.type === nodeType,\n    );\n}\n","import {GapCursor} from \"prosemirror-gapcursor\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport const isFirstChildOfParent = (state: EditorState): boolean => {\n    const {$from} = state.selection;\n    return $from.depth > 1\n        ? (state.selection instanceof GapCursor &&\n        $from.parentOffset === 0) ||\n        $from.index($from.depth - 1) === 0\n        : true;\n};\n","import {EditorState, Transaction} from \"prosemirror-state\";\nimport {getListLiftTarget} from \"../utils/get-list-lift-target\";\n\n// The function will list paragraphs in selection out to level 1 below root list.\nexport function liftSelectionList(\n    state: EditorState,\n    tr: Transaction,\n): Transaction {\n    const {from, to} = state.selection;\n    const {paragraph} = state.schema.nodes;\n    const listCol: any[] = [];\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.type === paragraph) {\n            listCol.push({node, pos});\n        }\n    });\n    for (let i = listCol.length - 1; i >= 0; i--) {\n        const paragraph = listCol[i];\n        const start = tr.doc.resolve(tr.mapping.map(paragraph.pos));\n        if (start.depth > 0) {\n            let end;\n            if (paragraph.node.textContent && paragraph.node.textContent.length > 0) {\n                end = tr.doc.resolve(\n                    tr.mapping.map(paragraph.pos + paragraph.node.textContent.length),\n                );\n            } else {\n                end = tr.doc.resolve(tr.mapping.map(paragraph.pos + 1));\n            }\n            const range = start.blockRange(end);\n            if (range) {\n                tr.lift(range, getListLiftTarget(state.schema, start));\n            }\n        }\n    }\n    return tr;\n}\n","import { Node, Mark, MarkType } from \"prosemirror-model\";\nimport { SelectionRange, EditorState, Transaction } from \"prosemirror-state\";\n\nexport const isMarkAllowedInRange = (\n    doc: Node,\n    ranges: Array<SelectionRange>,\n    type: MarkType,\n): boolean => {\n    for (let i = 0; i < ranges.length; i++) {\n        const { $from, $to } = ranges[i];\n        let can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, node => {\n            if (can) {\n                return false;\n            }\n            can = node.inlineContent && node.type.allowsMarkType(type);\n            return;\n        });\n        if (can) {\n            return can;\n        }\n    }\n    return false;\n};\n\nexport const isMarkExcluded = (\n    type: MarkType,\n    marks?: Array<Mark> | null,\n): boolean => {\n    if (marks) {\n        return marks.some(mark => mark.type !== type && mark.type.excludes(type));\n    }\n    return false;\n};\n\nconst not = <T>(fn: ((args: T) => boolean)) => (arg: T) => !fn(arg);\n\nexport const removeBlockMarks = (\n    state: EditorState,\n    marks: Array<MarkType | undefined>,\n): Transaction | undefined => {\n    const { selection, schema } = state;\n    let { tr } = state;\n\n    // Marks might not exist in Schema\n    const marksToRemove = marks.filter(Boolean);\n    if (marksToRemove.length === 0) {\n        return undefined;\n    }\n\n    /** Saves an extra dispatch */\n    let blockMarksExists = false;\n\n    const hasMark = (mark: Mark) => marksToRemove.indexOf(mark.type) > -1;\n    /**\n     * When you need to toggle the selection\n     * when another type which does not allow alignment is applied\n     */\n    state.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n        if (node.type === schema.nodes.paragraph && node.marks.some(hasMark)) {\n            blockMarksExists = true;\n            const resolvedPos = state.doc.resolve(pos);\n            const withoutBlockMarks = node.marks.filter(not(hasMark));\n            tr = tr.setNodeMarkup(\n                resolvedPos.pos,\n                undefined,\n                node.attrs,\n                withoutBlockMarks,\n            );\n        }\n    });\n    return blockMarksExists ? tr : undefined;\n};\n\n/**\n * Removes marks from nodes in the current selection that are not supported\n */\nexport const sanitizeSelectionMarks = (\n    state: EditorState,\n): Transaction | undefined => {\n    let tr: Transaction | undefined;\n    const { $from, $to } = state.tr.selection;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n        node.marks.forEach(mark => {\n            if (!node.type.allowsMarkType(mark.type)) {\n                const filteredMarks = node.marks.filter(m => m.type !== mark.type);\n                const position = pos > 0 ? pos - 1 : 0;\n                tr = (tr || state.tr).setNodeMarkup(\n                    position,\n                    undefined,\n                    node.attrs,\n                    filteredMarks,\n                );\n            }\n        });\n    });\n    return tr;\n};\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {HtmlEditor} from \"./editor\";\nimport {Command} from \"./prosemirror/command\";\nimport {indentList, outdentList, toggleList} from \"./prosemirror/list-commands\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findParentNode} from \"prosemirror-utils\";\n\n@Component({\n    styles: [`\n        :host { user-select: none; }\n        :host ion-list { margin: 0px; padding: 0px; }\n        :host ion-item:last-child { --border-width: 0px; }\n        :host ion-item-divider { --background: transparent; font-size: small }\n        :host ion-item-divider ion-label { margin-top: 20px; opacity: 0.8; }\n    `],\n    template: `\n        <ion-list lines=\"full\">\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleList('bulletList')\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Bulleted list\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeUnnumberedList\"></ion-icon>\n                <ion-icon src=\"assets/html-editor/list-bulleted.svg\" slot=\"start\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleList('orderedList')\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Numbered list\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeNumberedList\"></ion-icon>\n                <ion-icon src=\"assets/html-editor/list-numbered.svg\" slot=\"start\"></ion-icon>\n            </ion-item>\n\n            <ng-template [ngIf]=\"activeUnnumberedList || activeNumberedList\">\n\n                <ion-item-divider>\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Indent\" | intlMessage}}</ion-label>\n                </ion-item-divider>\n\n                <ion-item button=\"true\" detail=\"false\" (click)=\"level(-1)\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Decrease indent\" | intlMessage}}</ion-label>\n                    <ion-icon src=\"assets/html-editor/indent-decrease.svg\" slot=\"start\"></ion-icon>\n                </ion-item>\n\n                <ion-item button=\"true\" detail=\"false\" (click)=\"level(1)\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Increase indent\" | intlMessage}}</ion-label>\n                    <ion-icon src=\"assets/html-editor/indent-increase.svg\" slot=\"start\"></ion-icon>\n                </ion-item>\n\n            </ng-template>\n\n        </ion-list>\n    `\n})\nexport class ListMenu implements OnInit {\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    activeUnnumberedList: boolean;\n    activeNumberedList: boolean;\n\n    level(level: number) {\n\n        const command: Command = level < 0 ? outdentList() : indentList();\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    toggleList(type: \"bulletList\" | \"orderedList\") {\n        toggleList(this.editor.state, (tr) => this.editor.view.dispatch(tr), this.editor.view, type);\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n        this.activeUnnumberedList = !!findParentNode(predicate => predicate.hasMarkup(schema.nodes.bulletList))(this.editor.state.selection);\n        this.activeNumberedList = !!findParentNode(predicate => predicate.hasMarkup(schema.nodes.orderedList))(this.editor.state.selection);\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {MessageRef} from \"@co.mmons/js-intl\";\n\nexport class FontSize {\n\n    private static _sizes: FontSize[] = [];\n\n    static sizes() {\n        return FontSize._sizes.slice();\n    }\n\n    static readonly small = new FontSize(\"small\");\n    static readonly large = new FontSize(\"large\");\n\n    private constructor(public readonly size: string) {\n\n        FontSize._sizes.push(this);\n\n        this.label = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"textMenu/fontSize/\" + size.toUpperCase()[0] + size.substring(1));\n    }\n\n    readonly label: MessageRef;\n}\n","import {shallowEqual} from \"fast-equals\";\nimport {MarkType, Node} from \"prosemirror-model\";\nimport {Command} from \"../command\";\n\nfunction markApplies(doc: Node, from: number, to: number, type: MarkType) {\n\n    let applies = false;\n\n    doc.nodesBetween(from, to, (node, pos, parent) => {\n\n        if (applies) {\n            return false;\n        }\n\n        applies = node.isInline && parent.type.allowsMarkType(type);\n    });\n\n    return applies;\n}\n\n// return true iff all nodes in range have the mark with the same attrs\nfunction rangeHasMark(doc, from, to, type, attrs) {\n\n    let hasMark = null;\n\n    doc.nodesBetween(from, to, node => {\n\n        for (let i = 0; i < node.marks.length; i++) {\n            const markMatch = node.marks[i].type === type && (!attrs || shallowEqual(node.marks[i].attrs, attrs));\n            hasMark = (markMatch && (hasMark === null || hasMark === true));\n        }\n\n        return hasMark;\n    });\n\n    return !!hasMark;\n}\n\nexport function toggleInlineMark(markType: MarkType, attrs?: {[key: string]: any}): Command {\n\n    return function(state, dispatch) {\n\n        const { empty, from, to, $from } = state.selection;\n\n        if (!markApplies(state.doc, from, to, markType)) {\n            console.log(\"not applies\");\n            return false;\n        }\n\n        if (dispatch) {\n\n            if (empty) {\n\n                const markInSet = markType.isInSet(state.storedMarks || $from.marks());\n\n                if (markInSet && (!attrs || shallowEqual(markInSet.attrs, attrs))) {\n                    dispatch(state.tr.removeStoredMark(markType));\n                } else {\n                    dispatch(state.tr.addStoredMark(markType.create(attrs)));\n                }\n\n            } else {\n\n                if (rangeHasMark(state.doc, from, to, markType, attrs)) {\n                    dispatch(state.tr.removeMark(from, to, markType).scrollIntoView());\n                } else {\n                    dispatch(state.tr.addMark(from, to, markType.create(attrs)).scrollIntoView());\n                }\n            }\n        }\n\n        return true;\n    };\n}\n\n","import {Mark, MarkType, NodeType} from \"prosemirror-model\";\nimport {EditorState, NodeSelection} from \"prosemirror-state\";\n\nexport function isActive(state: EditorState, nodeType: NodeType, attrs?: {[key: string]: any}, marks?: Array<Mark<any>>) {\n\n    const selection = state.selection;\n\n    if (selection instanceof NodeSelection && selection.node) {\n        return selection.node.hasMarkup(nodeType, attrs, marks);\n    }\n\n    return selection.to <= selection.$from.end() && selection.$from.parent.hasMarkup(nodeType, attrs, marks);\n}\n\nexport function isMarkActive(state: EditorState, type: MarkType) {\n    const {from, $from, to, empty} = state.selection;\n\n    if (empty) {\n        return !!(type.isInSet(state.storedMarks || $from.marks()));\n    } else {\n        return state.doc.rangeHasMark(from, to, type);\n    }\n}\n\nexport function anyMarkActive(state: EditorState, types: MarkType[]) {\n\n    const {from, $from, to, empty} = state.selection;\n\n    if (empty) {\n\n        for (const type of types) {\n            if (type.isInSet(state.storedMarks || $from.marks())) {\n                return true;\n            }\n        }\n\n    } else {\n\n        for (const type of types) {\n            if (state.doc.rangeHasMark(from, to, type)) {\n                return true;\n            }\n        }\n\n    }\n\n    return false;\n}\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {toggleMark} from \"prosemirror-commands\";\nimport {HtmlEditor} from \"./editor\";\nimport {FontSize} from \"./font-sizes\";\nimport {Command} from \"./prosemirror/command\";\nimport {toggleInlineMark} from \"./prosemirror/commands/toogle-inline-mark\";\nimport {isMarkActive} from \"./prosemirror/is-active\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findMarksInSelection} from \"./prosemirror/utils/find-marks-in-selection\";\n\n@Component({\n    styles: [`\n        :host { user-select: none; }\n        :host ion-list { margin: 0px; padding: 0px; }\n        :host ion-item:last-child { --border-width: 0px; }\n        :host ion-item-divider { --background: transparent; font-size: small }\n        :host ion-item-divider ion-label { margin-top: 20px; opacity: 0.8; }\n    `],\n    template: `\n        <ion-list lines=\"full\">\n            \n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggle('bold')\">\n                <ion-label style=\"font-weight: bold\">{{\"@co.mmons/ionic-extensions/html-editor#textMenu/Bold\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"boldActivated\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggle('italic')\">\n                <ion-label style=\"font-style: italic\">{{\"@co.mmons/ionic-extensions/html-editor#textMenu/Italic\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"italicActivated\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggle('underline')\">\n                <ion-label style=\"text-decoration: underline\">{{\"@co.mmons/ionic-extensions/html-editor#textMenu/Underline\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"underlineActivated\"></ion-icon>\n            </ion-item>\n            \n            <ion-item-divider>\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#textMenu/fontSize/Text size\" | intlMessage}}</ion-label>\n            </ion-item-divider>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"resetFontSize()\" *ngIf=\"activeFontSize\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#textMenu/fontSize/Default\" | intlMessage}}</ion-label>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleFontSize(fontSize)\" *ngFor=\"let fontSize of FontSize.sizes()\">\n                <ion-label [style.fontSize]=\"fontSize.size\">{{fontSize.label | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeFontSize === fontSize\"></ion-icon>\n            </ion-item>\n\n        </ion-list>\n    `\n})\nexport class TextFormatMenu implements OnInit {\n\n    readonly FontSize = FontSize;\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    @Input()\n    editor: HtmlEditor;\n\n    boldActivated: boolean;\n\n    italicActivated: boolean;\n\n    underlineActivated: boolean;\n\n    activeFontSize: FontSize;\n\n\n    toggle(name: string) {\n\n        let command: Command;\n\n        if (name === \"bold\") {\n            command = toggleMark(schema.marks.strong);\n        } else if (name === \"italic\") {\n            command = toggleMark(schema.marks.em);\n        } else if (name === \"underline\") {\n            command = toggleMark(schema.marks.underline);\n        }\n\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    resetFontSize() {\n        toggleMark(schema.marks.fontSize)(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        this.popoverController.dismiss();\n    }\n\n    toggleFontSize(size: FontSize) {\n\n        const command = toggleInlineMark(schema.marks.fontSize, {fontSize: size.size});\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n        this.boldActivated = isMarkActive(this.editor.state, schema.marks.strong);\n        this.italicActivated = isMarkActive(this.editor.state, schema.marks.em);\n        this.underlineActivated = isMarkActive(this.editor.state, schema.marks.underline);\n\n        this.activeFontSize = undefined;\n        MARKS: for (const mark of findMarksInSelection(this.editor.state, schema.marks.fontSize)) {\n\n            for (const size of FontSize.sizes()) {\n                if (size.size === mark.attrs.fontSize) {\n\n                    // ups, mamy różne rozmiary w zaznaczeniu\n                    if (this.activeFontSize && size !== this.activeFontSize) {\n                        this.activeFontSize = undefined;\n                        break MARKS;\n                    }\n\n                    this.activeFontSize = size;\n                }\n            }\n        }\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {Component, OnDestroy, OnInit} from \"@angular/core\";\nimport {EventManager} from \"@angular/platform-browser\";\nimport {unsubscribe} from \"@co.mmons/rxjs-utils\";\nimport {ModalController, Platform, PopoverController} from \"@ionic/angular\";\nimport {redo, redoDepth, undo, undoDepth} from \"prosemirror-history\";\nimport {findParentNode, findParentNodeOfType} from \"prosemirror-utils\";\nimport {Subscription} from \"rxjs\";\nimport {AlignmentMenu} from \"./alignment-menu\";\nimport {HtmlEditor} from \"./editor\";\nimport {HeadingMenu} from \"./heading-menu\";\nimport {InsertMenu} from \"./insert-menu\";\nimport {LinkModal} from \"./link-modal\";\nimport {ListMenu} from \"./list-menu\";\nimport {anyMarkActive, isMarkActive} from \"./prosemirror/is-active\";\nimport {schema} from \"./prosemirror/schema\";\nimport {isBlockMarkActive} from \"./prosemirror/utils/selection/is-block-mark-active\";\nimport {TextFormatMenu} from \"./text-format-menu\";\n\n@Component({\n    selector: \"ionx-html-editor-toolbar\",\n    template: `\n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.text\" (click)=\"showMenu($event, 'text')\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Text\" | intlMessage}}</span>\n        </ion-button>\n\n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.alignment\" (click)=\"showMenu($event, 'alignment')\" *ngIf=\"!editor.features || editor.features.alignment\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Alignment\" | intlMessage}}</span>\n        </ion-button>\n\n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.heading\" (click)=\"showMenu($event, 'heading')\" *ngIf=\"!editor.features || editor.features.heading\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}}</span>\n        </ion-button>\n        \n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.list\" (click)=\"showMenu($event, 'list')\" *ngIf=\"!editor.features || editor.features.list\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/List\" | intlMessage}}</span>\n        </ion-button>\n\n        <ion-button size=\"small\" fill=\"clear\" (click)=\"showMenu($event, 'insert')\" *ngIf=\"!editor.features || editor.features.link || editor.features.multimedia\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Insert\" | intlMessage}}</span>\n        </ion-button>\n        \n        <ion-button size=\"small\" fill=\"clear\" class=\"active-feature\" (click)=\"editLink()\" *ngIf=\"activeFeatures.link\">\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#link/Link\" | intlMessage}}</span>\n        </ion-button>\n        \n        <div ionx--buttons-group>\n            <ion-button size=\"small\" fill=\"clear\" tabindex=\"-1\" title=\"{{'@co.mmons/ionic-extensions/html-editor#Undo' | intlMessage}}\" [disabled]=\"!canUndo\" (click)=\"undo()\">\n                <ion-icon name=\"undo\" slot=\"icon-only\"></ion-icon>\n            </ion-button>\n    \n            <ion-button size=\"small\" fill=\"clear\" title=\"{{'@co.mmons/ionic-extensions/html-editor#Redo' | intlMessage}}\" [disabled]=\"!canRedo\" (click)=\"redo()\">\n                <ion-icon name=\"redo\" slot=\"icon-only\"></ion-icon>\n            </ion-button>\n        </div>\n    `,\n    styles: [`\n        :host { outline: none; display: flex; justify-content: center; flex-wrap: wrap; position: sticky; position: -webkit-sticky; top: 0px; background-color: var(--background); z-index: 1; }\n        :host-context(.ion-focused) { background-color: var(--background-focused); }\n        :host ion-button { margin: 0px 4px; --padding-end: 2px; --padding-start: 4px; }\n        :host ion-button.active-feature span { font-weight: 800; }\n        :host ion-icon[slot=\"end\"] { margin: 0px; }\n        :host ion-button[disabled] { opacity: 0.5; }\n        :host [ionx--buttons-group] { display: flex; }\n        :host [ionx--buttons-group] ion-button:not(:last-child) { margin-right: 0px; }\n    `]\n})\nexport class Toolbar implements OnInit, OnDestroy {\n\n    constructor(\n        private popoverController: PopoverController,\n        private platform: Platform,\n        public readonly editor: HtmlEditor,\n        protected eventManager: EventManager,\n        private modalController: ModalController\n    ) {\n\n    }\n\n    async showMenu(event: Event, menu: string) {\n\n        const components = {\n            text: TextFormatMenu,\n            list: ListMenu,\n            alignment: AlignmentMenu,\n            insert: InsertMenu,\n            heading: HeadingMenu\n        };\n\n        const popover = await this.popoverController.create({\n            component: components[menu],\n            componentProps: {\n                editor: this.editor\n            },\n            event: event,\n            showBackdrop: this.platform.is(\"ios\")\n        });\n\n        popover.present();\n    }\n\n    activeFeatures: {\n        link?: boolean,\n        text?: boolean,\n        alignment?: boolean,\n        heading?: boolean;\n        list?: boolean\n    } = {};\n\n    async editLink() {\n        LinkModal.present(this.modalController, this.editor);\n    }\n\n    canUndo: boolean;\n\n    canRedo: boolean;\n\n    undo() {\n        undo(this.editor.view.state, (transaction) => this.editor.view.updateState(this.editor.view.state.apply(transaction)));\n        this.editor.focus();\n    }\n\n    redo() {\n        redo(this.editor.view.state, (transaction) => this.editor.view.updateState(this.editor.view.state.apply(transaction)));\n        this.editor.focus();\n\n    }\n\n    private editorSelectionChanged() {\n\n        this.canUndo = undoDepth(this.editor.view.state) > 0;\n        this.canRedo = redoDepth(this.editor.view.state) > 0;\n\n        this.activeFeatures = {};\n\n        this.activeFeatures.text = anyMarkActive(this.editor.view.state, [schema.marks.strong, schema.marks.em, schema.marks.underline, schema.marks.fontSize]);\n        this.activeFeatures.list = !!findParentNode(predicate => predicate.hasMarkup(schema.nodes.orderedList) || predicate.hasMarkup(schema.nodes.bulletList))(this.editor.state.selection);\n        this.activeFeatures.alignment = isBlockMarkActive(this.editor.view.state, schema.marks.alignment);\n        this.activeFeatures.heading = !!findParentNodeOfType(schema.nodes.heading)(this.editor.state.selection);\n        this.activeFeatures.link = isMarkActive(this.editor.view.state, schema.marks.link);\n    }\n\n    private selectionSubscription: Subscription;\n\n    async ngOnInit() {\n\n        this.selectionSubscription = this.editor.selectionChange.subscribe(() => this.editorSelectionChanged());\n\n        this.editorSelectionChanged();\n    }\n\n    ngOnDestroy() {\n        unsubscribe(this.selectionSubscription);\n    }\n\n}\n","import {MarkType} from \"prosemirror-model\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport function isBlockMarkActive(state: EditorState, type: MarkType) {\n    const {from, $from, to, empty} = state.selection;\n\n    if (empty) {\n\n        for (const mark of $from.parent.marks) {\n            if (mark.type === type) {\n                return true;\n            }\n        }\n    } else {\n        return state.doc.rangeHasMark(from, to, type);\n    }\n}\n","import {CommonModule} from \"@angular/common\";\nimport {NgModule} from \"@angular/core\";\nimport {FormsModule, ReactiveFormsModule} from \"@angular/forms\";\nimport {MatchMediaModule} from \"@co.mmons/angular-extensions/browser/match-media\";\nimport {IntlModule} from \"@co.mmons/angular-intl\";\nimport {FormHelperModule} from \"@co.mmons/ionic-extensions/form-helper\";\nimport {SelectModule} from \"@co.mmons/ionic-extensions/select\";\nimport {SpinnerModule} from \"@co.mmons/ionic-extensions/spinner\";\nimport {IonicModule} from \"@ionic/angular\";\nimport {ButtonsModule} from \"@co.mmons/ionic-extensions/buttons\";\nimport {AlignmentMenu} from \"./alignment-menu\";\nimport {HtmlEditor} from \"./editor\";\nimport {HeadingMenu} from \"./heading-menu\";\nimport {InsertMenu} from \"./insert-menu\";\nimport {LinkModal} from \"./link-modal\";\nimport {ListMenu} from \"./list-menu\";\nimport {TextFormatMenu} from \"./text-format-menu\";\nimport {Toolbar} from \"./toolbar\";\n\nexport {HtmlEditor} from \"./editor\";\nexport {HtmlEditorFeatures} from \"./editor-features\";\n\n@NgModule({\n    imports: [CommonModule, IonicModule, IntlModule, SelectModule, FormsModule, ReactiveFormsModule, FormHelperModule, ButtonsModule, MatchMediaModule, SpinnerModule],\n    declarations: [HtmlEditor, AlignmentMenu, HeadingMenu, InsertMenu, LinkModal, ListMenu, TextFormatMenu, Toolbar],\n    exports: [HtmlEditor, IntlModule],\n    entryComponents: [AlignmentMenu, HeadingMenu, InsertMenu, LinkModal, ListMenu, TextFormatMenu]\n})\nexport class HtmlEditorModule {\n}\n"]}