{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@co.mmons/ionic-extensions/html-editor/alignment.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/toogle-block-mark.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/marks/font-size.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/marks/alignment.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/nodes/youtube.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/schema.ts","ng://@co.mmons/ionic-extensions/html-editor/alignment-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/alignment/commands.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/selection/find-block-marks.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/keymap.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/views/youtube.ts","ng://@co.mmons/ionic-extensions/html-editor/scroll.ts","ng://@co.mmons/ionic-extensions/html-editor/editor.ts","ng://@co.mmons/ionic-extensions/html-editor/heading-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/link-type.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-marks-in-selection.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-marks.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-node-start-end.ts","ng://@co.mmons/ionic-extensions/html-editor/link-modal.ts","ng://@co.mmons/ionic-extensions/html-editor/insert-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/filter.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/is-empty-selection-at-start.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list/transforms/lift-following-list.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list/utils/get-list-lift-target.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/mark-utils.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-cut-before.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list-commands.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/is-first-child-of-parent.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list/transforms/lift-selection-list.ts","ng://@co.mmons/ionic-extensions/html-editor/list-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/font-sizes.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/toogle-inline-mark.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/is-active.ts","ng://@co.mmons/ionic-extensions/html-editor/text-format-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/toolbar.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/selection/is-block-mark-active.ts","ng://@co.mmons/ionic-extensions/html-editor/index.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","pop","push","__values","o","m","__read","ar","error","__spread","concat","Alignment","alignment","_alignments","MessageRef","alignments","slice","left","right","center","justify","toggleBlockMark","markType","getAttrs","allowedBlocks","state","dispatch","markApplied","tr","_a","selection","from","to","doc","nodesBetween","node","pos","parent","type","isBlock","isArray","indexOf","schema","allowsMarkType","oldMarks","marks","filter","mark","prevAttrs","attrs","undefined","newAttrs","setNodeMarkup","excludes","create","toggleBlockMarkOnRange","docChanged","scrollIntoView","fontSize","group","parseDOM","tag","dom","size","getAttribute","toDOM","style","data-font-size","align","data-align","youtube","id","default","start","inline","draggable","data-youtube","info","split","nodes","content","paragraph","blockquote","basicNodes","horizontalRule","horizontal_rule","heading","text","hardBreak","hard_break","bulletList","assign","orderedList","listItem","link","basicMarks","em","strong","underline","Schema","AlignmentMenu","popoverController","prototype","toggleAligment","_this","command","_b","editor","view","dismiss","ngOnInit","active","tslib_1.__values","_c","findBlockMarks","ionViewWillLeave","focus","PopoverController","tslib_1.__decorate","Input","Component","template","mac","navigator","test","platform","buildKeymap","mapKeys","keys","bind","cmd","mapped","undo","redo","undoInputRule","joinUp","joinDown","lift","selectParentNode","toggleMark","splitListItem","br_1","replaceSelectionWith","createYoutubeIframe","iframe","document","createElement","height","width","src","frameBorder","allow","allowFullscreen","YoutubeNodeView","eventManager","position","overflow","marginTop","setAttribute","appendChild","overlay","top","display","justifyContent","button","classList","add","deleteUnlisten","addEventListener","deleteNode","icon","slot","removeSelectedNode","selectNode","deselectNode","remove","update","destroy","stopEvent","event","ignoreMutation","findScrollParent","element","scrollHeight","clientHeight","overflowY","window","getComputedStyle","assignedSlot","parentElement","parentRect","getBoundingClientRect","rect","bottom","top_1","offsetTop","offsetParent","scrollTo","scrollToCaret","range","range0","getSelection","getRangeAt","startContainer","offset","startOffset","createRange","setStart","setEnd","styles","lineHeight","parseInt","delta","caretTopPoint","top_2","behavior","HtmlEditor","formControl","item","eventUnlisteners","change","EventEmitter","selectionChange","valueAccessor","HtmlEditor_1","idGenerator","itemInputWrapper","nativeElement","DOMSerializer","fromSchema","serializeFragment","tmp","innerText","prepareOutputValue","uninitializedValue","html","EditorState","plugins","editorDoc","updateState","silentChanges","querySelectorAll","forEach","params","innerHTML","prepareInputValue","setDisabledState","isDisabled","disabled","writeValue","registerOnChange","fn","controlOnChange","registerOnTouched","controlOnTouched","scrollParent","preventScroll","selectedView","querySelector","domAtPos","nodeType","Node","TEXT_NODE","editorInitialized","editorFocused","focused","updateItemClasses","editorBlured","handleScroll","DOMParser","parse","resetControlCss","classes","ion-untouched","untouched","ion-touched","touched","ion-pristine","pristine","ion-dirty","dirty","ion-valid","valid","ion-invalid","elements","elements_1","elements_1_1","fixItemOverflow","item_1","waitTill","shadowRoot","editorTransaction","transaction","readonlyChanged","readonly","ngAfterViewInit","ngAfterContentChecked","ngOnDestroy","unlisten","keymap","baseKeymap","gapCursor","history","EditorView","dispatchTransaction","handleScrollToSelection","nodeViews","ngOnChanges","changes","ElementRef","EventManager","NgControl","Optional","IonItem","HostBinding","Output","selector","tslib_1.__param","HeadingMenu","toggleHeading","activeHeading","setBlockType","level","findParentNodeOfType","DefaultLinkType","_super","inputComponent","inputType","inputValidators","urlValidator","inputLabel","Validators","email","inputHint","__","constructor","tslib_1.__extends","uri","fromLink","www","tel","sms","other","LinkType","toString","urlValidatorRegex","control","invalidUrl","findMarksInSelection","deepEqual","findMarks","findNodeStartEnd","$pos","textOffset","end","child","index","nodeSize","LinkModal","modalController","present","component","LinkModal_1","componentProps","close","unlink","empty","tr_1","isText","removeMark","ok","formHelper","validateAll","form","linkType_1","controls","tr_2","addMark","href","typeChanged","markAsDirty","updateValueAndValidity","sleep","parseLink","prefixes","http:","https:","tel:","sms:","mailto:","lowerCasedUri","trim","toLowerCase","prefix","startsWith","substring","linkValidator","required","validators","validators_1","validators_1_1","validator","ionViewDidEnter","types","FormGroup","FormControl","existingType","existingLink","setValidators","typeChangesSubscription","valueChanges","subscribe","MARKS","parsed","existing","unsubscribe","ModalController","ViewChild","FormHelper","static","InsertMenu","insertLink","insertYoutube","inputView","youtubeInput","setFocus","parseYoutube","replace","splice","param","applyYoutube","cancel","role","ionViewDidLeave","predicates","some","pred","isEmptySelectionAtStart","$from","parentOffset","GapCursor","liftListItem","$to","blockRange","childCount","firstChild","depth","endOfList","ReplaceAroundStep","Slice","Fragment","copy","NodeRange","liftTarget","getListLiftTarget","resPos","sanitizeSelectionMarks","filteredMarks","isRangeOfType","maxDepth","findAncestorPosition","current","Math","min","after","getAncestorNodesBetween","nestableBlocks","newPos","before","name","compose","func","funcs","_i","allFuncs","raw","reduceRight","memo","findCutBefore","spec","isolating","maxIndentation","deletePreviousEmptyListItem","$cut","nodeBefore","delete","joinToPreviousListItem","codeBlock","isGapCursorShown","nodeAfter","$lastNode","nodeBeforePos","findPositionOfNodeBefore","list","append","createChecked","replaceWith","$postCut","mapping","map","join","isInsideListItem","hasParentNodeOfType","canToJoinToPreviousListItem","$before","canOutdent","baseCommand.chainCommands","outdentList","$start","$end","$join","mergeLists","baseListCommand.liftListItem","indentList","initialIndentationLevel","currentIndentationLevel","currentPos","resolvedPos","numberNestedLists","canSink","baseListCommand.sinkListItem","liftListItems","isTextblock","sel","NodeSelection","count","toggleList","listType","fromNode","endNode","rootListDepth","lifted","listDepth","textContent","TextSelection","liftFollowingList","listCol","paragraph_1","liftSelectionList","setSelection","isSameLine","startPos","endPos","nodeAt","adjustSelectionInList","isRangeOfSingleType","grandgrandParent","isInsideList","baseCommand.autoJoin","baseListCommand.wrapInList","toggleListCommand","ListMenu","activeUnnumberedList","findParentNode","predicate","hasMarkup","activeNumberedList","FontSize","_sizes","toUpperCase","sizes","small","large","toggleInlineMark","applies","isInline","markApplies","console","log","markInSet","isInSet","storedMarks","shallowEqual","addStoredMark","removeStoredMark","hasMark","markMatch","rangeHasMark","isMarkActive","TextFormatMenu","toggle","resetFontSize","toggleFontSize","boldActivated","italicActivated","underlineActivated","activeFontSize","_d","_e","_f","Toolbar","activeFeatures","showMenu","menu","components","insert","showBackdrop","is","editLink","editorSelectionChanged","canUndo","undoDepth","canRedo","redoDepth","types_1","types_1_1","types_2","types_2_1","anyMarkActive","isBlockMarkActive","selectionSubscription","Platform","HtmlEditorModule","NgModule","imports","CommonModule","IonicModule","IntlModule","SelectModule","FormsModule","ReactiveFormsModule","FormHelperModule","ButtonsModule","MatchMediaModule","SpinnerModule","declarations","exports","entryComponents"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {MessageRef} from \"@co.mmons/js-intl\";\n\nexport class Alignment {\n\n    private static _alignments: Alignment[] = [];\n\n    static alignments() {\n        return Alignment._alignments.slice();\n    }\n\n    static readonly left = new Alignment(\"left\");\n    static readonly right = new Alignment(\"right\");\n    static readonly center = new Alignment(\"center\");\n    static readonly justify = new Alignment(\"justify\");\n\n    private constructor(public readonly alignment: string) {\n\n        Alignment._alignments.push(this);\n\n        this.label = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"alignmentMenu/\" + alignment);\n    }\n\n    readonly label: MessageRef;\n}\n","import {MarkType, Node as PMNode, NodeType, Schema} from \"prosemirror-model\";\nimport {Transaction} from \"prosemirror-state\";\nimport {Command} from \"../command\";\n\n/**\n * Toggles block mark based on the return type of `getAttrs`.\n * This is similar to ProseMirror\"s `getAttrs` from `AttributeSpec`\n * return `false` to remove the mark.\n * return `undefined for no-op.\n * return an `object` to update the mark.\n */\nexport const toggleBlockMark = <T = object>(\n    markType: MarkType,\n    getAttrs: ((prevAttrs?: T, node?: PMNode) => T | undefined | false),\n    allowedBlocks?:\n        | Array<NodeType>\n        | ((schema: Schema, node: PMNode, parent: PMNode) => boolean),\n): Command => (state, dispatch) => {\n    let markApplied = false;\n    const tr = state.tr;\n\n    const toggleBlockMarkOnRange = (from: number, to: number, tr: Transaction) => {\n\n        state.doc.nodesBetween(from, to, (node, pos, parent) => {\n\n            if (!node.type.isBlock) {\n                return false;\n            }\n\n            if (\n                (!allowedBlocks || (Array.isArray(allowedBlocks) ? allowedBlocks.indexOf(node.type) > -1 : allowedBlocks(state.schema, node, parent))) &&\n                parent.type.allowsMarkType(markType)\n            ) {\n\n                const oldMarks = node.marks.filter(mark => mark.type === markType);\n\n                const prevAttrs = oldMarks.length ? (oldMarks[0].attrs as T) : undefined;\n                const newAttrs = getAttrs(prevAttrs, node);\n\n                if (newAttrs !== undefined) {\n\n                    tr.setNodeMarkup(\n                        pos,\n                        node.type,\n                        node.attrs,\n                        node.marks\n                            .filter(mark => !markType.excludes(mark.type))\n                            .concat(newAttrs === false ? [] : markType.create(newAttrs)),\n                    );\n\n                    markApplied = true;\n                }\n            }\n\n            return;\n\n        });\n    };\n\n    const {from, to} = state.selection;\n    toggleBlockMarkOnRange(from, to, tr);\n\n    if (markApplied && tr.docChanged) {\n        if (dispatch) {\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n\n    return false;\n};\n","import {MarkSpec} from \"prosemirror-model\";\n\nexport const fontSize: MarkSpec = {\n    excludes: \"fontSize\",\n    group: \"fontSize\",\n    attrs: {\n        fontSize: {},\n    },\n    parseDOM: [\n        {\n            tag: \"span[data-font-size]\",\n            getAttrs: dom => {\n                const size = (dom as Element).getAttribute(\"data-font-size\");\n                return size ? {fontSize: size} : false;\n            },\n        },\n    ],\n    toDOM(mark) {\n        return [\n            \"span\",\n            {style: `font-size: ${mark.attrs.fontSize}`, \"data-font-size\": mark.attrs.fontSize},\n            0\n        ];\n    },\n};\n","import {MarkSpec} from \"prosemirror-model\";\n\nexport const alignment: MarkSpec = {\n    excludes: \"alignment\",\n    group: \"alignment\",\n    attrs: {\n        align: {},\n    },\n    parseDOM: [\n        {\n            tag: \"div[data-align]\",\n            getAttrs: dom => {\n                const align = (dom as Element).getAttribute(\"data-align\");\n                return align ? {align} : false;\n            },\n        },\n    ],\n    toDOM(mark) {\n        return [\n            \"div\",\n            {\n                style: `text-align: ${mark.attrs.align}`,\n                \"data-align\": mark.attrs.align,\n            },\n            0\n        ];\n    },\n};\n","import {NodeSpec} from \"prosemirror-model\";\n\nexport const youtube: NodeSpec = {\n    attrs: {id: {default: \"\"}, start: {default: 0}},\n    inline: false,\n    group: \"block\",\n    draggable: false,\n\n    toDOM: (node) => {\n\n        return [\n            \"div\",\n            {\"data-youtube\": node.attrs.id + (node.attrs.start ? \",\" + node.attrs.start : \"\")},\n            \"youtube\"\n        ];\n    },\n\n    parseDOM: [\n        {\n            tag: \"div[data-youtube]\",\n            getAttrs: (dom) => {\n\n                // @ts-ignore\n                const info = dom.getAttribute(\"data-youtube\").split(\",\");\n\n                return {\n                    id: info[0],\n                    start: info.length > 1 ? info[1] : 0\n                };\n            },\n        }\n    ]\n};\n","import {MarkSpec, NodeSpec, Schema} from \"prosemirror-model\";\nimport {marks as basicMarks, nodes as basicNodes} from \"prosemirror-schema-basic\";\nimport {bulletList, listItem, orderedList} from \"prosemirror-schema-list\";\nimport {fontSize} from \"./marks/font-size\";\nimport {alignment} from \"./marks/alignment\";\nimport {youtube} from \"./nodes/youtube\";\n\nexport const nodes = {\n    doc: {\n        content: \"block+\",\n        marks: \"alignment\",\n    },\n\n    paragraph: {\n        content: \"inline*\",\n        marks: \"alignment strong underline em fontSize link\",\n        group: \"block\",\n        parseDOM: [{tag: \"p\"}],\n        toDOM() { return [\"p\", 0]; }\n    } as NodeSpec,\n\n    blockquote: basicNodes.blockquote,\n    horizontalRule: basicNodes.horizontal_rule,\n    heading: basicNodes.heading,\n    text: basicNodes.text,\n    hardBreak: basicNodes.hard_break,\n\n    bulletList: Object.assign({}, bulletList, {\n        content: \"listItem+\",\n        group: \"block\"\n    }) as NodeSpec,\n\n    orderedList: Object.assign({}, orderedList, {\n        content: \"listItem+\",\n        group: \"block\"\n    }) as NodeSpec,\n\n    listItem: Object.assign({}, listItem, {\n        content: \"paragraph block*\",\n        marks: \"alignment\"\n    }) as NodeSpec,\n\n    youtube\n};\n\nexport const marks = {\n    link: basicMarks.link,\n    em: basicMarks.em,\n    strong: basicMarks.strong,\n    alignment,\n    fontSize: fontSize,\n\n    underline: {\n        parseDOM: [{tag: \"u\"}, {style: \"text-decoration=underline\"}],\n        toDOM() {\n            return [\"u\", 0];\n        }\n    } as MarkSpec\n};\n\nexport const schema = new Schema<keyof typeof nodes, keyof typeof marks>({nodes: nodes, marks: marks});\n\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {Alignment} from \"./alignment\";\nimport {HtmlEditor} from \"./editor\";\nimport {changeAlignment} from \"./prosemirror/alignment/commands\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findBlockMarks} from \"./prosemirror/utils/selection/find-block-marks\";\n\n@Component({\n    styles: [`\n        :host ion-list { margin: 0px; padding: 0px; }\n        :host ion-item:last-child { --border-width: 0px; }\n    `],\n    template: `\n        <ion-list lines=\"full\">\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleAligment(alignment)\" *ngFor=\"let alignment of Alignment.alignments()\">\n                <ion-label>{{alignment.label | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"active === alignment.alignment\"></ion-icon>\n                <ion-icon src=\"assets/html-editor/align-{{alignment.alignment}}.svg\" slot=\"start\"></ion-icon>\n            </ion-item>\n\n        </ion-list>\n    `\n})\nexport class AlignmentMenu implements OnInit {\n\n    Alignment = Alignment;\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    active: string;\n\n    toggleAligment(alignment: Alignment) {\n\n        const command = changeAlignment(<any>alignment.alignment);\n\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n\n        this.active = undefined;\n\n        for (const mark of findBlockMarks(this.editor.state, schema.marks.alignment)) {\n\n            // zaznaczonych wiele blockÃ³w z rÃ³Å¼nym wyrÃ³wnaniem\n            if (this.active && this.active !== mark.attrs.align) {\n                this.active = undefined;\n                break;\n            }\n\n            this.active = mark.attrs.align;\n        }\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {EditorState, Transaction} from \"prosemirror-state\";\nimport {Command, CommandDispatch} from \"../command\";\nimport {toggleBlockMark} from \"../commands/toogle-block-mark\";\nimport {AlignmentState} from \"./alignment-state\";\n\n/**\n * Iterates over the commands one after the other,\n * passes the tr through and dispatches the cumulated transaction\n */\nexport const cascadeCommands = (cmds: Array<Command>) => (\n    state: EditorState,\n    dispatch?: CommandDispatch,\n) => {\n    const {tr: baseTr} = state;\n    let shouldDispatch = false;\n\n    const onDispatchAction = (tr: Transaction) => {\n        tr.steps.forEach(st => {\n            baseTr.step(st);\n        });\n        shouldDispatch = true;\n    };\n\n    cmds.forEach(cmd => {\n        cmd(state, onDispatchAction);\n    });\n\n    if (dispatch && shouldDispatch) {\n        dispatch(baseTr);\n        return true;\n    }\n    return false;\n};\n\nexport const isAlignable = (align?: AlignmentState): Command => (state, dispatch) => {\n\n    const {\n        nodes: {paragraph, heading},\n        marks: {alignment},\n    } = state.schema;\n\n    return toggleBlockMark(\n        alignment,\n        () => (!align ? undefined : align === \"left\" ? false : {align}),\n        [paragraph, heading],\n    )(state, dispatch);\n};\n\nexport const changeAlignment = (align?: AlignmentState): Command => (state, dispatch) => {\n\n    const {\n        nodes: {paragraph, heading},\n        marks: {alignment}\n    } = state.schema;\n\n    return toggleBlockMark(alignment,\n        () => (!align ? undefined : align === \"left\" ? false : {align}),\n        [paragraph, heading],\n    )(state, dispatch);\n};\n","import {Mark, MarkType} from \"prosemirror-model\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport function findBlockMarks(state: EditorState, markType: MarkType) {\n\n    const marks: Mark[] = [];\n\n    const {from, to} = state.selection;\n\n    state.doc.nodesBetween(from, to, (node, pos, parent) => {\n\n        if (!node.type.isBlock) {\n            return false;\n        }\n\n        for (const mark of node.marks) {\n            if (mark.type === markType) {\n                marks.push(mark);\n            }\n        }\n\n    });\n\n\n    return marks;\n}\n","import {joinDown, joinUp, lift, selectParentNode, toggleMark} from \"prosemirror-commands\";\nimport {redo, undo} from \"prosemirror-history\";\nimport {undoInputRule} from \"prosemirror-inputrules\";\nimport {Schema} from \"prosemirror-model\";\nimport {splitListItem} from \"prosemirror-schema-list\";\n\nconst mac = typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n\nexport function buildKeymap(schema: Schema, mapKeys?: any) {\n\n    const keys = {};\n    let type: any;\n\n    function bind(key, cmd) {\n\n        if (mapKeys) {\n            const mapped = mapKeys[key];\n\n            if (mapped === false) {\n                return;\n            }\n\n            if (mapped) {\n                key = mapped;\n            }\n        }\n\n        keys[key] = cmd;\n    }\n\n\n    bind(\"Mod-z\", undo);\n    bind(\"Shift-Mod-z\", redo);\n    bind(\"Backspace\", undoInputRule);\n    if (!mac) {\n        bind(\"Mod-y\", redo);\n    }\n\n    bind(\"Alt-ArrowUp\", joinUp);\n    bind(\"Alt-ArrowDown\", joinDown);\n    bind(\"Mod-BracketLeft\", lift);\n    bind(\"Escape\", selectParentNode);\n\n    if (type = schema.marks.strong) {\n        bind(\"Mod-b\", toggleMark(type));\n        bind(\"Mod-B\", toggleMark(type));\n    }\n\n    if (type = schema.marks.em) {\n        bind(\"Mod-i\", toggleMark(type));\n        bind(\"Mod-I\", toggleMark(type));\n    }\n\n    if (type = schema.marks.underline) {\n        bind(\"Mod-u\", toggleMark(type));\n        bind(\"Mod-U\", toggleMark(type));\n    }\n\n    if (type = schema.nodes.listItem) {\n        bind(\"Enter\", splitListItem(type));\n    }\n\n    if (type = schema.nodes.hardBreak) {\n\n        const br = type;\n\n        const cmd = (state, dispatch) => {\n            dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());\n            return true;\n        };\n\n        bind(\"Mod-Enter\", cmd);\n        bind(\"Shift-Enter\", cmd);\n\n        if (mac) {\n            bind(\"Ctrl-Enter\", cmd);\n        }\n    }\n\n    return keys;\n}\n","import {EventManager} from \"@angular/platform-browser\";\nimport {Node} from \"prosemirror-model\";\nimport {removeSelectedNode} from \"prosemirror-utils\";\nimport {EditorView, NodeView} from \"prosemirror-view\";\n\nexport function createYoutubeIframe(id: string, start?: string) {\n\n    const iframe = document.createElement(\"iframe\");\n    iframe.height = \"200px\";\n    iframe.width = \"100%\";\n    iframe.src = `https://www.youtube.com/embed/${id}${start ? \"?start=\" + start : \"\"}`;\n    iframe.frameBorder = \"0\";\n    iframe.allow = \"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\";\n    iframe.allowFullscreen = true;\n\n    return iframe;\n}\n\n// https://www.youtube.com/watch?v=m3V7_Ov52sY\nexport class YoutubeNodeView implements NodeView {\n\n    constructor(node: Node, protected view: EditorView, eventManager: EventManager) {\n\n        this.dom = document.createElement(\"div\");\n        this.dom.style.position = \"relative\";\n        this.dom.style.overflow = \"hidden\";\n        this.dom.style.height = \"200px\";\n        this.dom.style.marginTop = \"16px\";\n        this.dom.setAttribute(\"no-blur\", \"\");\n\n        this.dom.appendChild(createYoutubeIframe(node.attrs.id, node.attrs.start));\n\n        const overlay = this.dom.appendChild(document.createElement(\"div\"));\n        overlay.style.position = \"absolute\";\n        overlay.style.left = \"0px\";\n        overlay.style.top = \"0px\";\n        overlay.style.width = \"100%\";\n        overlay.style.height = \"200px\";\n        overlay.style.display = \"flex\";\n        overlay.style.justifyContent = \"center\";\n\n        const button = overlay.appendChild(document.createElement(\"ion-button\"));\n        button.classList.add(\"ionx--interactive\");\n        button.setAttribute(\"color\", \"primary\");\n        this.deleteUnlisten = eventManager.addEventListener(button, \"click\", () => this.deleteNode());\n\n        const icon = document.createElement(\"ion-icon\");\n        icon.setAttribute(\"name\", \"trash\");\n        icon.slot = \"icon-only\";\n        button.appendChild(icon);\n    }\n\n    private deleteUnlisten: Function;\n\n    dom: HTMLElement;\n\n    private deleteNode() {\n        this.view.dispatch(removeSelectedNode(this.view.state.tr));\n    }\n\n    selectNode() {\n        this.dom.classList.add(\"ionx--selected\");\n    }\n\n    deselectNode() {\n        this.dom.classList.remove(\"ionx--selected\");\n    }\n\n    update(node: Node) {\n        return false;\n    }\n\n    destroy() {\n\n        if (this.deleteUnlisten) {\n            this.deleteUnlisten();\n        }\n    }\n\n    stopEvent(event: Event) {\n        return false;\n    }\n\n    ignoreMutation() {\n        return true;\n    }\n}\n","export function findScrollParent(element: HTMLElement): HTMLElement {\n\n    if (!element) {\n        return;\n    }\n\n    if (element.scrollHeight >= element.clientHeight) {\n        const overflowY = window.getComputedStyle(element).overflowY;\n        if (overflowY !== \"visible\" && overflowY !== \"hidden\") {\n            return element;\n        }\n    }\n\n    if (element.assignedSlot) {\n        const p = findScrollParent(element.assignedSlot.parentElement);\n        if (p) {\n            return p;\n        }\n    }\n\n    return findScrollParent(element.parentElement);\n}\n\nexport function scrollIntoView(element: HTMLElement, parent: HTMLElement) {\n\n    if (parent) {\n\n        const parentRect = parent.getBoundingClientRect();\n        const rect = element.getBoundingClientRect();\n\n        if (!(rect.top > parentRect.top && rect.top <= parentRect.bottom && rect.bottom < parentRect.height)) {\n\n            let top = element.offsetTop;\n\n            if (element.offsetParent) {\n                let offsetParent = element.offsetParent as HTMLElement;\n                while (offsetParent !== parent && !!offsetParent) {\n                    top += offsetParent.offsetTop;\n                    offsetParent = offsetParent.offsetParent as HTMLElement;\n                }\n            }\n\n            parent.scrollTo({top: top - 100});\n        }\n\n        return;\n    }\n\n    element.scrollIntoView();\n}\n\nexport function scrollToCaret(parent: HTMLElement) {\n\n    if (parent) {\n\n        const parentRect = parent.getBoundingClientRect();\n        const rect = caretTopPoint();\n\n        if (!(rect.top > parentRect.top && rect.top <= parentRect.bottom)) {\n\n            let top = rect.top - parentRect.top;\n            parent.scrollTo({top: top, behavior: \"auto\"});\n        }\n\n        return;\n    }\n\n}\n\nexport function caretTopPoint(): {left: number, top: number} {\n\n    const selection = document.getSelection();\n    const range0 = selection.getRangeAt(0);\n\n    let rect: {left: number, top: number};\n    let range: Range;\n\n    // supposed to be textNode in most cases\n    // but div[contenteditable] when empty\n    const node = range0.startContainer as Element;\n\n    const offset = range0.startOffset;\n    if (offset > 0) {\n\n        // new range, don't influence DOM state\n        range = document.createRange();\n        range.setStart(node, (offset - 1));\n        range.setEnd(node, offset);\n\n        // https://developer.mozilla.org/en-US/docs/Web/API/range.getBoundingClientRect\n        // IE9, Safari?(but look good in Safari 8)\n        rect = range.getBoundingClientRect();\n\n        return {left: rect[\"right\"], top: rect.top};\n\n    } else if (offset < node[\"length\"]) {\n\n        range = document.createRange();\n        // similar but select next on letter\n        range.setStart(node, offset);\n        range.setEnd(node, (offset + 1));\n        rect = range.getBoundingClientRect();\n\n        return {left: rect.left, top: rect.top};\n\n    } else {\n        // textNode has length\n\n        // https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect\n        rect = node.getBoundingClientRect();\n        const styles = getComputedStyle(node);\n        const lineHeight = parseInt(styles.lineHeight);\n        const fontSize = parseInt(styles.fontSize);\n\n        // roughly half the whitespace... but not exactly\n        const delta = (lineHeight - fontSize) / 2;\n\n        return {left: rect.left, top: (rect.top + delta)};\n    }\n\n}\n","import {AfterContentChecked, AfterViewInit, Component, ElementRef, EventEmitter, HostBinding, Input, OnChanges, OnDestroy, OnInit, Optional, Output, SimpleChanges} from \"@angular/core\";\nimport {ControlValueAccessor, NgControl} from \"@angular/forms\";\nimport {EventManager} from \"@angular/platform-browser\";\nimport {waitTill} from \"@co.mmons/js-utils/core\";\nimport {IonItem} from \"@ionic/angular\";\nimport {baseKeymap} from \"prosemirror-commands\";\nimport {gapCursor} from \"prosemirror-gapcursor\";\nimport {history} from \"prosemirror-history\";\nimport {keymap} from \"prosemirror-keymap\";\nimport {DOMParser, DOMSerializer, Schema} from \"prosemirror-model\";\nimport {EditorState, Plugin, Transaction} from \"prosemirror-state\";\nimport {EditorView} from \"prosemirror-view\";\nimport {HtmlEditorFeatures} from \"./editor-features\";\nimport {buildKeymap} from \"./prosemirror/keymap\";\nimport {schema} from \"./prosemirror/schema\";\nimport {createYoutubeIframe, YoutubeNodeView} from \"./prosemirror/views/youtube\";\nimport {findScrollParent, scrollIntoView, scrollToCaret} from \"./scroll\";\n\n@Component({\n    selector: \"ionx-html-editor\",\n    template: `\n        <ionx-html-editor-toolbar [style.display]=\"readonly ? 'none' : ''\"></ionx-html-editor-toolbar>\n    `,\n    styleUrls: [\"editor.scss\"]\n})\nexport class HtmlEditor implements OnInit, AfterViewInit, ControlValueAccessor, AfterContentChecked, OnDestroy, OnChanges {\n\n    private static idGenerator: number = 0;\n\n    constructor(\n        private element: ElementRef<HTMLElement>,\n        public eventManager: EventManager,\n        @Optional() private formControl: NgControl,\n        @Optional() private item: IonItem\n    ) {\n\n        if (formControl) {\n            this.formControl.valueAccessor = this;\n        }\n\n        this.id = \"ionx-trix-editor\" + (HtmlEditor.idGenerator++);\n        this.itemInputWrapper = !!this.item;\n\n        this.element.nativeElement.setAttribute(\"no-blur\", \"\");\n    }\n\n    private eventUnlisteners: Function[] = [];\n\n    readonly id: string;\n\n    @HostBinding(\"class.ionx-item-input-wrapper\")\n    /*private*/ itemInputWrapper: boolean;\n\n    @Input()\n    features: HtmlEditorFeatures;\n\n    @Input()\n    disabled: boolean;\n\n    @Input()\n    readonly: boolean;\n\n    /**\n     * Value, that should be set when editor is fully initialized.\n     */\n    private uninitializedValue: any;\n\n    private controlOnChange: Function;\n\n    private controlOnTouched: Function;\n\n    private focused: boolean;\n\n    private silentChanges: boolean;\n\n    view: EditorView;\n\n    get state() {\n        return this.view.state;\n    }\n\n    private schema: Schema;\n\n    private plugins: Plugin[];\n\n    private scrollParent: HTMLElement;\n\n    @Output()\n    readonly change: EventEmitter<any> = new EventEmitter();\n\n    @Output()\n    readonly selectionChange: EventEmitter<any> = new EventEmitter();\n\n    @Input()\n    public set value(html: string) {\n\n        if (this.view) {\n\n            const state = EditorState.create({\n                schema: this.view.state.schema,\n                plugins: this.view.state.plugins,\n                doc: this.editorDoc(html || \"<div></div>\")\n            });\n\n            this.view.updateState(state);\n\n        } else {\n            this.uninitializedValue = html;\n        }\n\n        this.silentChanges = false;\n    }\n\n    public get value(): string {\n        if (this.view) {\n            const value = DOMSerializer.fromSchema(this.schema).serializeFragment(this.state.doc.content);\n            const tmp = document.createElement(\"div\");\n            tmp.appendChild(value);\n\n            if (!tmp.innerText) {\n                return null;\n            } else {\n                return this.prepareOutputValue(tmp);\n            }\n\n        } else {\n            return this.uninitializedValue;\n        }\n    }\n\n    get nativeElement(): HTMLElement {\n        return this.element.nativeElement;\n    }\n\n    private prepareOutputValue(value: HTMLElement) {\n\n        value.querySelectorAll(\"div[data-youtube]\").forEach((node: HTMLElement) => {\n            const params = node.getAttribute(\"data-youtube\").split(\",\");\n            node.appendChild(createYoutubeIframe(params[0], params.length > 1 ? params[1] : undefined));\n        });\n\n        return value.innerHTML;\n    }\n\n    private prepareInputValue(value: HTMLElement) {\n\n    }\n\n    setDisabledState(isDisabled: boolean): void {\n        this.disabled = !!isDisabled;\n    }\n\n    writeValue(value: any) {\n        this.silentChanges = true;\n        this.value = value;\n    }\n\n    registerOnChange(fn: Function): void {\n        this.controlOnChange = fn;\n    }\n\n    registerOnTouched(fn: Function): void {\n        this.controlOnTouched = fn;\n    }\n\n    focus() {\n\n        if (!this.scrollParent) {\n            this.scrollParent = findScrollParent(this.element.nativeElement);\n        }\n\n        (this.view.dom as HTMLElement).focus({preventScroll: true});\n\n        const selectedView = (this.view.dom as HTMLElement).querySelector(\".ionx--selected\");\n\n        if (selectedView) {\n            scrollIntoView(selectedView as HTMLElement, this.scrollParent);\n        } else {\n            const pos = this.view.domAtPos(this.view.state.selection.to);\n            if (pos.node) {\n                if (pos.node.nodeType === Node.TEXT_NODE) {\n                    scrollToCaret(this.scrollParent);\n                } else {\n                    scrollIntoView(pos.node as HTMLElement, this.scrollParent);\n                }\n            }\n        }\n    }\n\n    // @ts-ignore\n    private async editorInitialized(event: Event) {\n\n        if (this.uninitializedValue) {\n            // this.trixEditor.loadHTML(this.uninitializedValue);\n        }\n\n        // this.trixEditorController.toolbarController.applyKeyboardCommand = this.applyKeyboardCommand.bind(this);\n    }\n\n    // @ts-ignore\n    private editorFocused(event: Event) {\n\n        if (this.controlOnTouched) {\n            this.controlOnTouched(true);\n        }\n\n        this.focused = true;\n        this.updateItemClasses();\n    }\n\n    // @ts-ignore\n    private editorBlured(event: Event) {\n        this.focused = false;\n        this.updateItemClasses();\n    }\n\n    private handleScroll(view: EditorView) {\n\n        if (!this.scrollParent) {\n            this.scrollParent = findScrollParent(this.element.nativeElement);\n        }\n\n        const pos = view.domAtPos(view.state.selection.to);\n        if (pos.node) {\n            if (pos.node.nodeType === Node.TEXT_NODE) {\n                scrollToCaret(this.scrollParent);\n            } else {\n                scrollIntoView(pos.node as HTMLElement, this.scrollParent);\n            }\n        }\n\n        return false;\n    }\n\n    private editorDoc(html: string) {\n\n        const node = document.createElement(\"div\");\n        node.innerHTML = html;\n        this.prepareInputValue(node);\n\n        return DOMParser.fromSchema(this.schema).parse(node);\n    }\n\n    private resetControlCss() {\n\n        const classes = {\n            \"ion-untouched\": this.formControl.untouched,\n            \"ion-touched\": this.formControl.touched,\n            \"ion-pristine\": this.formControl.pristine,\n            \"ion-dirty\": this.formControl.dirty,\n            \"ion-valid\": this.formControl.valid,\n            \"ion-invalid\": !this.formControl.valid\n        };\n\n        const elements: HTMLElement[] = [];\n        elements.push(this.element.nativeElement);\n\n        if (this.item) {\n            elements.push(this.item[\"el\"]);\n        }\n\n        for (const e of elements) {\n            for (const c in classes) {\n                if (classes[c]) {\n                    e.classList.add(c);\n                } else {\n                    e.classList.remove(c);\n                }\n            }\n        }\n    }\n\n    private updateItemClasses() {\n\n        if (!this.item) {\n            return;\n        }\n\n        const item: HTMLElement = this.item[\"el\"];\n\n        if (this.disabled) {\n            item.classList.remove(\"item-interactive\");\n        } else {\n            item.classList.add(\"item-interactive\");\n        }\n\n        if (this.focused) {\n            item.classList.add(\"item-has-focus\");\n        } else {\n            item.classList.remove(\"item-has-focus\");\n        }\n    }\n\n    private async fixItemOverflow() {\n\n        if (this.item) {\n            const item: HTMLElement = this.item[\"el\"];\n            await waitTill(() => !!item.shadowRoot && !!item.shadowRoot.querySelector(\".item-inner\"));\n\n            item.style.overflow = \"initial\";\n\n            const style = document.createElement(\"style\");\n            style.innerHTML = `.item-native, .item-inner, .input-wrapper { overflow: initial !important; }`;\n            item.shadowRoot.appendChild(style);\n        }\n\n    }\n\n    private editorTransaction(transaction: Transaction) {\n\n        this.focus();\n        this.view.updateState(this.view.state.apply(transaction));\n\n        this.selectionChange.next();\n\n        if (transaction.docChanged) {\n            this.change.next();\n\n            if (this.controlOnChange && !this.silentChanges) {\n                this.controlOnChange(this.value);\n            }\n        }\n\n        this.silentChanges = false;\n    }\n\n    private readonlyChanged() {\n\n        if (this.view) {\n            this.view.dom[\"contentEditable\"] = !this.readonly && !this.disabled ? \"true\" : \"false\";\n        }\n\n    }\n\n    ngAfterViewInit(): void {\n        this.fixItemOverflow();\n        this.updateItemClasses();\n    }\n\n    ngAfterContentChecked() {\n        this.resetControlCss();\n    }\n\n    ngOnDestroy() {\n\n        for (const unlisten of this.eventUnlisteners) {\n            unlisten();\n        }\n\n        this.view.destroy();\n        this.view = undefined;\n    }\n\n    ngOnInit() {\n\n        this.schema = schema;\n\n        this.plugins = [\n            keymap(buildKeymap(schema)),\n            keymap(baseKeymap),\n            gapCursor(),\n            history()\n        ];\n\n        const state = EditorState.create({\n            schema: this.schema,\n            plugins: this.plugins,\n            doc: this.editorDoc(this.uninitializedValue ? this.uninitializedValue : \"<div></div>\")\n        });\n\n        this.view = new EditorView(this.element.nativeElement, {\n            state: state,\n            dispatchTransaction: (transaction) => this.editorTransaction(transaction),\n            handleScrollToSelection: (view) => this.handleScroll(view),\n\n            nodeViews: {\n                youtube: (node, view) => new YoutubeNodeView(node, view, this.eventManager)\n            }\n        });\n\n        this.silentChanges = false;\n\n        if (this.readonly || this.disabled) {\n            this.readonlyChanged();\n        }\n    }\n\n    ngOnChanges(changes: SimpleChanges): void {\n\n        if (changes[\"readonly\"] || changes[\"disabled\"]) {\n            this.readonlyChanged();\n        }\n\n    }\n}\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {HtmlEditor} from \"./editor\";\nimport {schema} from \"./prosemirror/schema\";\nimport {setBlockType} from \"prosemirror-commands\";\nimport {findParentNodeOfType} from \"prosemirror-utils\";\n\n@Component({\n    styles: [\n        `:host ion-list { margin: 0px; padding: 0px }`,\n        `:host ion-item:last-child { --border-width: 0px; }`,\n    ],\n    template: `\n        <ion-list lines=\"full\">\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(0)\" *ngIf=\"activeHeading > 0\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#Plain text\" | intlMessage}}</ion-label>\n            </ion-item>\n            \n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(1)\">\n                <ion-label style=\"font-size: 130%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 1</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 1\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(2)\">\n                <ion-label style=\"font-size: 125%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 2</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 2\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(3)\">\n                <ion-label style=\"font-size: 120%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 3</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 3\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(4)\">\n                <ion-label style=\"font-size: 115%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 4</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 4\"></ion-icon>\n            </ion-item>\n            \n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(5)\">\n                <ion-label style=\"font-size: 110%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 5</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 5\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(6)\">\n                <ion-label style=\"font-size: 105%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 6</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 6\"></ion-icon>\n            </ion-item>\n            \n        </ion-list>\n    `\n})\nexport class HeadingMenu implements OnInit {\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    activeHeading: number;\n\n    @Input()\n    editor: HtmlEditor;\n\n\n    toggleHeading(heading: number) {\n\n        if (heading > 0 && this.activeHeading !== heading) {\n\n            const command = setBlockType(schema.nodes.heading, {level: heading});\n            if (command(this.editor.state)) {\n                command(this.editor.state, (tr) => {\n                    this.editor.view.dispatch(tr);\n                });\n            }\n\n        } else {\n            setBlockType(schema.nodes.paragraph)(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n\n        const active = findParentNodeOfType(schema.nodes.heading)(this.editor.state.selection);\n        if (active) {\n            this.activeHeading = active.node.attrs.level;\n        }\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {AbstractControl, ValidationErrors, ValidatorFn, Validators} from \"@angular/forms\";\nimport {MessageRef} from \"@co.mmons/js-intl\";\n\nexport abstract class LinkType {\n\n    protected constructor(public readonly type: string) {\n    }\n\n    abstract get label(): MessageRef;\n\n    abstract get inputType(): string;\n\n    abstract get inputComponent(): any;\n\n    abstract get inputValidators(): ValidatorFn[];\n\n    abstract get inputHint(): MessageRef;\n\n    abstract get inputLabel(): MessageRef;\n\n    abstract uri(fromLink: string): string;\n\n    toString() {\n        return this.type;\n    }\n}\n\nexport class DefaultLinkType extends LinkType {\n\n    static readonly www = new DefaultLinkType(\"www\");\n    static readonly email = new DefaultLinkType(\"email\");\n    static readonly tel = new DefaultLinkType(\"tel\");\n    static readonly sms = new DefaultLinkType(\"sms\");\n    static readonly other = new DefaultLinkType(\"other\");\n\n    constructor(type: string) {\n        super(type);\n\n        this.label = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/type/\" + type);\n\n        if (type === \"www\") {\n            this.inputType = \"url\";\n        } else if (type === \"other\") {\n            this.inputType = \"text\";\n        } else if (type === \"sms\") {\n            this.inputType = \"sms\";\n        } else {\n            this.inputType = type;\n        }\n\n        if (type === \"www\") {\n            this.inputValidators = [urlValidator];\n            this.inputLabel = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/Web page url\");\n        }\n\n        if (type === \"email\") {\n            this.inputValidators = [Validators.email];\n            this.inputLabel = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/E-mail address\");\n        }\n\n        if (type === \"tel\" || type === \"sms\") {\n            this.inputLabel = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/Phone number\");\n            this.inputHint = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/phoneNumberHint\");\n        }\n    }\n\n\n    readonly label: MessageRef;\n\n    readonly inputType: string;\n\n    readonly inputValidators: ValidatorFn[];\n\n    readonly inputComponent = undefined;\n\n    readonly inputLabel: MessageRef;\n\n    readonly inputHint: MessageRef;\n\n    uri(fromLink: string) {\n\n        if (this.type === \"www\" || this.type === \"other\") {\n            return fromLink;\n        } else if (this.type === \"tel\") {\n            return `tel:${fromLink}`;\n        } else if (this.type === \"sms\") {\n            return `sms:${fromLink}`;\n        } else if (this.type === \"email\") {\n            return `mailto:${fromLink}`;\n        }\n\n        return fromLink;\n    }\n\n}\n\nconst urlValidatorRegex = /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i;\n\nfunction urlValidator(control: AbstractControl): ValidationErrors {\n\n    const value = control.value;\n\n    if (urlValidatorRegex.test(value)) {\n        return undefined;\n    }\n\n    return {\n        invalidUrl: new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/invalidUrlError\")\n    };\n}\n","import {findMarks} from \"./find-marks\";\nimport {MarkType} from \"prosemirror-model\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport function findMarksInSelection(state: EditorState, markType: MarkType, attrs?: {[key: string]: any}) {\n    const doc = state.doc;\n    const {from, to} = state.selection;\n    return findMarks(doc, from, to, markType, attrs);\n}\n","import {deepEqual} from \"fast-equals\";\nimport {Mark, MarkType, Node} from \"prosemirror-model\";\n\nexport function findMarks(doc: Node, from: number, to: number, markType: MarkType, attrs?: {[key: string]: any}) {\n\n    const marks: Mark[] = [];\n\n    doc.nodesBetween(from, to, node => {\n\n        for (let i = 0; i < node.marks.length; i++) {\n            if (node.marks[i].type === markType && (!attrs || deepEqual(node.marks[i].attrs, attrs))) {\n                marks.push(node.marks[i]);\n            }\n        }\n\n    });\n\n    return marks;\n}\n","import {Node} from \"prosemirror-model\";\n\nexport function findNodeStartEnd(doc: Node, pos: number) {\n\n    const $pos = doc.resolve(pos);\n    const start = pos - $pos.textOffset;\n    const end = start + $pos.parent.child($pos.index()).nodeSize;\n\n    return {start, end};\n}\n","import {Component, Input, OnDestroy, OnInit, ViewChild} from \"@angular/core\";\nimport {AbstractControl, FormControl, FormGroup, ValidationErrors, Validators} from \"@angular/forms\";\nimport {FormHelper} from \"@co.mmons/ionic-extensions/form-helper\";\nimport {sleep, waitTill} from \"@co.mmons/js-utils/core\";\nimport {unsubscribe} from \"@co.mmons/rxjs-utils\";\nimport {ModalController} from \"@ionic/angular\";\nimport {toggleMark} from \"prosemirror-commands\";\nimport {Subscription} from \"rxjs\";\nimport {HtmlEditor} from \"./editor\";\nimport {DefaultLinkType, LinkType} from \"./link-type\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findMarksInSelection} from \"./prosemirror/utils/find-marks-in-selection\";\nimport {findNodeStartEnd} from \"./prosemirror/utils/find-node-start-end\";\n\n@Component({\n    templateUrl: \"link-modal.html\",\n    styles: [\n        `:host ion-item:not(.ion-dirty) { --highlight-height: 0px; }`\n    ]\n})\nexport class LinkModal implements OnDestroy, OnInit {\n\n    static async present(modalController: ModalController, editor: HtmlEditor) {\n\n        const modal = await modalController.create({component: LinkModal, componentProps: {editor: editor}});\n        modal.present();\n    }\n\n    constructor(private modalController: ModalController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    existing: boolean;\n\n    private existingType: LinkType;\n\n    private existingLink: string;\n\n    types: LinkType[];\n\n    form: FormGroup;\n\n    @ViewChild(FormHelper, {static: false})\n    formHelper: FormHelper;\n\n    async close() {\n        await this.modalController.dismiss();\n        this.editor.focus();\n    }\n\n    async unlink() {\n\n        await this.modalController.dismiss();\n\n        const selection = this.editor.state.selection;\n\n        if (selection.empty) {\n\n            const tr = this.editor.state.tr;\n\n            tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n                if (node.isText) {\n                    const $pos = tr.doc.resolve(pos);\n                    const start = pos - $pos.textOffset;\n                    const end = start + $pos.parent.child($pos.index()).nodeSize;\n\n                    tr.removeMark(start, end, schema.marks.link);\n                }\n            });\n\n            this.editor.view.dispatch(tr);\n\n        } else {\n            toggleMark(schema.marks.link)(this.editor.state, tr => this.editor.view.dispatch(tr));\n        }\n    }\n\n    async ok() {\n        this.formHelper.validateAll(\"dirty\");\n\n        if (this.form.valid) {\n            await this.modalController.dismiss();\n\n            const linkType = this.form.controls.type.value as LinkType;\n            const selection = this.editor.state.selection;\n\n            const tr = this.editor.state.tr;\n\n            if (selection.empty) {\n\n                tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n                    if (node.isText) {\n                        const {start, end} = findNodeStartEnd(tr.doc, pos);\n                        tr.addMark(start, end, schema.mark(schema.marks.link, {href: linkType.uri(this.form.controls.link.value)}));\n                    }\n                });\n\n            } else {\n\n                // usuwamy poprzedni link\n                tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n                    if (node.isText) {\n                        const {start, end} = findNodeStartEnd(tr.doc, pos);\n                        tr.removeMark(start, end, schema.marks.link);\n                    }\n                });\n\n                tr.addMark(selection.from, selection.to, schema.mark(schema.marks.link, {href: linkType.uri(this.form.controls.link.value)}));\n            }\n\n            this.editor.view.dispatch(tr);\n        }\n    }\n\n    private async typeChanged() {\n\n        if (this.form.controls.link.value) {\n            this.form.controls.link.markAsDirty();\n            this.form.controls.link.updateValueAndValidity();\n        }\n\n        await sleep(50); // we must wait for closing type selector\n\n        if (this.formHelper) {\n            this.formHelper.focus(\"link\", false);\n        }\n    }\n\n    private parseLink(uri: string): {type: LinkType, link: string} {\n\n        const prefixes = {\n            \"http:\": DefaultLinkType.www,\n            \"https:\": DefaultLinkType.www,\n            \"tel:\": DefaultLinkType.tel,\n            \"sms:\": DefaultLinkType.sms,\n            \"mailto:\": DefaultLinkType.email\n        };\n\n        const lowerCasedUri = uri.trim().toLowerCase();\n\n        for (const prefix of Object.keys(prefixes)) {\n            if (lowerCasedUri.startsWith(prefix)) {\n\n                const link = {type: prefixes[prefix], link: uri.trim()};\n\n                if (prefixes[prefix] !== DefaultLinkType.www) {\n                    link.link = uri.substring(prefix.length).trim();\n                }\n\n                return link;\n            }\n        }\n\n        return {type: DefaultLinkType.other, link: uri};\n    }\n\n    private linkValidator(control: AbstractControl): ValidationErrors {\n\n        const required = Validators.required(control);\n        if (required) {\n            return required;\n        }\n\n        const type = this.form.controls.type.value as LinkType;\n        const validators = type.inputValidators;\n\n        if (validators) {\n            for (const validator of validators) {\n                const r = validator(control);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n    }\n\n    async ionViewDidEnter() {\n\n        this.types = [DefaultLinkType.www, DefaultLinkType.email, DefaultLinkType.tel, DefaultLinkType.sms, DefaultLinkType.other];\n\n        this.form = new FormGroup({\n            type: new FormControl(this.existingType || DefaultLinkType.www),\n            link: new FormControl(this.existingLink)\n        });\n\n        this.form.controls.link.setValidators(control => this.linkValidator(control));\n\n        this.typeChangesSubscription = this.form.controls[\"type\"].valueChanges.subscribe(() => this.typeChanged());\n        this.typeChanged();\n\n        await waitTill(() => !!this.formHelper);\n\n        this.formHelper.focus(\"link\", false);\n    }\n\n    async ionViewWillLeave() {\n        this.editor.focus();\n    }\n\n    ngOnInit() {\n\n        MARKS: for (const mark of findMarksInSelection(this.editor.state, schema.marks.link)) {\n            const parsed = this.parseLink(mark.attrs.href);\n            if (parsed) {\n                this.existingType = parsed.type;\n                this.existingLink = parsed.link;\n                this.existing = true;\n                break MARKS;\n            }\n        }\n    }\n\n    private typeChangesSubscription: Subscription;\n\n    ngOnDestroy() {\n        unsubscribe(this.typeChangesSubscription);\n    }\n\n}\n","import {Component, Input, OnInit, ViewChild} from \"@angular/core\";\nimport {sleep, waitTill} from \"@co.mmons/js-utils/core\";\nimport {IonInput, ModalController, PopoverController} from \"@ionic/angular\";\nimport {OverlayEventDetail} from \"@ionic/core\";\nimport {HtmlEditor} from \"./editor\";\nimport {LinkModal} from \"./link-modal\";\n\n@Component({\n    styles: [\n        `:host ion-list { margin: 0px; padding: 0px }`,\n        `:host ion-item:last-child { --border-width: 0px; }`,\n        `:host ion-item { --highlight-height: 0px; }`\n    ],\n    template: `\n        <ion-list lines=\"full\">\n            \n            <ng-template [ngIf]=\"!inputView\">\n                \n                <ion-item button=\"true\" detail=\"false\" (click)=\"insertLink()\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#link/Link\" | intlMessage}}</ion-label>\n                    <ion-icon name=\"link\" slot=\"start\"></ion-icon>\n                </ion-item>\n    \n                <ion-item button=\"true\" detail=\"false\" (click)=\"insertYoutube()\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#youtube/YouTube video\" | intlMessage}}</ion-label>\n                    <ion-icon name=\"logo-youtube\" slot=\"start\"></ion-icon>\n                </ion-item>\n                \n            </ng-template>\n            \n            <ng-template [ngIf]=\"inputView == 'youtube'\">\n\n                <ion-item>\n                    <ion-icon name=\"logo-youtube\" slot=\"start\"></ion-icon>\n                    <ion-input #youtubeInput [placeholder]=\"'@co.mmons/ionic-extensions/html-editor#youtube/Paste YouTube video url' | intlMessage\" (keydown.enter)=\"applyYoutube()\"></ion-input>\n                </ion-item>\n                \n                <ion-item>\n                    <ionx-buttons slot=\"end\">\n                        <ion-button fill=\"clear\" color=\"dark\" (click)=\"cancel()\">\n                            <ion-label>{{\"@co.mmons/js-intl#Cancel\" | intlMessage}}</ion-label>\n                        </ion-button>\n                        \n                        <ion-button fill=\"clear\" color=\"primary\" (click)=\"applyYoutube()\">\n                            <ion-label>{{\"@co.mmons/js-intl#Ok\" | intlMessage}}</ion-label>\n                        </ion-button>\n                    </ionx-buttons>\n                </ion-item>\n    \n            </ng-template>\n            \n        </ion-list>\n    `\n})\nexport class InsertMenu implements OnInit {\n\n    // @ts-ignore\n    constructor(private popoverController: PopoverController, private modalController: ModalController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    inputView: \"youtube\";\n\n    // @ts-ignore\n    private editorLastSelection: [number, number];\n\n\n    async insertLink() {\n\n        this.popoverController.dismiss(undefined, \"link\");\n\n        LinkModal.present(this.modalController, this.editor);\n    }\n\n    @ViewChild(\"youtubeInput\", {static: false})\n    private youtubeInput: IonInput;\n\n    async insertYoutube() {\n\n        this.inputView = \"youtube\";\n\n        await waitTill(() => !!this.youtubeInput, undefined, 2000);\n        this.youtubeInput.setFocus();\n    }\n\n    // @ts-ignore\n    private parseYoutube(value: string): {id: string, start?: string} {\n        // https://www.youtube.com/watch?v=NqMgaHUNSQc\n        // https://youtu.be/NqMgaHUNSQc\n        // https://www.youtube.com/embed/NqMgaHUNSQc\n        // https://www.youtube-nocookie.com/embed/NqMgaHUNSQc\n        // https://youtu.be/NqMgaHUNSQc?t=17\n\n        value = value.replace(\"-nocookie.com/\", \".com/\");\n        value = value.replace(\"/embed/\", \"/\");\n        value = value.replace(\"youtu.be/\", \"youtube.com/\");\n        value = value.replace(\"watch?v=\", \"\");\n        value = value.replace(\"?\", \"&\");\n\n        const info = {id: undefined, start: undefined};\n\n        if (value.indexOf(\"youtube.com/\") > -1) {\n            value = value.split(\"youtube.com/\").splice(1, 1)[0];\n\n            for (const param of value.split(\"&\")) {\n                if (param.indexOf(\"=\") < 0) {\n                    info.id = param;\n                } else if (param.startsWith(\"t=\")) {\n                    info.start = param.substring(2);\n                } else if (param.startsWith(\"start=\")) {\n                    info.start = param.substring(6);\n                }\n            }\n\n        } else  {\n        }\n\n        if (info.id) {\n            return info;\n        }\n    }\n\n\n    applyYoutube() {\n\n\n        const info = this.parseYoutube(this.youtubeInput.value);\n        if (info) {\n            const tr = this.editor.state.tr.replaceSelectionWith(this.editor.state.schema.nodes.youtube.create({id: info.id, start: info.start || 0}));\n            this.editor.view.dispatch(tr);\n        }\n\n        this.popoverController.dismiss(undefined, \"youtube\");\n    }\n\n    cancel() {\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n    }\n\n    async ionViewWillLeave(event: OverlayEventDetail<any>) {\n\n        if (!this.inputView && !event.role) {\n            this.editor.focus();\n        }\n    }\n\n    async ionViewDidLeave(event: OverlayEventDetail<any>) {\n\n        if (this.inputView) {\n            await sleep(50);\n            this.editor.focus();\n\n        } else if (!event.role) {\n            this.editor.focus();\n        }\n    }\n}\n","import {Command} from \"../command\";\nimport {Predicate} from \"../predicate\";\n\nexport const filter = (predicates: Predicate[] | Predicate, cmd: Command): Command => {\n\n    return function(state, dispatch, view): boolean {\n        if (!Array.isArray(predicates)) {\n            predicates = [predicates];\n        }\n\n        if (predicates.some(pred => !pred(state, view))) {\n            return false;\n        }\n\n        return cmd(state, dispatch, view) || false;\n    };\n};\n","import {GapCursor} from \"prosemirror-gapcursor\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport const isEmptySelectionAtStart = (state: EditorState): boolean => {\n    const {empty, $from} = state.selection;\n    return (\n        empty &&\n        ($from.parentOffset === 0 || state.selection instanceof GapCursor)\n    );\n};\n\n","import {Fragment, NodeRange, Slice} from \"prosemirror-model\";\nimport {EditorState, Selection, TextSelection, Transaction,} from \"prosemirror-state\";\nimport {liftTarget, ReplaceAroundStep} from \"prosemirror-transform\";\n\nfunction liftListItem(\n    state: EditorState,\n    selection: Selection,\n    tr: Transaction,\n): Transaction {\n    const { $from, $to } = selection;\n    const nodeType = state.schema.nodes.listItem;\n    let range = $from.blockRange(\n        $to,\n        node =>\n            !!node.childCount &&\n            !!node.firstChild &&\n            node.firstChild.type === nodeType,\n    );\n    if (\n        !range ||\n        range.depth < 2 ||\n        $from.node(range.depth - 1).type !== nodeType\n    ) {\n        return tr;\n    }\n    const end = range.end;\n    const endOfList = $to.end(range.depth);\n    if (end < endOfList) {\n        tr.step(\n            new ReplaceAroundStep(\n                end - 1,\n                endOfList,\n                end,\n                endOfList,\n                new Slice(\n                    Fragment.from(nodeType.create(undefined, range.parent.copy())),\n                    1,\n                    0,\n                ),\n                1,\n                true,\n            ),\n        );\n\n        range = new NodeRange(\n            tr.doc.resolve($from.pos),\n            tr.doc.resolve(endOfList),\n            range.depth,\n        );\n    }\n    return tr.lift(range, liftTarget(range) as number).scrollIntoView();\n}\n\nexport function liftFollowingList(\n    state: EditorState,\n    from: number,\n    to: number,\n    rootListDepth: number,\n    tr: Transaction,\n): Transaction {\n    const { listItem } = state.schema.nodes;\n    let lifted = false;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!lifted && node.type === listItem && pos > from) {\n            lifted = true;\n            let listDepth = rootListDepth + 3;\n            while (listDepth > rootListDepth + 2) {\n                const start = tr.doc.resolve(tr.mapping.map(pos));\n                listDepth = start.depth;\n                const end = tr.doc.resolve(\n                    tr.mapping.map(pos + node.textContent.length),\n                );\n                const sel = new TextSelection(start, end);\n                tr = liftListItem(state, sel, tr);\n            }\n        }\n    });\n    return tr;\n}\n","import {ResolvedPos, Schema} from \"prosemirror-model\";\n\n// This will return (depth - 1) for root list parent of a list.\nexport const getListLiftTarget = (\n    schema: Schema,\n    resPos: ResolvedPos,\n): number => {\n    let target = resPos.depth;\n    const { bulletList, orderedList, listItem } = schema.nodes;\n    for (let i = resPos.depth; i > 0; i--) {\n        const node = resPos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            target = i;\n        }\n        if (\n            node.type !== bulletList &&\n            node.type !== orderedList &&\n            node.type !== listItem\n        ) {\n            break;\n        }\n    }\n    return target - 1;\n};\n","import { Node, Mark, MarkType } from \"prosemirror-model\";\nimport { SelectionRange, EditorState, Transaction } from \"prosemirror-state\";\n\nexport const isMarkAllowedInRange = (\n    doc: Node,\n    ranges: Array<SelectionRange>,\n    type: MarkType,\n): boolean => {\n    for (let i = 0; i < ranges.length; i++) {\n        const { $from, $to } = ranges[i];\n        let can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, node => {\n            if (can) {\n                return false;\n            }\n            can = node.inlineContent && node.type.allowsMarkType(type);\n            return;\n        });\n        if (can) {\n            return can;\n        }\n    }\n    return false;\n};\n\nexport const isMarkExcluded = (\n    type: MarkType,\n    marks?: Array<Mark> | null,\n): boolean => {\n    if (marks) {\n        return marks.some(mark => mark.type !== type && mark.type.excludes(type));\n    }\n    return false;\n};\n\nconst not = <T>(fn: ((args: T) => boolean)) => (arg: T) => !fn(arg);\n\nexport const removeBlockMarks = (\n    state: EditorState,\n    marks: Array<MarkType | undefined>,\n): Transaction | undefined => {\n    const { selection, schema } = state;\n    let { tr } = state;\n\n    // Marks might not exist in Schema\n    const marksToRemove = marks.filter(Boolean);\n    if (marksToRemove.length === 0) {\n        return undefined;\n    }\n\n    /** Saves an extra dispatch */\n    let blockMarksExists = false;\n\n    const hasMark = (mark: Mark) => marksToRemove.indexOf(mark.type) > -1;\n    /**\n     * When you need to toggle the selection\n     * when another type which does not allow alignment is applied\n     */\n    state.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n        if (node.type === schema.nodes.paragraph && node.marks.some(hasMark)) {\n            blockMarksExists = true;\n            const resolvedPos = state.doc.resolve(pos);\n            const withoutBlockMarks = node.marks.filter(not(hasMark));\n            tr = tr.setNodeMarkup(\n                resolvedPos.pos,\n                undefined,\n                node.attrs,\n                withoutBlockMarks,\n            );\n        }\n    });\n    return blockMarksExists ? tr : undefined;\n};\n\n/**\n * Removes marks from nodes in the current selection that are not supported\n */\nexport const sanitizeSelectionMarks = (\n    state: EditorState,\n): Transaction | undefined => {\n    let tr: Transaction | undefined;\n    const { $from, $to } = state.tr.selection;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n        node.marks.forEach(mark => {\n            if (!node.type.allowsMarkType(mark.type)) {\n                const filteredMarks = node.marks.filter(m => m.type !== mark.type);\n                const position = pos > 0 ? pos - 1 : 0;\n                tr = (tr || state.tr).setNodeMarkup(\n                    position,\n                    undefined,\n                    node.attrs,\n                    filteredMarks,\n                );\n            }\n        });\n    });\n    return tr;\n};\n","import { toggleMark } from \"prosemirror-commands\";\nimport {GapCursor} from \"prosemirror-gapcursor\";\nimport {\n    Fragment,\n    Mark as PMMark,\n    MarkType,\n    Node,\n    NodeType,\n    ResolvedPos,\n    Slice,\n    Schema,\n    NodeRange,\n    Mark,\n} from \"prosemirror-model\";\nimport { EditorView } from \"prosemirror-view\";\nimport {\n    EditorState,\n    NodeSelection,\n    Selection,\n    TextSelection,\n    Transaction,\n} from \"prosemirror-state\";\nimport { liftTarget, findWrapping } from \"prosemirror-transform\";\nimport { hasParentNodeOfType } from \"prosemirror-utils\";\nimport { isNodeEmpty } from \"./document-utils\";\n\nexport {\n    isEmptyParagraph,\n    hasVisibleContent,\n    isNodeEmpty,\n    isEmptyDocument,\n    getStepRange,\n    findFarthestParentNode,\n    isSelectionEndOfParagraph,\n    nodesBetweenChanged,\n} from \"./document-utils\";\n\n\nexport const ZeroWidthSpace = \"\\u200b\";\n\nfunction validateNode(_node: Node): boolean {\n    return false;\n}\n\nfunction isMarkTypeCompatibleWithMark(\n    markType: MarkType,\n    mark: PMMark,\n): boolean {\n    return !mark.type.excludes(markType) && !markType.excludes(mark.type);\n}\n\nfunction isMarkTypeAllowedInNode(\n    markType: MarkType,\n    state: EditorState,\n): boolean {\n    return toggleMark(markType)(state);\n}\n\nfunction closest(\n    node: HTMLElement | null | undefined,\n    s: string,\n): HTMLElement | null {\n    let el = node as HTMLElement;\n    if (!el) {\n        return null;\n    }\n    if (!document.documentElement || !document.documentElement.contains(el)) {\n        return null;\n    }\n    const matches = el.matches ? \"matches\" : \"msMatchesSelector\";\n\n    do {\n        // @ts-ignore\n        if (el[matches] && el[matches](s)) {\n            return el;\n        }\n        el = (el.parentElement || el.parentNode) as HTMLElement;\n    } while (el !== null && el.nodeType === 1);\n    return null;\n}\n\nexport const isImage = (fileType?: string): boolean => {\n    return (\n        !!fileType &&\n        (fileType.indexOf(\"image/\") > -1 || fileType.indexOf(\"video/\") > -1)\n    );\n};\n\nexport function canMoveUp(state: EditorState): boolean {\n    const { selection, doc } = state;\n\n    /**\n     * If there\"s a media element on the selection,\n     * add text blocks with arrow navigation.\n     * Also, the selection could be media | mediaGroup.\n     */\n    if (selection instanceof NodeSelection) {\n        if (selection.node.type.name === \"media\") {\n            /** Weird way of checking if the previous element is a paragraph */\n            const mediaAncestorNode = doc.nodeAt(selection.anchor - 3);\n            return !!(\n                mediaAncestorNode && mediaAncestorNode.type.name === \"paragraph\"\n            );\n        } else if (selection.node.type.name === \"mediaGroup\") {\n            const mediaGroupAncestorNode = selection.$anchor.nodeBefore;\n            return !!(\n                mediaGroupAncestorNode &&\n                mediaGroupAncestorNode.type.name === \"paragraph\"\n            );\n        }\n    }\n\n    if (selection instanceof TextSelection) {\n        if (!selection.empty) {\n            return true;\n        }\n    }\n\n    return !atTheBeginningOfDoc(state);\n}\n\nexport function canMoveDown(state: EditorState): boolean {\n    const { selection, doc } = state;\n\n    /**\n     * If there\"s a media element on the selection,\n     * add text blocks with arrow navigation.\n     * Also, the selection could be media | mediaGroup.\n     */\n    if (selection instanceof NodeSelection) {\n        if (selection.node.type.name === \"media\") {\n            const nodeAfter = doc.nodeAt(selection.$head.after());\n            return !!(nodeAfter && nodeAfter.type.name === \"paragraph\");\n        } else if (selection.node.type.name === \"mediaGroup\") {\n            return !(\n                selection.$head.parentOffset === selection.$anchor.parent.content.size\n            );\n        }\n    }\n    if (selection instanceof TextSelection) {\n        if (!selection.empty) {\n            return true;\n        }\n    }\n\n    return !atTheEndOfDoc(state);\n}\n\nexport function isSelectionInsideLastNodeInDocument(\n    selection: Selection,\n): boolean {\n    const docNode = selection.$anchor.node(0);\n    const rootNode = selection.$anchor.node(1);\n\n    return docNode.lastChild === rootNode;\n}\n\nexport function atTheEndOfDoc(state: EditorState): boolean {\n    const { selection, doc } = state;\n    return doc.nodeSize - selection.$to.pos - 2 === selection.$to.depth;\n}\n\nexport function atTheBeginningOfDoc(state: EditorState): boolean {\n    const { selection } = state;\n    return selection.$from.pos === selection.$from.depth;\n}\n\nexport function atTheEndOfBlock(state: EditorState): boolean {\n    const { selection } = state;\n    const { $to } = selection;\n    if (selection instanceof GapCursor) {\n        return false;\n    }\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n        return true;\n    }\n    return endPositionOfParent($to) === $to.pos + 1;\n}\n\nexport function atTheBeginningOfBlock(state: EditorState): boolean {\n    const { selection } = state;\n    const { $from } = selection;\n    if (selection instanceof GapCursor) {\n        return false;\n    }\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n        return true;\n    }\n    return startPositionOfParent($from) === $from.pos;\n}\n\nexport function startPositionOfParent(resolvedPos: ResolvedPos): number {\n    return resolvedPos.start(resolvedPos.depth);\n}\n\nexport function endPositionOfParent(resolvedPos: ResolvedPos): number {\n    return resolvedPos.end(resolvedPos.depth) + 1;\n}\n\nexport function getCursor(selection: Selection): ResolvedPos | undefined {\n    return (selection as TextSelection).$cursor || undefined;\n}\n\n/**\n * Check if a mark is allowed at the current selection / cursor based on a given state.\n * This method looks at both the currently active marks on the transaction, as well as\n * the node and marks at the current selection to determine if the given mark type is\n * allowed.\n */\nexport function isMarkTypeAllowedInCurrentSelection(\n    markType: MarkType,\n    state: EditorState,\n) {\n\n    if (!isMarkTypeAllowedInNode(markType, state)) {\n        return false;\n    }\n\n    const { empty, $cursor, ranges } = state.selection as TextSelection;\n    if (empty && !$cursor) {\n        return false;\n    }\n\n    const isCompatibleMarkType = (mark: PMMark) =>\n        isMarkTypeCompatibleWithMark(markType, mark);\n\n    // Handle any new marks in the current transaction\n    if (\n        state.tr.storedMarks &&\n        !state.tr.storedMarks.every(isCompatibleMarkType)\n    ) {\n        return false;\n    }\n\n    if ($cursor) {\n        return $cursor.marks().every(isCompatibleMarkType);\n    }\n\n    // Check every node in a selection - ensuring that it is compatible with the current mark type\n    return ranges.every(({ $from, $to }) => {\n        let allowedInActiveMarks =\n            $from.depth === 0 ? state.doc.marks.every(isCompatibleMarkType) : true;\n\n        state.doc.nodesBetween($from.pos, $to.pos, node => {\n            allowedInActiveMarks =\n                allowedInActiveMarks && node.marks.every(isCompatibleMarkType);\n        });\n\n        return allowedInActiveMarks;\n    });\n}\n\n/**\n * Step through block-nodes between $from and $to and returns false if a node is\n * found that isn\"t of the specified type\n */\nexport function isRangeOfType(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n    nodeType: NodeType,\n): boolean {\n    return (\n        getAncestorNodesBetween(doc, $from, $to).filter(\n            node => node.type !== nodeType,\n        ).length === 0\n    );\n}\n\nexport function createSliceWithContent(content: string, state: EditorState) {\n    return new Slice(Fragment.from(state.schema.text(content)), 0, 0);\n}\n\n/**\n * Determines if content inside a selection can be joined with the next block.\n * We need this check since the built-in method for \"joinDown\" will join a orderedList with bulletList.\n */\nexport function canJoinDown(\n    selection: Selection,\n    doc: any,\n    nodeType: NodeType,\n): boolean {\n    return checkNodeDown(selection, doc, node => node.type === nodeType);\n}\n\nexport function checkNodeDown(\n    selection: Selection,\n    doc: Node,\n    filter: (node: Node) => boolean,\n): boolean {\n    const res = doc.resolve(\n        selection.$to.after(findAncestorPosition(doc, selection.$to).depth),\n    );\n    return res.nodeAfter ? filter(res.nodeAfter) : false;\n}\n\nexport const setNodeSelection = (view: EditorView, pos: number) => {\n    const { state, dispatch } = view;\n\n    if (!isFinite(pos)) {\n        return;\n    }\n\n    const tr = state.tr.setSelection(NodeSelection.create(state.doc, pos));\n    dispatch(tr);\n};\n\nexport function setTextSelection(\n    view: EditorView,\n    anchor: number,\n    head?: number,\n) {\n    const { state } = view;\n    const tr = state.tr.setSelection(\n        TextSelection.create(state.doc, anchor, head),\n    );\n    view.dispatch(tr);\n}\n\n/**\n * Determines if content inside a selection can be joined with the previous block.\n * We need this check since the built-in method for \"joinUp\" will join a orderedList with bulletList.\n */\nexport function canJoinUp(\n    selection: Selection,\n    doc: any,\n    nodeType: NodeType,\n): boolean {\n    const res = doc.resolve(\n        selection.$from.before(findAncestorPosition(doc, selection.$from).depth),\n    );\n    return res.nodeBefore && res.nodeBefore.type === nodeType;\n}\n\n/**\n * Returns all top-level ancestor-nodes between $from and $to\n */\nexport function getAncestorNodesBetween(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n): Node[] {\n    const nodes = Array<Node>();\n    const maxDepth = findAncestorPosition(doc, $from).depth;\n    let current = doc.resolve($from.start(maxDepth));\n\n    while (current.pos <= $to.start($to.depth)) {\n        const depth = Math.min(current.depth, maxDepth);\n        const node = current.node(depth);\n\n        if (node) {\n            nodes.push(node);\n        }\n\n        if (depth === 0) {\n            break;\n        }\n\n        let next: ResolvedPos = doc.resolve(current.after(depth));\n        if (next.start(depth) >= doc.nodeSize - 2) {\n            break;\n        }\n\n        if (next.depth !== current.depth) {\n            next = doc.resolve(next.pos + 2);\n        }\n\n        if (next.depth) {\n            current = doc.resolve(next.start(next.depth));\n        } else {\n            current = doc.resolve(next.end(next.depth));\n        }\n    }\n\n    return nodes;\n}\n\n/**\n * Finds all \"selection-groups\" within a range. A selection group is based on ancestors.\n *\n * Example:\n * Given the following document and selection ({<} = start of selection and {>} = end)\n *  doc\n *    blockquote\n *      ul\n *        li\n *        li{<}\n *        li\n *     p\n *     p{>}\n *\n * The output will be two selection-groups. One within the ul and one with the two paragraphs.\n */\nexport function getGroupsInRange(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n    isNodeValid: (node: Node) => boolean = validateNode,\n): Array<{ $from: ResolvedPos; $to: ResolvedPos }> {\n    const groups = Array<{ $from: ResolvedPos; $to: ResolvedPos }>();\n    const commonAncestor = hasCommonAncestor(doc, $from, $to);\n    const fromAncestor = findAncestorPosition(doc, $from);\n\n    if (\n        commonAncestor ||\n        (fromAncestor.depth === 1 && isNodeValid($from.node(1)))\n    ) {\n        groups.push({ $from, $to });\n    } else {\n        let current = $from;\n\n        while (current.pos < $to.pos) {\n            let ancestorPos = findAncestorPosition(doc, current);\n            while (ancestorPos.depth > 1) {\n                ancestorPos = findAncestorPosition(doc, ancestorPos);\n            }\n\n            const endPos = doc.resolve(\n                Math.min(\n                    // should not be smaller then start position in case of an empty paragraph for example.\n                    Math.max(\n                        ancestorPos.start(ancestorPos.depth),\n                        ancestorPos.end(ancestorPos.depth) - 3,\n                    ),\n                    $to.pos,\n                ),\n            );\n\n            groups.push({\n                $from: current,\n                $to: endPos,\n            });\n\n            current = doc.resolve(Math.min(endPos.after(1) + 1, doc.nodeSize - 2));\n        }\n    }\n\n    return groups;\n}\n\n/**\n * Traverse the document until an \"ancestor\" is found. Any nestable block can be an ancestor.\n */\nexport function findAncestorPosition(doc: Node, pos: any): any {\n    const nestableBlocks = [\"blockquote\", \"bulletList\", \"orderedList\"];\n\n    if (pos.depth === 1) {\n        return pos;\n    }\n\n    let node: Node | undefined = pos.node(pos.depth);\n    let newPos = pos;\n    while (pos.depth >= 1) {\n        pos = doc.resolve(pos.before(pos.depth));\n        node = pos.node(pos.depth);\n\n        if (node && nestableBlocks.indexOf(node.type.name) !== -1) {\n            newPos = pos;\n        }\n    }\n\n    return newPos;\n}\n\n/**\n * Determine if two positions have a common ancestor.\n */\nexport function hasCommonAncestor(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n): boolean {\n    let current;\n    let target;\n\n    if ($from.depth > $to.depth) {\n        current = findAncestorPosition(doc, $from);\n        target = findAncestorPosition(doc, $to);\n    } else {\n        current = findAncestorPosition(doc, $to);\n        target = findAncestorPosition(doc, $from);\n    }\n\n    while (current.depth > target.depth && current.depth > 1) {\n        current = findAncestorPosition(doc, current);\n    }\n\n    return current.node(current.depth) === target.node(target.depth);\n}\n\n/**\n * Takes a selection $from and $to and lift all text nodes from their parents to document-level\n */\nexport function liftSelection(\n    tr: Transaction,\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n) {\n    let startPos = $from.start($from.depth);\n    let endPos = $to.end($to.depth);\n    const target = Math.max(0, findAncestorPosition(doc, $from).depth - 1);\n\n    tr.doc.nodesBetween(startPos, endPos, (node, pos) => {\n        if (\n            node.isText || // Text node\n            (node.isTextblock && !node.textContent) // Empty paragraph\n        ) {\n            const res = tr.doc.resolve(tr.mapping.map(pos));\n            const sel = new NodeSelection(res);\n            const range = sel.$from.blockRange(sel.$to);\n\n            if (liftTarget(range as NodeRange) !== undefined) {\n                tr.lift(range, target);\n            }\n        }\n    });\n\n    startPos = tr.mapping.map(startPos);\n    endPos = tr.mapping.map(endPos);\n    endPos = tr.doc.resolve(endPos).end(tr.doc.resolve(endPos).depth); // We want to select the entire node\n\n    tr.setSelection(\n        new TextSelection(tr.doc.resolve(startPos), tr.doc.resolve(endPos)),\n    );\n\n    return {\n        tr: tr,\n        $from: tr.doc.resolve(startPos),\n        $to: tr.doc.resolve(endPos),\n    };\n}\n\n/**\n * Lift nodes in block to one level above.\n */\nexport function liftSiblingNodes(view: EditorView) {\n    const { tr } = view.state;\n    const { $from, $to } = view.state.selection;\n    const blockStart = tr.doc.resolve($from.start($from.depth - 1));\n    const blockEnd = tr.doc.resolve($to.end($to.depth - 1));\n    const range = blockStart.blockRange(blockEnd);\n    view.dispatch(tr.lift(range as NodeRange, blockStart.depth - 1));\n}\n\n/**\n * Lift sibling nodes to document-level and select them.\n */\nexport function liftAndSelectSiblingNodes(view: EditorView): Transaction {\n    const { tr } = view.state;\n    const { $from, $to } = view.state.selection;\n    const blockStart = tr.doc.resolve($from.start($from.depth - 1));\n    const blockEnd = tr.doc.resolve($to.end($to.depth - 1));\n    // TODO: [ts30] handle void and null properly\n    const range = blockStart.blockRange(blockEnd) as NodeRange;\n    tr.setSelection(new TextSelection(blockStart, blockEnd));\n    tr.lift(range as NodeRange, blockStart.depth - 1);\n    return tr;\n}\n\nexport function wrapIn(\n    nodeType: NodeType,\n    tr: Transaction,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n): Transaction {\n    const range = $from.blockRange($to) as any;\n    const wrapping = range && (findWrapping(range, nodeType) as any);\n    if (wrapping) {\n        tr = tr.wrap(range, wrapping).scrollIntoView();\n    }\n    return tr;\n}\n\n/**\n * Repeating string for multiple times\n */\nexport function stringRepeat(text: string, length: number): string {\n    let result = \"\";\n    for (let x = 0; x < length; x++) {\n        result += text;\n    }\n    return result;\n}\n\n/**\n * A replacement for `Array.from` until it becomes widely implemented.\n */\nexport function arrayFrom(obj: any): any[] {\n    return Array.prototype.slice.call(obj);\n}\n\n/**\n * Replacement for Element.closest, until it becomes widely implemented\n * Returns the ancestor element of a particular type if exists or null\n */\nexport function closestElement(\n    node: HTMLElement | null | undefined,\n    s: string,\n): HTMLElement | null {\n    return closest(node, s);\n}\n\n/*\n * From Modernizr\n * Returns the kind of transitionevent available for the element\n */\nexport function whichTransitionEvent<TransitionEventName extends string>() {\n    const el = document.createElement(\"fakeelement\");\n    const transitions: Record<string, string> = {\n        transition: \"transitionend\",\n        MozTransition: \"transitionend\",\n        OTransition: \"oTransitionEnd\",\n        WebkitTransition: \"webkitTransitionEnd\",\n    };\n\n    for (const t in transitions) {\n        if (el.style[t as keyof CSSStyleDeclaration] !== undefined) {\n            // Use a generic as the return type because TypeScript doesnt know\n            // about cross browser features, so we cast here to align to the\n            // standard Event spec and propagate the type properly to the callbacks\n            // of `addEventListener` and `removeEventListener`.\n            return transitions[t] as TransitionEventName;\n        }\n    }\n\n    return;\n}\n\n/**\n * Function will create a list of wrapper blocks present in a selection.\n */\nfunction getSelectedWrapperNodes(state: EditorState): NodeType[] {\n    const nodes: Array<NodeType> = [];\n    if (state.selection) {\n        const { $from, $to } = state.selection;\n        const {\n            blockquote,\n            panel,\n            orderedList,\n            bulletList,\n            listItem,\n            codeBlock,\n        } = state.schema.nodes;\n        state.doc.nodesBetween($from.pos, $to.pos, node => {\n            if (\n                (node.isBlock &&\n                    [blockquote, panel, orderedList, bulletList, listItem].indexOf(\n                        node.type,\n                    ) >= 0) ||\n                node.type === codeBlock\n            ) {\n                nodes.push(node.type);\n            }\n        });\n    }\n    return nodes;\n}\n\n/**\n * Function will check if changing block types: Paragraph, Heading is enabled.\n */\nexport function areBlockTypesDisabled(state: EditorState): boolean {\n    const nodesTypes: NodeType[] = getSelectedWrapperNodes(state);\n    const { panel } = state.schema.nodes;\n    return nodesTypes.filter(type => type !== panel).length > 0;\n}\n\nexport const isTemporary = (id: string): boolean => {\n    return id.indexOf(\"temporary:\") === 0;\n};\n\n\nexport const isEmptyNode = (schema: Schema) => {\n    const {\n        doc,\n        paragraph,\n        codeBlock,\n        blockquote,\n        panel,\n        heading,\n        listItem,\n        bulletList,\n        orderedList,\n        taskList,\n        taskItem,\n        decisionList,\n        decisionItem,\n        media,\n        mediaGroup,\n        mediaSingle,\n    } = schema.nodes;\n    const innerIsEmptyNode = (node: Node): boolean => {\n        switch (node.type) {\n            case media:\n            case mediaGroup:\n            case mediaSingle:\n                return false;\n            case paragraph:\n            case codeBlock:\n            case heading:\n            case taskItem:\n            case decisionItem:\n                return node.content.size === 0;\n            case blockquote:\n            case panel:\n            case listItem:\n                return (\n                    node.content.size === 2 && innerIsEmptyNode(node.content.firstChild)\n                );\n            case bulletList:\n            case orderedList:\n                return (\n                    node.content.size === 4 && innerIsEmptyNode(node.content.firstChild)\n                );\n            case taskList:\n            case decisionList:\n                return (\n                    node.content.size === 2 && innerIsEmptyNode(node.content.firstChild)\n                );\n            case doc:\n                let isEmpty = true;\n                node.content.forEach(child => {\n                    isEmpty = isEmpty && innerIsEmptyNode(child);\n                });\n                return isEmpty;\n            default:\n                return isNodeEmpty(node);\n        }\n    };\n    return innerIsEmptyNode;\n};\n\nexport const insideTable = (state: EditorState): Boolean => {\n    const { table, tableCell } = state.schema.nodes;\n\n    return hasParentNodeOfType([table, tableCell])(state.selection);\n};\n\nexport const insideTableCell = (state: EditorState) => {\n    const { tableCell, tableHeader } = state.schema.nodes;\n    return hasParentNodeOfType([tableCell, tableHeader])(state.selection);\n};\n\nexport const isElementInTableCell = (\n    element: HTMLElement | null,\n): HTMLElement | null => {\n    return closest(element, \"td\") || closest(element, \"th\");\n};\n\nexport const isLastItemMediaGroup = (node: Node): boolean => {\n    const { content } = node;\n    return !!content.lastChild && content.lastChild.type.name === \"mediaGroup\";\n};\n\nexport const isInListItem = (state: EditorState): boolean => {\n    return hasParentNodeOfType(state.schema.nodes.listItem)(state.selection);\n};\n\nexport const hasOpenEnd = (slice: Slice): boolean => {\n    return slice.openStart > 0 || slice.openEnd > 0;\n};\n\nexport function filterChildrenBetween(\n    doc: Node,\n    from: number,\n    to: number,\n    predicate: (node: Node, pos: number, parent: Node) => boolean | undefined,\n) {\n    const results = [] as { node: Node; pos: number }[];\n    doc.nodesBetween(from, to, (node, pos, parent) => {\n        if (predicate(node, pos, parent)) {\n            results.push({ node, pos });\n        }\n    });\n    return results;\n}\n\nexport function dedupe<T>(\n    list: T[] = [],\n    iteratee?: (p: T) => T[keyof T] | T,\n): T[] {\n    const transformed = iteratee ? list.map(iteratee) : list;\n\n    return transformed\n        .map((item, index, list) => (list.indexOf(item) === index ? item : null))\n        .reduce<T[]>(\n            (acc, item, index) => (!!item ? acc.concat(list[index]) : acc),\n            [],\n        );\n}\n\nexport const isTextSelection = (\n    selection: Selection,\n): selection is TextSelection => selection instanceof TextSelection;\n\n/** Helper type for single arg function */\ntype Func<A, B> = (a: A) => B;\ntype FuncN<A extends any[], B> = (...args: A) => B;\n\n/**\n * Compose 1 to n functions.\n * @param func first function\n * @param funcs additional functions\n */\nexport function compose<\n    F1 extends Func<any, any>,\n    FN extends Array<Func<any, any>>,\n    R extends FN extends []\n        ? F1\n        : FN extends [Func<infer A, any>]\n            ? (a: A) => ReturnType<F1>\n            : FN extends [any, Func<infer A, any>]\n                ? (a: A) => ReturnType<F1>\n                : FN extends [any, any, Func<infer A, any>]\n                    ? (a: A) => ReturnType<F1>\n                    : FN extends [any, any, any, Func<infer A, any>]\n                        ? (a: A) => ReturnType<F1>\n                        : FN extends [any, any, any, any, Func<infer A, any>]\n                            ? (a: A) => ReturnType<F1>\n                            : Func<any, ReturnType<F1>> // Doubtful we\"d ever want to pipe this many functions, but in the off chance someone does, we can still infer the return type\n    >(func: F1, ...funcs: FN): R {\n    const allFuncs = [func, ...funcs];\n    return function composed(raw: any) {\n        return allFuncs.reduceRight((memo, func) => func(memo), raw);\n    } as R;\n}\n\nexport function pipe(): <R>(a: R) => R;\n\nexport function pipe<F extends Function>(f: F): F;\n\n// one function\nexport function pipe<F1 extends FuncN<any, any>>(\n    f1: F1,\n): (...args: Parameters<F1>) => ReturnType<F1>;\n\n// two function\nexport function pipe<\n    F1 extends FuncN<any, any>,\n    F2 extends Func<ReturnType<F1>, any>\n    >(f1: F1, f2: F2): (...args: Parameters<F1>) => ReturnType<F2>;\n\n// three function\nexport function pipe<\n    F1 extends FuncN<any, any>,\n    F2 extends Func<ReturnType<F1>, any>,\n    F3 extends Func<ReturnType<F2>, any>\n    >(f1: F1, f2: F2, f3: F3): (...args: Parameters<F1>) => ReturnType<F3>;\n// If needed add more than 3 function\n// Generic\nexport function pipe<\n    F1 extends FuncN<any, any>,\n    F2 extends Func<ReturnType<F1>, any>,\n    F3 extends Func<ReturnType<F2>, any>,\n    FN extends Array<Func<any, any>>\n    >(f1: F1, f2: F2, f3: F3, ...fn: FN): (...args: Parameters<F1>) => any;\n\n// rest\nexport function pipe(...fns: Function[]) {\n    if (fns.length === 0) {\n        return (a: any) => a;\n    }\n\n    if (fns.length === 1) {\n        return fns[0];\n    }\n\n    return fns.reduce((prevFn, nextFn) => (...args: any[]) =>\n        nextFn(prevFn(...args)),\n    );\n}\n\nexport const normaliseNestedLayout = (state: EditorState, node: Node) => {\n    if (state.selection.$from.depth > 1) {\n        if (node.attrs.layout && node.attrs.layout !== \"default\") {\n            return node.type.createChecked(\n                {\n                    ...node.attrs,\n                    layout: \"default\",\n                },\n                node.content,\n                node.marks,\n            );\n        }\n\n        // If its a breakout layout, we can remove the mark\n        // Since default isn\"t a valid breakout mode.\n        const breakoutMark: Mark = state.schema.marks.breakout;\n        if (breakoutMark && breakoutMark.isInSet(node.marks)) {\n            const newMarks = breakoutMark.removeFromSet(node.marks);\n            return node.type.createChecked(node.attrs, node.content, newMarks);\n        }\n    }\n\n    return node;\n};\n","// https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js#L90\n// Keep going left up the tree, without going across isolating boundaries, until we\n// can go along the tree at that same level\n//\n// You can think of this as, if you could construct each document like we do in the tests,\n// return the position of the first ) backwards from the current selection.\nimport {ResolvedPos} from \"prosemirror-model\";\n\nexport function findCutBefore($pos: ResolvedPos): ResolvedPos | null {\n\n    // parent is non-isolating, so we can look across this boundary\n    if (!$pos.parent.type.spec.isolating) {\n        // search up the tree from the pos\"s *parent*\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            // starting from the inner most node\"s parent, find out\n            // if we\"re not its first child\n            if ($pos.index(i) > 0) {\n                return $pos.doc.resolve($pos.before(i + 1));\n            }\n\n            if ($pos.node(i).type.spec.isolating) {\n                break;\n            }\n        }\n    }\n\n    return null;\n}\n","import * as baseCommand from \"prosemirror-commands\";\nimport {GapCursor} from \"prosemirror-gapcursor\";\nimport {Fragment, Node, NodeRange, NodeType, ResolvedPos, Slice} from \"prosemirror-model\";\nimport * as baseListCommand from \"prosemirror-schema-list\";\nimport {EditorState, NodeSelection, TextSelection, Transaction} from \"prosemirror-state\";\nimport {liftTarget, ReplaceAroundStep} from \"prosemirror-transform\";\nimport {findPositionOfNodeBefore, hasParentNodeOfType} from \"prosemirror-utils\";\nimport {EditorView} from \"prosemirror-view\";\nimport {Command} from \"./command\";\nimport {filter} from \"./commands/filter\";\nimport {isEmptySelectionAtStart} from \"./commands/is-empty-selection-at-start\";\nimport {isFirstChildOfParent} from \"./commands/is-first-child-of-parent\";\nimport {hasVisibleContent, isNodeEmpty} from \"./document-utils\";\nimport {liftFollowingList} from \"./list/transforms/lift-following-list\";\nimport {liftSelectionList} from \"./list/transforms/lift-selection-list\";\nimport {sanitizeSelectionMarks} from \"./mark-utils\";\nimport {compose, isRangeOfType} from \"./utils\";\nimport {findCutBefore} from \"./utils/find-cut-before\";\n\nconst maxIndentation = 5;\n\nconst deletePreviousEmptyListItem: Command = (state, dispatch) => {\n    const { $from } = state.selection;\n    const { listItem } = state.schema.nodes;\n\n    const $cut = findCutBefore($from);\n    if (!$cut || !$cut.nodeBefore || !($cut.nodeBefore.type === listItem)) {\n        return false;\n    }\n\n    const previousListItemEmpty = $cut.nodeBefore.childCount === 1 && $cut.nodeBefore.firstChild && $cut.nodeBefore.firstChild.nodeSize <= 2;\n\n    if (previousListItemEmpty) {\n        const { tr } = state;\n\n        if (dispatch) {\n            dispatch(\n                tr\n                    .delete($cut.pos - $cut.nodeBefore.nodeSize, $from.pos)\n                    .scrollIntoView(),\n            );\n        }\n        return true;\n    }\n\n    return false;\n};\n\nconst joinToPreviousListItem: Command = (state, dispatch) => {\n    const { $from } = state.selection;\n    const {\n        paragraph,\n        listItem,\n        codeBlock,\n        bulletList,\n        orderedList,\n    } = state.schema.nodes;\n    const isGapCursorShown = state.selection instanceof GapCursor;\n    const $cutPos = isGapCursorShown ? state.doc.resolve($from.pos + 1) : $from;\n    const $cut = findCutBefore($cutPos);\n    if (!$cut) {\n        return false;\n    }\n\n    // see if the containing node is a list\n    if (\n        $cut.nodeBefore &&\n        [bulletList, orderedList].indexOf($cut.nodeBefore.type) > -1\n    ) {\n        // and the node after this is a paragraph or a codeBlock\n        if (\n            $cut.nodeAfter &&\n            ($cut.nodeAfter.type === paragraph || $cut.nodeAfter.type === codeBlock)\n        ) {\n            // find the nearest paragraph that precedes this node\n            let $lastNode = $cut.doc.resolve($cut.pos - 1);\n\n            while ($lastNode.parent.type !== paragraph) {\n                $lastNode = state.doc.resolve($lastNode.pos - 1);\n            }\n\n            let { tr } = state;\n            if (isGapCursorShown) {\n                const nodeBeforePos = findPositionOfNodeBefore(tr.selection);\n                if (typeof nodeBeforePos !== \"number\") {\n                    return false;\n                }\n                // append the codeblock to the list node\n                const list = $cut.nodeBefore.copy(\n                    $cut.nodeBefore.content.append(\n                        Fragment.from(listItem.createChecked({}, $cut.nodeAfter)),\n                    ),\n                );\n                tr.replaceWith(\n                    nodeBeforePos,\n                    $from.pos + $cut.nodeAfter.nodeSize,\n                    list,\n                );\n            } else {\n                // take the text content of the paragraph and insert after the paragraph up until before the the cut\n                tr = state.tr.step(\n                    new ReplaceAroundStep(\n                        $lastNode.pos,\n                        $cut.pos + $cut.nodeAfter.nodeSize,\n                        $cut.pos + 1,\n                        $cut.pos + $cut.nodeAfter.nodeSize - 1,\n                        state.tr.doc.slice($lastNode.pos, $cut.pos),\n                        0,\n                        true,\n                    ),\n                );\n            }\n\n            // find out if there\"s now another list following and join them\n            // as in, [list, p, list] => [list with p, list], and we want [joined list]\n            const $postCut = tr.doc.resolve(\n                tr.mapping.map($cut.pos + $cut.nodeAfter.nodeSize),\n            );\n            if (\n                $postCut.nodeBefore &&\n                $postCut.nodeAfter &&\n                $postCut.nodeBefore.type === $postCut.nodeAfter.type &&\n                [bulletList, orderedList].indexOf($postCut.nodeBefore.type) > -1\n            ) {\n                tr = tr.join($postCut.pos);\n            }\n\n            if (dispatch) {\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n\n    return false;\n};\n\nconst isInsideListItem = (state: EditorState): boolean => {\n    const { $from } = state.selection;\n    const { listItem, paragraph } = state.schema.nodes;\n\n    if (state.selection instanceof GapCursor) {\n        return $from.parent.type === listItem;\n    }\n\n    return (\n        hasParentNodeOfType(listItem)(state.selection) &&\n        $from.parent.type === paragraph\n    );\n};\n\nconst canToJoinToPreviousListItem = (state: EditorState): boolean => {\n    const { $from } = state.selection;\n    const { bulletList, orderedList } = state.schema.nodes;\n\n    const $before = state.doc.resolve($from.pos - 1);\n    let nodeBefore = $before ? $before.nodeBefore : null;\n\n    if (state.selection instanceof GapCursor) {\n        nodeBefore = $from.nodeBefore;\n    }\n\n    return (\n        !!nodeBefore && [bulletList, orderedList].indexOf(nodeBefore.type) > -1\n    );\n};\n\nconst canOutdent = (state: EditorState): boolean => {\n    const { parent } = state.selection.$from;\n    const { listItem, paragraph } = state.schema.nodes;\n\n    if (state.selection instanceof GapCursor) {\n        return parent.type === listItem;\n    }\n\n    return (\n        parent.type === paragraph && hasParentNodeOfType(listItem)(state.selection)\n    );\n};\n\nexport const enterKeyCommand: Command = (state, dispatch): boolean => {\n    const { selection } = state;\n    if (selection.empty) {\n        const { $from } = selection;\n        const { listItem, codeBlock } = state.schema.nodes;\n        const node = $from.node($from.depth);\n        const wrapper = $from.node($from.depth - 1);\n\n        if (wrapper && wrapper.type === listItem) {\n            /** Check if the wrapper has any visible content */\n            const wrapperHasContent = hasVisibleContent(wrapper);\n            if (isNodeEmpty(node) && !wrapperHasContent) {\n                return outdentList()(state, dispatch);\n            } else if (!hasParentNodeOfType(codeBlock)(selection)) {\n                return splitListItem(listItem)(state, dispatch);\n            }\n        }\n    }\n    return false;\n};\n\nexport const backspaceKeyCommand = baseCommand.chainCommands(\n    // if we\"re at the start of a list item, we need to either backspace\n    // directly to an empty list item above, or outdent this node\n    filter(\n        [\n            isEmptySelectionAtStart,\n\n            // list items might have multiple paragraphs; only do this at the first one\n            isFirstChildOfParent,\n            canOutdent,\n        ],\n        baseCommand.chainCommands(deletePreviousEmptyListItem, outdentList()),\n    ),\n\n    // if we\"re just inside a paragraph node (or gapcursor is shown) and backspace, then try to join\n    // the text to the previous list item, if one exists\n    filter(\n        [isEmptySelectionAtStart, canToJoinToPreviousListItem],\n        joinToPreviousListItem,\n    ),\n);\n\n/**\n * Implemetation taken and modified for our needs from PM\n * @param itemType Node\n * Splits the list items, specific implementation take from PM\n */\nfunction splitListItem(itemType: NodeType): Command {\n    return function(state, dispatch) {\n        const ref = state.selection as NodeSelection;\n        const $from = ref.$from;\n        const $to = ref.$to;\n        const node = ref.node;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        const grandParent = $from.node(-1);\n        if (grandParent.type !== itemType) {\n            return false;\n        }\n        /** --> The following line changed from the original PM implementation to allow list additions with multiple paragraphs */\n        if (\n            (grandParent.content as any).content.length <= 1 &&\n            $from.parent.content.size === 0 &&\n            !(grandParent.content.size === 0)\n        ) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if (\n                $from.depth === 2 ||\n                $from.node(-3).type !== itemType ||\n                $from.index(-2) !== $from.node(-2).childCount - 1\n            ) {\n                return false;\n            }\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                const keepItem = $from.index(-1) > 0;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (\n                    let d = $from.depth - (keepItem ? 1 : 2);\n                    d >= $from.depth - 3;\n                    d--\n                ) {\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                }\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                const tr$1 = state.tr.replace(\n                    $from.before(keepItem ? undefined : -1),\n                    $from.after(-3),\n                    new Slice(wrap, keepItem ? 3 : 2, 2),\n                );\n                tr$1.setSelection(\n                    (state.selection.constructor as any).near(\n                        tr$1.doc.resolve($from.pos + (keepItem ? 3 : 2)),\n                    ),\n                );\n                dispatch(tr$1.scrollIntoView());\n            }\n            return true;\n        }\n        const nextType =\n            $to.pos === $from.end()\n                ? grandParent.contentMatchAt(0).defaultType\n                : undefined;\n        const tr = state.tr.delete($from.pos, $to.pos);\n        const types = nextType && [undefined, { type: nextType }];\n\n        if (dispatch) {\n            dispatch(tr.split($from.pos, 2, types as any).scrollIntoView());\n        }\n        return true;\n    };\n}\n\n/**\n * Merge closest bullet list blocks into one\n */\nfunction mergeLists(listItem: NodeType, range: NodeRange) {\n    return (command: Command): Command => {\n        return (state, dispatch) =>\n            command(state, tr => {\n                /* we now need to handle the case that we lifted a sublist out,\n                 * and any listItems at the current level get shifted out to\n                 * their own new list; e.g.:\n                 *\n                 * unorderedList\n                 *  listItem(A)\n                 *  listItem\n                 *    unorderedList\n                 *      listItem(B)\n                 *  listItem(C)\n                 *\n                 * becomes, after unindenting the first, top level listItem, A:\n                 *\n                 * content of A\n                 * unorderedList\n                 *  listItem(B)\n                 * unorderedList\n                 *  listItem(C)\n                 *\n                 * so, we try to merge these two lists if they\"re of the same type, to give:\n                 *\n                 * content of A\n                 * unorderedList\n                 *  listItem(B)\n                 *  listItem(C)\n                 */\n\n                const $start: ResolvedPos = state.doc.resolve(range.start);\n                const $end: ResolvedPos = state.doc.resolve(range.end);\n                const $join = tr.doc.resolve(tr.mapping.map(range.end - 1));\n\n                if (\n                    $join.nodeBefore &&\n                    $join.nodeAfter &&\n                    $join.nodeBefore.type === $join.nodeAfter.type\n                ) {\n                    if (\n                        $end.nodeAfter &&\n                        $end.nodeAfter.type === listItem &&\n                        $end.parent.type === $start.parent.type\n                    ) {\n                        tr.join($join.pos);\n                    }\n                }\n\n                if (dispatch) {\n                    dispatch(tr.scrollIntoView());\n                }\n            });\n    };\n}\n\nexport function outdentList(): Command {\n    return function(state, dispatch) {\n        const { listItem } = state.schema.nodes;\n        const { $from, $to } = state.selection;\n        if (isInsideListItem(state)) {\n            // if we\"re backspacing at the start of a list item, unindent it\n            // take the the range of nodes we might be lifting\n\n            // the predicate is for when you\"re backspacing a top level list item:\n            // we don\"t want to go up past the doc node, otherwise the range\n            // to clear will include everything\n            const range = $from.blockRange(\n                $to,\n                node => node.childCount > 0 && node.firstChild && node.firstChild.type === listItem,\n            );\n\n            if (!range) {\n                return false;\n            }\n            return compose(\n                mergeLists(listItem, range), // 2. Check if I need to merge nearest list\n                baseListCommand.liftListItem, // 1. First lift list item\n            )(listItem)(state, dispatch);\n        }\n\n        return false;\n    };\n}\n\n/**\n * Check if we can sink the list.\n *\n * @returns true if we can sink the list, false if we reach the max indentation level\n */\nfunction canSink(initialIndentationLevel: number, state: EditorState): boolean {\n    /*\n        - Keep going forward in document until indentation of the node is < than the initial\n        - If indentation is EVER > max indentation, return true and don\"t sink the list\n        */\n    let currentIndentationLevel: number;\n    let currentPos = state.tr.selection.$to.pos;\n    do {\n        const resolvedPos = state.doc.resolve(currentPos);\n        currentIndentationLevel = numberNestedLists(\n            resolvedPos,\n            state.schema.nodes,\n        );\n        if (currentIndentationLevel > maxIndentation) {\n            // Cancel sink list.\n            // If current indentation less than the initial, it won\"t be\n            // larger than the max, and the loop will terminate at end of this iteration\n            return false;\n        }\n        currentPos++;\n    } while (currentIndentationLevel >= initialIndentationLevel);\n\n    return true;\n}\n\nexport function indentList(): Command {\n    return function(state, dispatch) {\n        const { listItem } = state.schema.nodes;\n        if (isInsideListItem(state)) {\n            // Record initial list indentation\n            const initialIndentationLevel = numberNestedLists(\n                state.selection.$from,\n                state.schema.nodes,\n            );\n\n            if (canSink(initialIndentationLevel, state)) {\n                compose(\n                    baseListCommand.sinkListItem,\n                )(listItem)(state, dispatch);\n            }\n            return true;\n        }\n        return false;\n    };\n}\n\nexport function liftListItems(): Command {\n    return function(state, dispatch) {\n        const { tr } = state;\n        const { $from, $to } = state.selection;\n\n        tr.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            // Following condition will ensure that block types paragraph, heading, codeBlock, blockquote, panel are lifted.\n            // isTextblock is true for paragraph, heading, codeBlock.\n            if (\n                node.isTextblock ||\n                node.type.name === \"blockquote\" ||\n                node.type.name === \"panel\"\n            ) {\n                const sel = new NodeSelection(tr.doc.resolve(tr.mapping.map(pos)));\n                const range = sel.$from.blockRange(sel.$to);\n\n                if (!range || sel.$from.parent.type !== state.schema.nodes.listItem) {\n                    return false;\n                }\n\n                const target = range && liftTarget(range);\n\n                if (target === undefined || target === null) {\n                    return false;\n                }\n\n                tr.lift(range, target);\n            }\n            return;\n        });\n\n        if (dispatch) {\n            dispatch(tr);\n        }\n\n        return true;\n    };\n}\n\n/**\n * Sometimes a selection in the editor can be slightly offset, for example:\n * it\"s possible for a selection to start or end at an empty node at the very end of\n * a line. This isn\"t obvious by looking at the editor and it\"s likely not what the\n * user intended - so we need to adjust the selection a bit in scenarios like that.\n */\nexport function adjustSelectionInList(\n    doc: Node,\n    selection: TextSelection,\n): TextSelection {\n    const { $from, $to } = selection;\n\n    const isSameLine = $from.pos === $to.pos;\n\n    let startPos = $from.pos;\n    const endPos = $to.pos;\n\n    if (isSameLine && startPos === doc.nodeSize - 3) {\n        // Line is empty, don\"t do anything\n        return selection;\n    }\n\n    // Selection started at the very beginning of a line and therefor points to the previous line.\n    if ($from.nodeBefore && !isSameLine) {\n        startPos++;\n        let node = doc.nodeAt(startPos);\n        while (!node || (node && !node.isText)) {\n            startPos++;\n            node = doc.nodeAt(startPos);\n        }\n    }\n\n    if (endPos === startPos) {\n        return new TextSelection(doc.resolve(startPos));\n    }\n\n    return new TextSelection(doc.resolve(startPos), doc.resolve(endPos));\n}\n\n// Get the depth of the nearest ancestor list\nexport const rootListDepth = (\n    pos: ResolvedPos,\n    nodes: Record<string, NodeType>,\n) => {\n    const { bulletList, orderedList, listItem } = nodes;\n    let depth;\n    for (let i = pos.depth - 1; i > 0; i--) {\n        const node = pos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            depth = i;\n        }\n        if (\n            node.type !== bulletList &&\n            node.type !== orderedList &&\n            node.type !== listItem\n        ) {\n            break;\n        }\n    }\n    return depth;\n};\n\n// Returns the number of nested lists that are ancestors of the given selection\nexport const numberNestedLists = (\n    resolvedPos: ResolvedPos,\n    nodes: Record<string, NodeType>,\n) => {\n    const { bulletList, orderedList } = nodes;\n    let count = 0;\n    for (let i = resolvedPos.depth - 1; i > 0; i--) {\n        const node = resolvedPos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            count += 1;\n        }\n    }\n    return count;\n};\n\nexport const toggleList = (\n    state: EditorState,\n    dispatch: (tr: Transaction) => void,\n    view: EditorView,\n    listType: \"bulletList\" | \"orderedList\",\n): boolean => {\n    const { selection } = state;\n    const fromNode = selection.$from.node(selection.$from.depth - 2);\n    const endNode = selection.$to.node(selection.$to.depth - 2);\n    if (\n        !fromNode ||\n        fromNode.type.name !== listType ||\n        (!endNode || endNode.type.name !== listType)\n    ) {\n        return toggleListCommand(listType)(state, dispatch, view);\n    } else {\n        const depth = rootListDepth(selection.$to, state.schema.nodes);\n        let tr = liftFollowingList(\n            state,\n            selection.$to.pos,\n            selection.$to.end(depth),\n            depth || 0,\n            state.tr,\n        );\n        tr = liftSelectionList(state, tr);\n        dispatch(tr);\n        return true;\n    }\n};\n\n/**\n * Check of is selection is inside a list of the specified type\n */\nexport function isInsideList(\n    state: EditorState,\n    listType: \"bulletList\" | \"orderedList\",\n) {\n    const { $from } = state.selection;\n    const parent = $from.node(-2);\n    const grandgrandParent = $from.node(-3);\n\n    return (\n        (parent && parent.type === state.schema.nodes[listType]) ||\n        (grandgrandParent && grandgrandParent.type === state.schema.nodes[listType])\n    );\n}\n\nexport function toggleListCommand(\n    listType: \"bulletList\" | \"orderedList\",\n): Command {\n    return function(state, dispatch, view) {\n        if (dispatch) {\n            dispatch(\n                state.tr.setSelection(\n                    adjustSelectionInList(state.doc, state.selection as TextSelection),\n                ),\n            );\n        }\n\n        if (!view) {\n            return false;\n        }\n\n        state = view.state;\n\n        const { $from, $to } = state.selection;\n        const isRangeOfSingleType = isRangeOfType(\n            state.doc,\n            $from,\n            $to,\n            state.schema.nodes[listType],\n        );\n\n        if (isInsideList(state, listType) && isRangeOfSingleType) {\n            // Untoggles list\n            return liftListItems()(state, dispatch);\n        } else {\n            // Converts list type e.g. bullet_list -> ordered_list if needed\n            if (!isRangeOfSingleType) {\n                liftListItems()(state, dispatch);\n                state = view.state;\n            }\n\n            // Remove any invalid marks that are not supported\n            const tr = sanitizeSelectionMarks(state);\n            if (tr) {\n                if (dispatch) {\n                    dispatch(tr);\n                }\n                state = view.state;\n            }\n            // Wraps selection in list\n            return wrapInList(state.schema.nodes[listType])(state, dispatch);\n        }\n    };\n}\n\nexport function toggleBulletList(view: EditorView) {\n    return toggleList(view.state, view.dispatch, view, \"bulletList\");\n}\n\nexport function toggleOrderedList(view: EditorView) {\n    return toggleList(view.state, view.dispatch, view, \"orderedList\");\n}\n\nexport function wrapInList(nodeType: NodeType): Command {\n    return baseCommand.autoJoin(\n        baseListCommand.wrapInList(nodeType),\n        (before, after) => before.type === after.type && before.type === nodeType,\n    );\n}\n","import {GapCursor} from \"prosemirror-gapcursor\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport const isFirstChildOfParent = (state: EditorState): boolean => {\n    const {$from} = state.selection;\n    return $from.depth > 1\n        ? (state.selection instanceof GapCursor &&\n        $from.parentOffset === 0) ||\n        $from.index($from.depth - 1) === 0\n        : true;\n};\n","import {EditorState, Transaction} from \"prosemirror-state\";\nimport {getListLiftTarget} from \"../utils/get-list-lift-target\";\n\n// The function will list paragraphs in selection out to level 1 below root list.\nexport function liftSelectionList(\n    state: EditorState,\n    tr: Transaction,\n): Transaction {\n    const {from, to} = state.selection;\n    const {paragraph} = state.schema.nodes;\n    const listCol: any[] = [];\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.type === paragraph) {\n            listCol.push({node, pos});\n        }\n    });\n    for (let i = listCol.length - 1; i >= 0; i--) {\n        const paragraph = listCol[i];\n        const start = tr.doc.resolve(tr.mapping.map(paragraph.pos));\n        if (start.depth > 0) {\n            let end;\n            if (paragraph.node.textContent && paragraph.node.textContent.length > 0) {\n                end = tr.doc.resolve(\n                    tr.mapping.map(paragraph.pos + paragraph.node.textContent.length),\n                );\n            } else {\n                end = tr.doc.resolve(tr.mapping.map(paragraph.pos + 1));\n            }\n            const range = start.blockRange(end);\n            if (range) {\n                tr.lift(range, getListLiftTarget(state.schema, start));\n            }\n        }\n    }\n    return tr;\n}\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {HtmlEditor} from \"./editor\";\nimport {Command} from \"./prosemirror/command\";\nimport {indentList, outdentList, toggleList} from \"./prosemirror/list-commands\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findParentNode} from \"prosemirror-utils\";\n\n@Component({\n    styles: [`\n        :host { user-select: none; }\n        :host ion-list { margin: 0px; padding: 0px; }\n        :host ion-item:last-child { --border-width: 0px; }\n        :host ion-item-divider { --background: transparent; font-size: small }\n        :host ion-item-divider ion-label { margin-top: 20px; opacity: 0.8; }\n    `],\n    template: `\n        <ion-list lines=\"full\">\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleList('bulletList')\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Bulleted list\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeUnnumberedList\"></ion-icon>\n                <ion-icon src=\"assets/html-editor/list-bulleted.svg\" slot=\"start\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleList('orderedList')\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Numbered list\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeNumberedList\"></ion-icon>\n                <ion-icon src=\"assets/html-editor/list-numbered.svg\" slot=\"start\"></ion-icon>\n            </ion-item>\n\n            <ng-template [ngIf]=\"activeUnnumberedList || activeNumberedList\">\n\n                <ion-item-divider>\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Indent\" | intlMessage}}</ion-label>\n                </ion-item-divider>\n\n                <ion-item button=\"true\" detail=\"false\" (click)=\"level(-1)\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Decrease indent\" | intlMessage}}</ion-label>\n                    <ion-icon src=\"assets/html-editor/indent-decrease.svg\" slot=\"start\"></ion-icon>\n                </ion-item>\n\n                <ion-item button=\"true\" detail=\"false\" (click)=\"level(1)\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Increase indent\" | intlMessage}}</ion-label>\n                    <ion-icon src=\"assets/html-editor/indent-increase.svg\" slot=\"start\"></ion-icon>\n                </ion-item>\n\n            </ng-template>\n\n        </ion-list>\n    `\n})\nexport class ListMenu implements OnInit {\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    activeUnnumberedList: boolean;\n    activeNumberedList: boolean;\n\n    level(level: number) {\n\n        const command: Command = level < 0 ? outdentList() : indentList();\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    toggleList(type: \"bulletList\" | \"orderedList\") {\n        toggleList(this.editor.state, (tr) => this.editor.view.dispatch(tr), this.editor.view, type);\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n        this.activeUnnumberedList = !!findParentNode(predicate => predicate.hasMarkup(schema.nodes.bulletList))(this.editor.state.selection);\n        this.activeNumberedList = !!findParentNode(predicate => predicate.hasMarkup(schema.nodes.orderedList))(this.editor.state.selection);\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {MessageRef} from \"@co.mmons/js-intl\";\n\nexport class FontSize {\n\n    private static _sizes: FontSize[] = [];\n\n    static sizes() {\n        return FontSize._sizes.slice();\n    }\n\n    static readonly small = new FontSize(\"small\");\n    static readonly large = new FontSize(\"large\");\n\n    private constructor(public readonly size: string) {\n\n        FontSize._sizes.push(this);\n\n        this.label = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"textMenu/fontSize/\" + size.toUpperCase()[0] + size.substring(1));\n    }\n\n    readonly label: MessageRef;\n}\n","import {shallowEqual} from \"fast-equals\";\nimport {MarkType, Node} from \"prosemirror-model\";\nimport {Command} from \"../command\";\n\nfunction markApplies(doc: Node, from: number, to: number, type: MarkType) {\n\n    let applies = false;\n\n    doc.nodesBetween(from, to, (node, pos, parent) => {\n\n        if (applies) {\n            return false;\n        }\n\n        applies = node.isInline && parent.type.allowsMarkType(type);\n    });\n\n    return applies;\n}\n\n// return true iff all nodes in range have the mark with the same attrs\nfunction rangeHasMark(doc, from, to, type, attrs) {\n\n    let hasMark = null;\n\n    doc.nodesBetween(from, to, node => {\n\n        for (let i = 0; i < node.marks.length; i++) {\n            const markMatch = node.marks[i].type === type && (!attrs || shallowEqual(node.marks[i].attrs, attrs));\n            hasMark = (markMatch && (hasMark === null || hasMark === true));\n        }\n\n        return hasMark;\n    });\n\n    return !!hasMark;\n}\n\nexport function toggleInlineMark(markType: MarkType, attrs?: {[key: string]: any}): Command {\n\n    return function(state, dispatch) {\n\n        const { empty, from, to, $from } = state.selection;\n\n        if (!markApplies(state.doc, from, to, markType)) {\n            console.log(\"not applies\");\n            return false;\n        }\n\n        if (dispatch) {\n\n            if (empty) {\n\n                const markInSet = markType.isInSet(state.storedMarks || $from.marks());\n\n                if (markInSet && (!attrs || shallowEqual(markInSet.attrs, attrs))) {\n                    dispatch(state.tr.removeStoredMark(markType));\n                } else {\n                    dispatch(state.tr.addStoredMark(markType.create(attrs)));\n                }\n\n            } else {\n\n                if (rangeHasMark(state.doc, from, to, markType, attrs)) {\n                    dispatch(state.tr.removeMark(from, to, markType).scrollIntoView());\n                } else {\n                    dispatch(state.tr.addMark(from, to, markType.create(attrs)).scrollIntoView());\n                }\n            }\n        }\n\n        return true;\n    };\n}\n\n","import {Mark, MarkType, NodeType} from \"prosemirror-model\";\nimport {EditorState, NodeSelection} from \"prosemirror-state\";\n\nexport function isActive(state: EditorState, nodeType: NodeType, attrs?: {[key: string]: any}, marks?: Array<Mark<any>>) {\n\n    const selection = state.selection;\n\n    if (selection instanceof NodeSelection && selection.node) {\n        return selection.node.hasMarkup(nodeType, attrs, marks);\n    }\n\n    return selection.to <= selection.$from.end() && selection.$from.parent.hasMarkup(nodeType, attrs, marks);\n}\n\nexport function isMarkActive(state: EditorState, type: MarkType) {\n    const {from, $from, to, empty} = state.selection;\n\n    if (empty) {\n        return !!(type.isInSet(state.storedMarks || $from.marks()));\n    } else {\n        return state.doc.rangeHasMark(from, to, type);\n    }\n}\n\nexport function anyMarkActive(state: EditorState, types: MarkType[]) {\n\n    const {from, $from, to, empty} = state.selection;\n\n    if (empty) {\n\n        for (const type of types) {\n            if (type.isInSet(state.storedMarks || $from.marks())) {\n                return true;\n            }\n        }\n\n    } else {\n\n        for (const type of types) {\n            if (state.doc.rangeHasMark(from, to, type)) {\n                return true;\n            }\n        }\n\n    }\n\n    return false;\n}\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {toggleMark} from \"prosemirror-commands\";\nimport {HtmlEditor} from \"./editor\";\nimport {FontSize} from \"./font-sizes\";\nimport {Command} from \"./prosemirror/command\";\nimport {toggleInlineMark} from \"./prosemirror/commands/toogle-inline-mark\";\nimport {isMarkActive} from \"./prosemirror/is-active\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findMarksInSelection} from \"./prosemirror/utils/find-marks-in-selection\";\n\n@Component({\n    styles: [`\n        :host { user-select: none; }\n        :host ion-list { margin: 0px; padding: 0px; }\n        :host ion-item:last-child { --border-width: 0px; }\n        :host ion-item-divider { --background: transparent; font-size: small }\n        :host ion-item-divider ion-label { margin-top: 20px; opacity: 0.8; }\n    `],\n    template: `\n        <ion-list lines=\"full\">\n            \n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggle('bold')\">\n                <ion-label style=\"font-weight: bold\">{{\"@co.mmons/ionic-extensions/html-editor#textMenu/Bold\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"boldActivated\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggle('italic')\">\n                <ion-label style=\"font-style: italic\">{{\"@co.mmons/ionic-extensions/html-editor#textMenu/Italic\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"italicActivated\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggle('underline')\">\n                <ion-label style=\"text-decoration: underline\">{{\"@co.mmons/ionic-extensions/html-editor#textMenu/Underline\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"underlineActivated\"></ion-icon>\n            </ion-item>\n            \n            <ion-item-divider>\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#textMenu/fontSize/Text size\" | intlMessage}}</ion-label>\n            </ion-item-divider>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"resetFontSize()\" *ngIf=\"activeFontSize\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#textMenu/fontSize/Default\" | intlMessage}}</ion-label>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleFontSize(fontSize)\" *ngFor=\"let fontSize of FontSize.sizes()\">\n                <ion-label [style.fontSize]=\"fontSize.size\">{{fontSize.label | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeFontSize === fontSize\"></ion-icon>\n            </ion-item>\n\n        </ion-list>\n    `\n})\nexport class TextFormatMenu implements OnInit {\n\n    readonly FontSize = FontSize;\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    @Input()\n    editor: HtmlEditor;\n\n    boldActivated: boolean;\n\n    italicActivated: boolean;\n\n    underlineActivated: boolean;\n\n    activeFontSize: FontSize;\n\n\n    toggle(name: string) {\n\n        let command: Command;\n\n        if (name === \"bold\") {\n            command = toggleMark(schema.marks.strong);\n        } else if (name === \"italic\") {\n            command = toggleMark(schema.marks.em);\n        } else if (name === \"underline\") {\n            command = toggleMark(schema.marks.underline);\n        }\n\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    resetFontSize() {\n        toggleMark(schema.marks.fontSize)(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        this.popoverController.dismiss();\n    }\n\n    toggleFontSize(size: FontSize) {\n\n        const command = toggleInlineMark(schema.marks.fontSize, {fontSize: size.size});\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n        this.boldActivated = isMarkActive(this.editor.state, schema.marks.strong);\n        this.italicActivated = isMarkActive(this.editor.state, schema.marks.em);\n        this.underlineActivated = isMarkActive(this.editor.state, schema.marks.underline);\n\n        this.activeFontSize = undefined;\n        MARKS: for (const mark of findMarksInSelection(this.editor.state, schema.marks.fontSize)) {\n\n            for (const size of FontSize.sizes()) {\n                if (size.size === mark.attrs.fontSize) {\n\n                    // ups, mamy rÃ³Å¼ne rozmiary w zaznaczeniu\n                    if (this.activeFontSize && size !== this.activeFontSize) {\n                        this.activeFontSize = undefined;\n                        break MARKS;\n                    }\n\n                    this.activeFontSize = size;\n                }\n            }\n        }\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {Component, OnDestroy, OnInit} from \"@angular/core\";\nimport {EventManager} from \"@angular/platform-browser\";\nimport {unsubscribe} from \"@co.mmons/rxjs-utils\";\nimport {ModalController, Platform, PopoverController} from \"@ionic/angular\";\nimport {redo, redoDepth, undo, undoDepth} from \"prosemirror-history\";\nimport {findParentNode, findParentNodeOfType} from \"prosemirror-utils\";\nimport {Subscription} from \"rxjs\";\nimport {AlignmentMenu} from \"./alignment-menu\";\nimport {HtmlEditor} from \"./editor\";\nimport {HeadingMenu} from \"./heading-menu\";\nimport {InsertMenu} from \"./insert-menu\";\nimport {LinkModal} from \"./link-modal\";\nimport {ListMenu} from \"./list-menu\";\nimport {anyMarkActive, isMarkActive} from \"./prosemirror/is-active\";\nimport {schema} from \"./prosemirror/schema\";\nimport {isBlockMarkActive} from \"./prosemirror/utils/selection/is-block-mark-active\";\nimport {TextFormatMenu} from \"./text-format-menu\";\n\n@Component({\n    selector: \"ionx-html-editor-toolbar\",\n    template: `\n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.text\" (click)=\"showMenu($event, 'text')\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Text\" | intlMessage}}</span>\n        </ion-button>\n\n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.alignment\" (click)=\"showMenu($event, 'alignment')\" *ngIf=\"!editor.features || editor.features.alignment\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Alignment\" | intlMessage}}</span>\n        </ion-button>\n\n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.heading\" (click)=\"showMenu($event, 'heading')\" *ngIf=\"!editor.features || editor.features.heading\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}}</span>\n        </ion-button>\n        \n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.list\" (click)=\"showMenu($event, 'list')\" *ngIf=\"!editor.features || editor.features.list\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/List\" | intlMessage}}</span>\n        </ion-button>\n\n        <ion-button size=\"small\" fill=\"clear\" (click)=\"showMenu($event, 'insert')\" *ngIf=\"!editor.features || editor.features.link || editor.features.multimedia\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Insert\" | intlMessage}}</span>\n        </ion-button>\n        \n        <ion-button size=\"small\" fill=\"clear\" class=\"active-feature\" (click)=\"editLink()\" *ngIf=\"activeFeatures.link\">\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#link/Link\" | intlMessage}}</span>\n        </ion-button>\n        \n        <div ionx--buttons-group>\n            <ion-button size=\"small\" fill=\"clear\" tabindex=\"-1\" title=\"{{'@co.mmons/ionic-extensions/html-editor#Undo' | intlMessage}}\" [disabled]=\"!canUndo\" (click)=\"undo()\">\n                <ion-icon name=\"undo\" slot=\"icon-only\"></ion-icon>\n            </ion-button>\n    \n            <ion-button size=\"small\" fill=\"clear\" title=\"{{'@co.mmons/ionic-extensions/html-editor#Redo' | intlMessage}}\" [disabled]=\"!canRedo\" (click)=\"redo()\">\n                <ion-icon name=\"redo\" slot=\"icon-only\"></ion-icon>\n            </ion-button>\n        </div>\n    `,\n    styles: [`\n        :host { outline: none; display: flex; justify-content: center; flex-wrap: wrap; position: sticky; position: -webkit-sticky; top: 0px; background-color: var(--background); z-index: 1; }\n        :host-context(.ion-focused) { background-color: var(--background-focused); }\n        :host ion-button { margin: 0px 4px; --padding-end: 2px; --padding-start: 4px; }\n        :host ion-button.active-feature span { font-weight: 800; }\n        :host ion-icon[slot=\"end\"] { margin: 0px; }\n        :host ion-button[disabled] { opacity: 0.5; }\n        :host [ionx--buttons-group] { display: flex; }\n        :host [ionx--buttons-group] ion-button:not(:last-child) { margin-right: 0px; }\n    `]\n})\nexport class Toolbar implements OnInit, OnDestroy {\n\n    constructor(\n        private popoverController: PopoverController,\n        private platform: Platform,\n        public readonly editor: HtmlEditor,\n        protected eventManager: EventManager,\n        private modalController: ModalController\n    ) {\n\n    }\n\n    async showMenu(event: Event, menu: string) {\n\n        const components = {\n            text: TextFormatMenu,\n            list: ListMenu,\n            alignment: AlignmentMenu,\n            insert: InsertMenu,\n            heading: HeadingMenu\n        };\n\n        const popover = await this.popoverController.create({\n            component: components[menu],\n            componentProps: {\n                editor: this.editor\n            },\n            event: event,\n            showBackdrop: this.platform.is(\"ios\")\n        });\n\n        popover.present();\n    }\n\n    activeFeatures: {\n        link?: boolean,\n        text?: boolean,\n        alignment?: boolean,\n        heading?: boolean;\n        list?: boolean\n    } = {};\n\n    async editLink() {\n        LinkModal.present(this.modalController, this.editor);\n    }\n\n    canUndo: boolean;\n\n    canRedo: boolean;\n\n    undo() {\n        undo(this.editor.view.state, (transaction) => this.editor.view.updateState(this.editor.view.state.apply(transaction)));\n        this.editor.focus();\n    }\n\n    redo() {\n        redo(this.editor.view.state, (transaction) => this.editor.view.updateState(this.editor.view.state.apply(transaction)));\n        this.editor.focus();\n\n    }\n\n    private editorSelectionChanged() {\n\n        this.canUndo = undoDepth(this.editor.view.state) > 0;\n        this.canRedo = redoDepth(this.editor.view.state) > 0;\n\n        this.activeFeatures = {};\n\n        this.activeFeatures.text = anyMarkActive(this.editor.view.state, [schema.marks.strong, schema.marks.em, schema.marks.underline, schema.marks.fontSize]);\n        this.activeFeatures.list = !!findParentNode(predicate => predicate.hasMarkup(schema.nodes.orderedList) || predicate.hasMarkup(schema.nodes.bulletList))(this.editor.state.selection);\n        this.activeFeatures.alignment = isBlockMarkActive(this.editor.view.state, schema.marks.alignment);\n        this.activeFeatures.heading = !!findParentNodeOfType(schema.nodes.heading)(this.editor.state.selection);\n        this.activeFeatures.link = isMarkActive(this.editor.view.state, schema.marks.link);\n    }\n\n    private selectionSubscription: Subscription;\n\n    async ngOnInit() {\n\n        this.selectionSubscription = this.editor.selectionChange.subscribe(() => this.editorSelectionChanged());\n\n        this.editorSelectionChanged();\n    }\n\n    ngOnDestroy() {\n        unsubscribe(this.selectionSubscription);\n    }\n\n}\n","import {MarkType} from \"prosemirror-model\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport function isBlockMarkActive(state: EditorState, type: MarkType) {\n    const {from, $from, to, empty} = state.selection;\n\n    if (empty) {\n\n        for (const mark of $from.parent.marks) {\n            if (mark.type === type) {\n                return true;\n            }\n        }\n    } else {\n        return state.doc.rangeHasMark(from, to, type);\n    }\n}\n","import {CommonModule} from \"@angular/common\";\nimport {NgModule} from \"@angular/core\";\nimport {FormsModule, ReactiveFormsModule} from \"@angular/forms\";\nimport {MatchMediaModule} from \"@co.mmons/angular-extensions/browser/match-media\";\nimport {IntlModule} from \"@co.mmons/angular-intl\";\nimport {FormHelperModule} from \"@co.mmons/ionic-extensions/form-helper\";\nimport {SelectModule} from \"@co.mmons/ionic-extensions/select\";\nimport {SpinnerModule} from \"@co.mmons/ionic-extensions/spinner\";\nimport {IonicModule} from \"@ionic/angular\";\nimport {ButtonsModule} from \"@co.mmons/ionic-extensions/buttons\";\nimport {AlignmentMenu} from \"./alignment-menu\";\nimport {HtmlEditor} from \"./editor\";\nimport {HeadingMenu} from \"./heading-menu\";\nimport {InsertMenu} from \"./insert-menu\";\nimport {LinkModal} from \"./link-modal\";\nimport {ListMenu} from \"./list-menu\";\nimport {TextFormatMenu} from \"./text-format-menu\";\nimport {Toolbar} from \"./toolbar\";\n\nexport {HtmlEditor} from \"./editor\";\nexport {HtmlEditorFeatures} from \"./editor-features\";\n\n@NgModule({\n    imports: [CommonModule, IonicModule, IntlModule, SelectModule, FormsModule, ReactiveFormsModule, FormHelperModule, ButtonsModule, MatchMediaModule, SpinnerModule],\n    declarations: [HtmlEditor, AlignmentMenu, HeadingMenu, InsertMenu, LinkModal, ListMenu, TextFormatMenu, Toolbar],\n    exports: [HtmlEditor, IntlModule],\n    entryComponents: [AlignmentMenu, HeadingMenu, InsertMenu, LinkModal, ListMenu, TextFormatMenu]\n})\nexport class HtmlEditorModule {\n}\n"]}