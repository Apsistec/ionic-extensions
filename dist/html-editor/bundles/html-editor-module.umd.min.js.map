{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@co.mmons/ionic-extensions/html-editor/alignment.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/toogle-block-mark.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/marks/font-size.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/marks/alignment.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/nodes/youtube.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/schema.ts","ng://@co.mmons/ionic-extensions/html-editor/alignment-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/alignment/commands.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/selection/find-block-marks.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/keymap.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/views/youtube.ts","ng://@co.mmons/ionic-extensions/html-editor/scroll.ts","ng://@co.mmons/ionic-extensions/html-editor/editor.ts","ng://@co.mmons/ionic-extensions/html-editor/heading-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/link-type.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-marks-in-selection.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-marks.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-node-start-end.ts","ng://@co.mmons/ionic-extensions/html-editor/link-modal.ts","ng://@co.mmons/ionic-extensions/html-editor/insert-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/filter.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/is-empty-selection-at-start.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list/transforms/lift-following-list.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list/utils/get-list-lift-target.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/mark-utils.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/find-cut-before.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list-commands.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/is-first-child-of-parent.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/list/transforms/lift-selection-list.ts","ng://@co.mmons/ionic-extensions/html-editor/list-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/font-sizes.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/commands/toogle-inline-mark.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/is-active.ts","ng://@co.mmons/ionic-extensions/html-editor/text-format-menu.ts","ng://@co.mmons/ionic-extensions/html-editor/toolbar.ts","ng://@co.mmons/ionic-extensions/html-editor/prosemirror/utils/selection/is-block-mark-active.ts","ng://@co.mmons/ionic-extensions/html-editor/index.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","pop","push","__values","o","m","__read","ar","error","__spread","concat","Alignment","alignment","_alignments","MessageRef","alignments","slice","left","right","center","justify","toggleBlockMark","markType","getAttrs","allowedBlocks","state","dispatch","markApplied","tr","_a","selection","from","to","doc","nodesBetween","node","pos","parent","type","isBlock","isArray","indexOf","schema","allowsMarkType","oldMarks","marks","filter","mark","prevAttrs","attrs","undefined","newAttrs","setNodeMarkup","excludes","create","toggleBlockMarkOnRange","docChanged","scrollIntoView","fontSize","group","parseDOM","tag","dom","size","getAttribute","toDOM","style","data-font-size","align","data-align","youtube","id","default","start","inline","draggable","data-youtube","info","split","nodes","content","paragraph","blockquote","basicNodes","horizontalRule","horizontal_rule","heading","text","hardBreak","hard_break","bulletList","assign","orderedList","listItem","link","basicMarks","em","strong","underline","Schema","AlignmentMenu","popoverController","prototype","toggleAligment","_this","command","_b","editor","view","dismiss","ngOnInit","active","tslib_1.__values","_c","findBlockMarks","ionViewWillLeave","focus","PopoverController","tslib_1.__decorate","Input","Component","template","mac","navigator","test","platform","buildKeymap","mapKeys","keys","bind","cmd","mapped","undo","redo","undoInputRule","joinUp","joinDown","lift","selectParentNode","toggleMark","splitListItem","br_1","replaceSelectionWith","createYoutubeIframe","iframe","document","createElement","height","width","src","frameBorder","allow","allowFullscreen","YoutubeNodeView","eventManager","position","overflow","marginTop","appendChild","overlay","top","display","justifyContent","button","classList","add","setAttribute","deleteUnlisten","addEventListener","deleteNode","icon","slot","removeSelectedNode","selectNode","deselectNode","remove","update","destroy","stopEvent","event","ignoreMutation","findScrollParent","element","scrollHeight","clientHeight","overflowY","window","getComputedStyle","assignedSlot","parentElement","HtmlEditor","formControl","item","eventUnlisteners","change","EventEmitter","selectionChange","valueAccessor","HtmlEditor_1","idGenerator","itemInputWrapper","DOMSerializer","fromSchema","serializeFragment","tmp","innerText","prepareOutputValue","uninitializedValue","html","EditorState","plugins","editorDoc","updateState","nativeElement","querySelectorAll","forEach","params","innerHTML","prepareInputValue","setDisabledState","isDisabled","disabled","writeValue","silentChanges","registerOnChange","fn","controlOnChange","registerOnTouched","controlOnTouched","editorInitialized","editorFocused","focused","updateItemClasses","editorBlured","handleScroll","scrollParent","domAtPos","HTMLElement","scrollBehavior","parentRect","getBoundingClientRect","rect","bottom","top_1","offsetTop","offsetParent","scrollTo","behavior","DOMParser","parse","resetControlCss","classes","ion-untouched","untouched","ion-touched","touched","ion-pristine","pristine","ion-dirty","dirty","ion-valid","valid","ion-invalid","elements","elements_1","elements_1_1","fixItemOverflow","item_1","waitTill","shadowRoot","editorTransaction","transaction","readonlyChanged","readonly","ngAfterViewInit","ngAfterContentChecked","ngOnDestroy","unlisten","keymap","baseKeymap","gapCursor","history","EditorView","dispatchTransaction","handleScrollToSelection","nodeViews","ngOnChanges","changes","ElementRef","EventManager","NgControl","Optional","IonItem","HostBinding","Output","selector","tslib_1.__param","HeadingMenu","toggleHeading","activeHeading","setBlockType","level","findParentNodeOfType","DefaultLinkType","_super","inputComponent","inputType","inputValidators","urlValidator","inputLabel","Validators","email","inputHint","__","constructor","tslib_1.__extends","uri","fromLink","www","tel","sms","other","LinkType","toString","urlValidatorRegex","control","invalidUrl","findMarksInSelection","deepEqual","findMarks","findNodeStartEnd","$pos","textOffset","end","child","index","nodeSize","LinkModal","modalController","present","component","LinkModal_1","componentProps","close","unlink","empty","tr_1","isText","removeMark","ok","formHelper","validateAll","form","linkType_1","controls","tr_2","addMark","href","typeChanged","markAsDirty","updateValueAndValidity","sleep","parseLink","prefixes","http:","https:","tel:","sms:","mailto:","lowerCasedUri","trim","toLowerCase","prefix","startsWith","substring","linkValidator","required","validators","validators_1","validators_1_1","validator","ionViewDidEnter","types","FormGroup","FormControl","setValidators","typeChangesSubscription","valueChanges","subscribe","existing","parsed","setValue","unsubscribe","ModalController","ViewChild","FormHelper","static","InsertMenu","insertLink","insertYoutube","inputView","youtubeInput","setFocus","parseYoutube","replace","splice","param","applyYoutube","cancel","role","ionViewDidLeave","predicates","some","pred","isEmptySelectionAtStart","$from","parentOffset","GapCursor","liftListItem","$to","nodeType","range","blockRange","childCount","firstChild","depth","endOfList","ReplaceAroundStep","Slice","Fragment","copy","NodeRange","liftTarget","getListLiftTarget","resPos","sanitizeSelectionMarks","filteredMarks","isRangeOfType","maxDepth","findAncestorPosition","current","Math","min","after","getAncestorNodesBetween","nestableBlocks","newPos","before","name","compose","func","funcs","_i","allFuncs","raw","reduceRight","memo","findCutBefore","spec","isolating","maxIndentation","deletePreviousEmptyListItem","$cut","nodeBefore","delete","joinToPreviousListItem","codeBlock","isGapCursorShown","nodeAfter","$lastNode","nodeBeforePos","findPositionOfNodeBefore","list","append","createChecked","replaceWith","$postCut","mapping","map","join","isInsideListItem","hasParentNodeOfType","canToJoinToPreviousListItem","$before","canOutdent","baseCommand.chainCommands","outdentList","$start","$end","$join","mergeLists","baseListCommand.liftListItem","indentList","initialIndentationLevel","currentIndentationLevel","currentPos","resolvedPos","numberNestedLists","canSink","baseListCommand.sinkListItem","liftListItems","isTextblock","sel","NodeSelection","count","toggleList","listType","fromNode","endNode","rootListDepth","lifted","listDepth","textContent","TextSelection","liftFollowingList","listCol","paragraph_1","liftSelectionList","setSelection","isSameLine","startPos","endPos","nodeAt","adjustSelectionInList","isRangeOfSingleType","grandgrandParent","isInsideList","baseCommand.autoJoin","baseListCommand.wrapInList","toggleListCommand","ListMenu","activeUnnumberedList","findParentNode","predicate","hasMarkup","activeNumberedList","FontSize","_sizes","toUpperCase","sizes","small","large","toggleInlineMark","applies","isInline","markApplies","console","log","markInSet","isInSet","storedMarks","shallowEqual","addStoredMark","removeStoredMark","hasMark","markMatch","rangeHasMark","isMarkActive","TextFormatMenu","toggle","resetFontSize","toggleFontSize","boldActivated","italicActivated","underlineActivated","activeFontSize","MARKS","_d","_e","_f","Toolbar","activeFeatures","showMenu","menu","components","insert","showBackdrop","is","editLink","editorSelectionChanged","canUndo","undoDepth","canRedo","redoDepth","types_1","types_1_1","types_2","types_2_1","anyMarkActive","isBlockMarkActive","selectionSubscription","Platform","HtmlEditorModule","NgModule","imports","CommonModule","IonicModule","IntlModule","SelectModule","FormsModule","ReactiveFormsModule","FormHelperModule","ButtonsModule","MatchMediaModule","declarations","exports","entryComponents"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {MessageRef} from \"@co.mmons/js-intl\";\n\nexport class Alignment {\n\n    private static _alignments: Alignment[] = [];\n\n    static alignments() {\n        return Alignment._alignments.slice();\n    }\n\n    static readonly left = new Alignment(\"left\");\n    static readonly right = new Alignment(\"right\");\n    static readonly center = new Alignment(\"center\");\n    static readonly justify = new Alignment(\"justify\");\n\n    private constructor(public readonly alignment: string) {\n\n        Alignment._alignments.push(this);\n\n        this.label = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"alignmentMenu/\" + alignment);\n    }\n\n    readonly label: MessageRef;\n}\n","import {MarkType, Node as PMNode, NodeType, Schema} from \"prosemirror-model\";\nimport {Transaction} from \"prosemirror-state\";\nimport {Command} from \"../command\";\n\n/**\n * Toggles block mark based on the return type of `getAttrs`.\n * This is similar to ProseMirror\"s `getAttrs` from `AttributeSpec`\n * return `false` to remove the mark.\n * return `undefined for no-op.\n * return an `object` to update the mark.\n */\nexport const toggleBlockMark = <T = object>(\n    markType: MarkType,\n    getAttrs: ((prevAttrs?: T, node?: PMNode) => T | undefined | false),\n    allowedBlocks?:\n        | Array<NodeType>\n        | ((schema: Schema, node: PMNode, parent: PMNode) => boolean),\n): Command => (state, dispatch) => {\n    let markApplied = false;\n    const tr = state.tr;\n\n    const toggleBlockMarkOnRange = (from: number, to: number, tr: Transaction) => {\n\n        state.doc.nodesBetween(from, to, (node, pos, parent) => {\n\n            if (!node.type.isBlock) {\n                return false;\n            }\n\n            if (\n                (!allowedBlocks || (Array.isArray(allowedBlocks) ? allowedBlocks.indexOf(node.type) > -1 : allowedBlocks(state.schema, node, parent))) &&\n                parent.type.allowsMarkType(markType)\n            ) {\n\n                const oldMarks = node.marks.filter(mark => mark.type === markType);\n\n                const prevAttrs = oldMarks.length ? (oldMarks[0].attrs as T) : undefined;\n                const newAttrs = getAttrs(prevAttrs, node);\n\n                if (newAttrs !== undefined) {\n\n                    tr.setNodeMarkup(\n                        pos,\n                        node.type,\n                        node.attrs,\n                        node.marks\n                            .filter(mark => !markType.excludes(mark.type))\n                            .concat(newAttrs === false ? [] : markType.create(newAttrs)),\n                    );\n\n                    markApplied = true;\n                }\n            }\n\n            return;\n\n        });\n    };\n\n    const {from, to} = state.selection;\n    toggleBlockMarkOnRange(from, to, tr);\n\n    if (markApplied && tr.docChanged) {\n        if (dispatch) {\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n\n    return false;\n};\n","import {MarkSpec} from \"prosemirror-model\";\n\nexport const fontSize: MarkSpec = {\n    excludes: \"fontSize\",\n    group: \"fontSize\",\n    attrs: {\n        fontSize: {},\n    },\n    parseDOM: [\n        {\n            tag: \"span[data-font-size]\",\n            getAttrs: dom => {\n                const size = (dom as Element).getAttribute(\"data-font-size\");\n                return size ? {fontSize: size} : false;\n            },\n        },\n    ],\n    toDOM(mark) {\n        return [\n            \"span\",\n            {style: `font-size: ${mark.attrs.fontSize}`, \"data-font-size\": mark.attrs.fontSize},\n            0\n        ];\n    },\n};\n","import {MarkSpec} from \"prosemirror-model\";\n\nexport const alignment: MarkSpec = {\n    excludes: \"alignment\",\n    group: \"alignment\",\n    attrs: {\n        align: {},\n    },\n    parseDOM: [\n        {\n            tag: \"div[data-align]\",\n            getAttrs: dom => {\n                const align = (dom as Element).getAttribute(\"data-align\");\n                return align ? {align} : false;\n            },\n        },\n    ],\n    toDOM(mark) {\n        return [\n            \"div\",\n            {\n                style: `text-align: ${mark.attrs.align}`,\n                \"data-align\": mark.attrs.align,\n            },\n            0\n        ];\n    },\n};\n","import {NodeSpec} from \"prosemirror-model\";\n\nexport const youtube: NodeSpec = {\n    attrs: {id: {default: \"\"}, start: {default: 0}},\n    inline: false,\n    group: \"block\",\n    draggable: false,\n\n    toDOM: (node) => {\n\n        return [\n            \"div\",\n            {\"data-youtube\": node.attrs.id + (node.attrs.start ? \",\" + node.attrs.start : \"\")},\n            \"youtube\"\n        ];\n    },\n\n    parseDOM: [\n        {\n            tag: \"div[data-youtube]\",\n            getAttrs: (dom) => {\n\n                // @ts-ignore\n                const info = dom.getAttribute(\"data-youtube\").split(\",\");\n\n                return {\n                    id: info[0],\n                    start: info.length > 1 ? info[1] : 0\n                };\n            },\n        }\n    ]\n};\n","import {MarkSpec, NodeSpec, Schema} from \"prosemirror-model\";\nimport {marks as basicMarks, nodes as basicNodes} from \"prosemirror-schema-basic\";\nimport {bulletList, listItem, orderedList} from \"prosemirror-schema-list\";\nimport {fontSize} from \"./marks/font-size\";\nimport {alignment} from \"./marks/alignment\";\nimport {youtube} from \"./nodes/youtube\";\n\nexport const nodes = {\n    doc: {\n        content: \"block+\",\n        marks: \"alignment\",\n    },\n\n    paragraph: {\n        content: \"inline*\",\n        marks: \"alignment strong underline em fontSize link\",\n        group: \"block\",\n        parseDOM: [{tag: \"p\"}],\n        toDOM() { return [\"p\", 0]; }\n    } as NodeSpec,\n\n    blockquote: basicNodes.blockquote,\n    horizontalRule: basicNodes.horizontal_rule,\n    heading: basicNodes.heading,\n    text: basicNodes.text,\n    hardBreak: basicNodes.hard_break,\n\n    bulletList: Object.assign({}, bulletList, {\n        content: \"listItem+\",\n        group: \"block\"\n    }) as NodeSpec,\n\n    orderedList: Object.assign({}, orderedList, {\n        content: \"listItem+\",\n        group: \"block\"\n    }) as NodeSpec,\n\n    listItem: Object.assign({}, listItem, {\n        content: \"paragraph block*\",\n        marks: \"alignment\"\n    }) as NodeSpec,\n\n    youtube\n};\n\nexport const marks = {\n    link: basicMarks.link,\n    em: basicMarks.em,\n    strong: basicMarks.strong,\n    alignment,\n    fontSize: fontSize,\n\n    underline: {\n        parseDOM: [{tag: \"u\"}, {style: \"text-decoration=underline\"}],\n        toDOM() {\n            return [\"u\", 0];\n        }\n    } as MarkSpec\n};\n\nexport const schema = new Schema<keyof typeof nodes, keyof typeof marks>({nodes: nodes, marks: marks});\n\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {Alignment} from \"./alignment\";\nimport {HtmlEditor} from \"./editor\";\nimport {changeAlignment} from \"./prosemirror/alignment/commands\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findBlockMarks} from \"./prosemirror/utils/selection/find-block-marks\";\n\n@Component({\n    styles: [`\n        :host ion-list { margin: 0px; padding: 0px; }\n        :host ion-item:last-child { --border-width: 0px; }\n    `],\n    template: `\n        <ion-list lines=\"full\">\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleAligment(alignment)\" *ngFor=\"let alignment of Alignment.alignments()\">\n                <ion-label>{{alignment.label | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"active === alignment.alignment\"></ion-icon>\n                <ion-icon src=\"assets/html-editor/align-{{alignment.alignment}}.svg\" slot=\"start\"></ion-icon>\n            </ion-item>\n\n        </ion-list>\n    `\n})\nexport class AlignmentMenu implements OnInit {\n\n    Alignment = Alignment;\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    active: string;\n\n    toggleAligment(alignment: Alignment) {\n\n        const command = changeAlignment(<any>alignment.alignment);\n\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n\n        this.active = undefined;\n\n        for (const mark of findBlockMarks(this.editor.state, schema.marks.alignment)) {\n\n            // zaznaczonych wiele blockÃ³w z rÃ³Å¼nym wyrÃ³wnaniem\n            if (this.active && this.active !== mark.attrs.align) {\n                this.active = undefined;\n                break;\n            }\n\n            this.active = mark.attrs.align;\n        }\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {EditorState, Transaction} from \"prosemirror-state\";\nimport {Command, CommandDispatch} from \"../command\";\nimport {toggleBlockMark} from \"../commands/toogle-block-mark\";\nimport {AlignmentState} from \"./alignment-state\";\n\n/**\n * Iterates over the commands one after the other,\n * passes the tr through and dispatches the cumulated transaction\n */\nexport const cascadeCommands = (cmds: Array<Command>) => (\n    state: EditorState,\n    dispatch?: CommandDispatch,\n) => {\n    const {tr: baseTr} = state;\n    let shouldDispatch = false;\n\n    const onDispatchAction = (tr: Transaction) => {\n        tr.steps.forEach(st => {\n            baseTr.step(st);\n        });\n        shouldDispatch = true;\n    };\n\n    cmds.forEach(cmd => {\n        cmd(state, onDispatchAction);\n    });\n\n    if (dispatch && shouldDispatch) {\n        dispatch(baseTr);\n        return true;\n    }\n    return false;\n};\n\nexport const isAlignable = (align?: AlignmentState): Command => (state, dispatch) => {\n\n    const {\n        nodes: {paragraph, heading},\n        marks: {alignment},\n    } = state.schema;\n\n    return toggleBlockMark(\n        alignment,\n        () => (!align ? undefined : align === \"left\" ? false : {align}),\n        [paragraph, heading],\n    )(state, dispatch);\n};\n\nexport const changeAlignment = (align?: AlignmentState): Command => (state, dispatch) => {\n\n    const {\n        nodes: {paragraph, heading},\n        marks: {alignment}\n    } = state.schema;\n\n    return toggleBlockMark(alignment,\n        () => (!align ? undefined : align === \"left\" ? false : {align}),\n        [paragraph, heading],\n    )(state, dispatch);\n};\n","import {Mark, MarkType} from \"prosemirror-model\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport function findBlockMarks(state: EditorState, markType: MarkType) {\n\n    const marks: Mark[] = [];\n\n    const {from, to} = state.selection;\n\n    state.doc.nodesBetween(from, to, (node, pos, parent) => {\n\n        if (!node.type.isBlock) {\n            return false;\n        }\n\n        for (const mark of node.marks) {\n            if (mark.type === markType) {\n                marks.push(mark);\n            }\n        }\n\n    });\n\n\n    return marks;\n}\n","import {joinDown, joinUp, lift, selectParentNode, toggleMark} from \"prosemirror-commands\";\nimport {redo, undo} from \"prosemirror-history\";\nimport {undoInputRule} from \"prosemirror-inputrules\";\nimport {Schema} from \"prosemirror-model\";\nimport {splitListItem} from \"prosemirror-schema-list\";\n\nconst mac = typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n\nexport function buildKeymap(schema: Schema, mapKeys?: any) {\n\n    const keys = {};\n    let type: any;\n\n    function bind(key, cmd) {\n\n        if (mapKeys) {\n            const mapped = mapKeys[key];\n\n            if (mapped === false) {\n                return;\n            }\n\n            if (mapped) {\n                key = mapped;\n            }\n        }\n\n        keys[key] = cmd;\n    }\n\n\n    bind(\"Mod-z\", undo);\n    bind(\"Shift-Mod-z\", redo);\n    bind(\"Backspace\", undoInputRule);\n    if (!mac) {\n        bind(\"Mod-y\", redo);\n    }\n\n    bind(\"Alt-ArrowUp\", joinUp);\n    bind(\"Alt-ArrowDown\", joinDown);\n    bind(\"Mod-BracketLeft\", lift);\n    bind(\"Escape\", selectParentNode);\n\n    if (type = schema.marks.strong) {\n        bind(\"Mod-b\", toggleMark(type));\n        bind(\"Mod-B\", toggleMark(type));\n    }\n\n    if (type = schema.marks.em) {\n        bind(\"Mod-i\", toggleMark(type));\n        bind(\"Mod-I\", toggleMark(type));\n    }\n\n    if (type = schema.marks.underline) {\n        bind(\"Mod-u\", toggleMark(type));\n        bind(\"Mod-U\", toggleMark(type));\n    }\n\n    if (type = schema.nodes.listItem) {\n        bind(\"Enter\", splitListItem(type));\n    }\n\n    if (type = schema.nodes.hardBreak) {\n\n        const br = type;\n\n        const cmd = (state, dispatch) => {\n            dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());\n            return true;\n        };\n\n        bind(\"Mod-Enter\", cmd);\n        bind(\"Shift-Enter\", cmd);\n\n        if (mac) {\n            bind(\"Ctrl-Enter\", cmd);\n        }\n    }\n\n    return keys;\n}\n","import {EventManager} from \"@angular/platform-browser\";\nimport {Node} from \"prosemirror-model\";\nimport {removeSelectedNode} from \"prosemirror-utils\";\nimport {EditorView, NodeView} from \"prosemirror-view\";\n\nexport function createYoutubeIframe(id: string, start?: string) {\n\n    const iframe = document.createElement(\"iframe\");\n    iframe.height = \"200px\";\n    iframe.width = \"100%\";\n    iframe.src = `https://www.youtube.com/embed/${id}${start ? \"?start=\" + start : \"\"}`;\n    iframe.frameBorder = \"0\";\n    iframe.allow = \"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\";\n    iframe.allowFullscreen = true;\n\n    return iframe;\n}\n\n// https://www.youtube.com/watch?v=m3V7_Ov52sY\nexport class YoutubeNodeView implements NodeView {\n\n    constructor(node: Node, protected view: EditorView, eventManager: EventManager) {\n\n        this.dom = document.createElement(\"div\");\n        this.dom.style.position = \"relative\";\n        this.dom.style.overflow = \"hidden\";\n        this.dom.style.height = \"200px\";\n        this.dom.style.marginTop = \"16px\";\n\n        this.dom.appendChild(createYoutubeIframe(node.attrs.id, node.attrs.start));\n\n        const overlay = this.dom.appendChild(document.createElement(\"div\"));\n        overlay.style.position = \"absolute\";\n        overlay.style.left = \"0px\";\n        overlay.style.top = \"0px\";\n        overlay.style.width = \"100%\";\n        overlay.style.height = \"200px\";\n        overlay.style.display = \"flex\";\n        overlay.style.justifyContent = \"center\";\n\n        const button = overlay.appendChild(document.createElement(\"ion-button\"));\n        button.classList.add(\"ionx--interactive\");\n        button.setAttribute(\"color\", \"primary\");\n        this.deleteUnlisten = eventManager.addEventListener(button, \"click\", () => this.deleteNode());\n\n        const icon = document.createElement(\"ion-icon\");\n        icon.setAttribute(\"name\", \"trash\");\n        icon.slot = \"icon-only\";\n        button.appendChild(icon);\n    }\n\n    private deleteUnlisten: Function;\n\n    dom: HTMLElement;\n\n    private deleteNode() {\n        this.view.dispatch(removeSelectedNode(this.view.state.tr));\n    }\n\n    selectNode() {\n        this.dom.classList.add(\"ionx--selected\");\n    }\n\n    deselectNode() {\n        this.dom.classList.remove(\"ionx--selected\");\n    }\n\n    update(node: Node) {\n        return false;\n    }\n\n    destroy() {\n\n        if (this.deleteUnlisten) {\n            this.deleteUnlisten();\n        }\n    }\n\n    stopEvent(event: Event) {\n        return false;\n    }\n\n    ignoreMutation() {\n        return true;\n    }\n}\n","export function findScrollParent(element: HTMLElement): HTMLElement {\n\n    if (!element) {\n        return;\n    }\n\n    if (element.scrollHeight >= element.clientHeight) {\n        const overflowY = window.getComputedStyle(element).overflowY;\n        if (overflowY !== \"visible\" && overflowY !== \"hidden\") {\n            return element;\n        }\n    }\n\n    if (element.assignedSlot) {\n        const p = findScrollParent(element.assignedSlot.parentElement);\n        if (p) {\n            return p;\n        }\n    }\n\n    return findScrollParent(element.parentElement);\n}\n\nexport function scrollIntoView(element: HTMLElement, scrollBehavior?: ScrollBehavior, parent?: HTMLElement) {\n\n    if (!parent) {\n        parent = findScrollParent(element);\n    }\n\n    if (parent) {\n\n        const parentRect = parent.getBoundingClientRect();\n        const rect = element.getBoundingClientRect();\n\n        if (!(rect.top > parentRect.top && rect.top <= parentRect.bottom && rect.bottom < parentRect.height)) {\n\n            let top = element.offsetTop;\n\n            if (element.offsetParent) {\n                let offsetParent = element.offsetParent as HTMLElement;\n                while (offsetParent !== parent && !!offsetParent) {\n                    top += offsetParent.offsetTop;\n                    offsetParent = offsetParent.offsetParent as HTMLElement;\n                }\n            }\n\n            parent.scrollTo({top: top, behavior: scrollBehavior});\n        }\n\n        return;\n    }\n\n    element.scrollIntoView();\n}\n","import {AfterContentChecked, AfterViewInit, Component, ElementRef, EventEmitter, HostBinding, Input, OnChanges, OnDestroy, OnInit, Optional, Output, SimpleChanges} from \"@angular/core\";\nimport {ControlValueAccessor, NgControl} from \"@angular/forms\";\nimport {EventManager} from \"@angular/platform-browser\";\nimport {waitTill} from \"@co.mmons/js-utils/core\";\nimport {IonItem} from \"@ionic/angular\";\nimport {baseKeymap} from \"prosemirror-commands\";\nimport {gapCursor} from \"prosemirror-gapcursor\";\nimport {history} from \"prosemirror-history\";\nimport {keymap} from \"prosemirror-keymap\";\nimport {DOMParser, DOMSerializer, Schema} from \"prosemirror-model\";\nimport {EditorState, Plugin, Transaction} from \"prosemirror-state\";\nimport {EditorView} from \"prosemirror-view\";\nimport {HtmlEditorFeatures} from \"./editor-features\";\nimport {buildKeymap} from \"./prosemirror/keymap\";\nimport {schema} from \"./prosemirror/schema\";\nimport {createYoutubeIframe, YoutubeNodeView} from \"./prosemirror/views/youtube\";\nimport {findScrollParent, scrollIntoView} from \"./scroll\";\n\n@Component({\n    selector: \"ionx-html-editor\",\n    template: `\n        <ionx-html-editor-toolbar [style.display]=\"readonly ? 'none' : ''\"></ionx-html-editor-toolbar>\n    `,\n    styles: [`\n        :host ::ng-deep .ProseMirror {\n            outline: none; \n        }\n\n        :host ::ng-deep .ProseMirror[contenteditable=true] {\n            min-height: 60px;\n            white-space: pre-wrap;\n            word-wrap: break-word;\n        }\n        \n        :host ::ng-deep .ProseMirror p {\n            margin: 16px 0px 0px 0px;\n        }\n        \n        :host ::ng-deep .ProseMirror p:first-child {\n            margin-top: 0px;\n        }\n\n        :host ::ng-deep .ProseMirror h1 {\n            font-size: 130%;\n        }\n\n        :host ::ng-deep .ProseMirror h2 {\n            font-size: 125%;\n        }\n\n        :host ::ng-deep .ProseMirror h3 {\n            font-size: 120%;\n        }\n\n        :host ::ng-deep .ProseMirror h4 {\n            font-size: 115%;\n        }\n\n        :host ::ng-deep .ProseMirror h5 {\n            font-size: 110%;\n        }\n\n        :host ::ng-deep .ProseMirror h6 {\n            font-size: 105%;\n        }\n\n        :host ::ng-deep .ProseMirror h1, :host ::ng-deep .ProseMirror h2, :host ::ng-deep .ProseMirror h3, :host ::ng-deep .ProseMirror h4, :host ::ng-deep .ProseMirror h5, :host ::ng-deep .ProseMirror h6 {\n            margin-top: 16px;\n            margin-bottom: 8px;\n        }\n        \n        :host ::ng-deep .ProseMirror h1:first-child, :host ::ng-deep .ProseMirror h2:first-child, :host ::ng-deep .ProseMirror h3:first-child, :host ::ng-deep .ProseMirror h4:first-child, :host ::ng-deep .ProseMirror h5:first-child, :host ::ng-deep .ProseMirror h6:first-child {\n            margin-top: 0px;\n        }\n\n        :host ::ng-deep .ProseMirror ul:first-child {\n            margin-top: 0px;\n        }\n        \n        :host ::ng-deep .ProseMirror[contenteditable=true] .ionx--selected {\n            border: 4px solid var(--ion-color-primary);\n        }\n        \n        :host ::ng-deep .ProseMirror[contenteditable=false] .ionx--interactive {\n            display: none;\n        }\n    `]\n})\nexport class HtmlEditor implements OnInit, AfterViewInit, ControlValueAccessor, AfterContentChecked, OnDestroy, OnChanges {\n\n    private static idGenerator: number = 0;\n\n    constructor(\n        private element: ElementRef<HTMLElement>,\n        public eventManager: EventManager,\n        @Optional() private formControl: NgControl,\n        @Optional() private item: IonItem\n    ) {\n\n        if (formControl) {\n            this.formControl.valueAccessor = this;\n        }\n\n        this.id = \"ionx-trix-editor\" + (HtmlEditor.idGenerator++);\n        this.itemInputWrapper = !!this.item;\n    }\n\n    private eventUnlisteners: Function[] = [];\n\n    readonly id: string;\n\n    @HostBinding(\"class.ionx-item-input-wrapper\")\n    /*private*/ itemInputWrapper: boolean;\n\n    @Input()\n    features: HtmlEditorFeatures;\n\n    @Input()\n    disabled: boolean;\n\n    @Input()\n    readonly: boolean;\n\n    /**\n     * Value, that should be set when editor is fully initialized.\n     */\n    private uninitializedValue: any;\n\n    private controlOnChange: Function;\n\n    private controlOnTouched: Function;\n\n    private focused: boolean;\n\n    private silentChanges: boolean;\n\n    view: EditorView;\n\n    get state() {\n        return this.view.state;\n    }\n\n    private schema: Schema;\n\n    private plugins: Plugin[];\n\n    private scrollParent: HTMLElement;\n\n    @Output()\n    readonly change: EventEmitter<any> = new EventEmitter();\n\n    @Output()\n    readonly selectionChange: EventEmitter<any> = new EventEmitter();\n\n    @Input()\n    public set value(html: string) {\n\n        if (this.view) {\n\n            const state = EditorState.create({\n                schema: this.view.state.schema,\n                plugins: this.view.state.plugins,\n                doc: this.editorDoc(html || \"<div></div>\")\n            });\n\n            this.view.updateState(state);\n\n        } else {\n            this.uninitializedValue = html;\n        }\n    }\n\n    public get value(): string {\n        if (this.view) {\n            const value = DOMSerializer.fromSchema(this.schema).serializeFragment(this.state.doc.content);\n            const tmp = document.createElement(\"div\");\n            tmp.appendChild(value);\n\n            if (!tmp.innerText) {\n                return null;\n            } else {\n                return this.prepareOutputValue(tmp);\n            }\n\n        } else {\n            return this.uninitializedValue;\n        }\n    }\n\n    get nativeElement(): HTMLElement {\n        return this.element.nativeElement;\n    }\n\n    private prepareOutputValue(value: HTMLElement) {\n\n        value.querySelectorAll(\"div[data-youtube]\").forEach((node: HTMLElement) => {\n            const params = node.getAttribute(\"data-youtube\").split(\",\");\n            node.appendChild(createYoutubeIframe(params[0], params.length > 1 ? params[1] : undefined));\n        });\n\n        return value.innerHTML;\n    }\n\n    private prepareInputValue(value: HTMLElement) {\n\n    }\n\n    setDisabledState(isDisabled: boolean): void {\n        this.disabled = !!isDisabled;\n    }\n\n    writeValue(value: any) {\n        this.silentChanges = true;\n        this.value = value;\n    }\n\n    registerOnChange(fn: Function): void {\n        this.controlOnChange = fn;\n    }\n\n    registerOnTouched(fn: Function): void {\n        this.controlOnTouched = fn;\n    }\n\n    focus() {\n        (this.view.dom as HTMLElement).focus();\n        // this.content.focus();\n    }\n\n    // @ts-ignore\n    private async editorInitialized(event: Event) {\n\n        if (this.uninitializedValue) {\n            // this.trixEditor.loadHTML(this.uninitializedValue);\n        }\n\n        // this.trixEditorController.toolbarController.applyKeyboardCommand = this.applyKeyboardCommand.bind(this);\n    }\n\n    // @ts-ignore\n    private editorFocused(event: Event) {\n\n        if (this.controlOnTouched) {\n            this.controlOnTouched(true);\n        }\n\n        this.focused = true;\n        this.updateItemClasses();\n    }\n\n    // @ts-ignore\n    private editorBlured(event: Event) {\n        this.focused = false;\n        this.updateItemClasses();\n    }\n\n    private handleScroll(view: EditorView) {\n\n        if (!this.scrollParent) {\n            this.scrollParent = findScrollParent(this.element.nativeElement);\n        }\n\n        const pos = view.domAtPos(view.state.selection.to);\n\n        if (pos.node instanceof HTMLElement) {\n            scrollIntoView(pos.node, undefined, this.scrollParent);\n        }\n\n        return false;\n    }\n\n    private editorDoc(html: string) {\n\n        const node = document.createElement(\"div\");\n        node.innerHTML = html;\n        this.prepareInputValue(node);\n\n        return DOMParser.fromSchema(this.schema).parse(node);\n    }\n\n    private resetControlCss() {\n\n        const classes = {\n            \"ion-untouched\": this.formControl.untouched,\n            \"ion-touched\": this.formControl.touched,\n            \"ion-pristine\": this.formControl.pristine,\n            \"ion-dirty\": this.formControl.dirty,\n            \"ion-valid\": this.formControl.valid,\n            \"ion-invalid\": !this.formControl.valid\n        };\n\n        const elements: HTMLElement[] = [];\n        elements.push(this.element.nativeElement);\n\n        if (this.item) {\n            elements.push(this.item[\"el\"]);\n        }\n\n        for (const e of elements) {\n            for (const c in classes) {\n                if (classes[c]) {\n                    e.classList.add(c);\n                } else {\n                    e.classList.remove(c);\n                }\n            }\n        }\n    }\n\n    private updateItemClasses() {\n\n        if (!this.item) {\n            return;\n        }\n\n        const item: HTMLElement = this.item[\"el\"];\n\n        if (this.disabled) {\n            item.classList.remove(\"item-interactive\");\n        } else {\n            item.classList.add(\"item-interactive\");\n        }\n\n        if (this.focused) {\n            item.classList.add(\"item-has-focus\");\n        } else {\n            item.classList.remove(\"item-has-focus\");\n        }\n    }\n\n    private async fixItemOverflow() {\n\n        if (this.item) {\n            const item: HTMLElement = this.item[\"el\"];\n            await waitTill(() => !!item.shadowRoot);\n\n            item.style.overflow = \"initial\";\n\n            const style = document.createElement(\"style\");\n            style.innerHTML = `.item-native, .item-inner, .input-wrapper { overflow: initial !important; }`;\n            item.shadowRoot.appendChild(style);\n        }\n\n    }\n\n    private editorTransaction(transaction: Transaction) {\n\n        this.focus();\n        this.view.updateState(this.view.state.apply(transaction));\n\n        this.selectionChange.next();\n\n        if (transaction.docChanged) {\n            this.change.next();\n\n            if (this.controlOnChange && !this.silentChanges) {\n                this.controlOnChange(this.value);\n            }\n        }\n\n        this.silentChanges = false;\n    }\n\n    private readonlyChanged() {\n\n        if (this.view) {\n            this.view.dom[\"contentEditable\"] = !this.readonly && !this.disabled ? \"true\" : \"false\";\n        }\n\n    }\n\n    ngAfterViewInit(): void {\n        this.fixItemOverflow();\n        this.updateItemClasses();\n    }\n\n    ngAfterContentChecked() {\n        this.resetControlCss();\n    }\n\n    ngOnDestroy() {\n\n        for (const unlisten of this.eventUnlisteners) {\n            unlisten();\n        }\n\n        this.view.destroy();\n        this.view = undefined;\n    }\n\n    ngOnInit() {\n\n        this.schema = schema;\n\n        this.plugins = [\n            keymap(buildKeymap(schema)),\n            keymap(baseKeymap),\n            gapCursor(),\n            history()\n        ];\n\n        const state = EditorState.create({\n            schema: this.schema,\n            plugins: this.plugins,\n            doc: this.editorDoc(this.uninitializedValue ? this.uninitializedValue : \"<div></div>\")\n        });\n\n        this.view = new EditorView(this.element.nativeElement, {\n            state: state,\n            dispatchTransaction: (transaction) => this.editorTransaction(transaction),\n            handleScrollToSelection: (view) => this.handleScroll(view),\n\n            nodeViews: {\n                youtube: (node, view) => new YoutubeNodeView(node, view, this.eventManager)\n            }\n        });\n\n        this.silentChanges = false;\n\n        if (this.readonly || this.disabled) {\n            this.readonlyChanged();\n        }\n    }\n\n    ngOnChanges(changes: SimpleChanges): void {\n\n        if (changes[\"readonly\"] || changes[\"disabled\"]) {\n            this.readonlyChanged();\n        }\n\n    }\n}\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {HtmlEditor} from \"./editor\";\nimport {schema} from \"./prosemirror/schema\";\nimport {setBlockType} from \"prosemirror-commands\";\nimport {findParentNodeOfType} from \"prosemirror-utils\";\n\n@Component({\n    styles: [\n        `:host ion-list { margin: 0px; padding: 0px }`,\n        `:host ion-item:last-child { --border-width: 0px; }`,\n    ],\n    template: `\n        <ion-list lines=\"full\">\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(0)\" *ngIf=\"activeHeading > 0\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#Plain text\" | intlMessage}}</ion-label>\n            </ion-item>\n            \n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(1)\">\n                <ion-label style=\"font-size: 130%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 1</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 1\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(2)\">\n                <ion-label style=\"font-size: 125%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 2</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 2\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(3)\">\n                <ion-label style=\"font-size: 120%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 3</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 3\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(4)\">\n                <ion-label style=\"font-size: 115%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 4</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 4\"></ion-icon>\n            </ion-item>\n            \n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(5)\">\n                <ion-label style=\"font-size: 110%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 5</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 5\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleHeading(6)\">\n                <ion-label style=\"font-size: 105%; font-weight: 500\">{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}} 6</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeHeading == 6\"></ion-icon>\n            </ion-item>\n            \n        </ion-list>\n    `\n})\nexport class HeadingMenu implements OnInit {\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    activeHeading: number;\n\n    @Input()\n    editor: HtmlEditor;\n\n\n    toggleHeading(heading: number) {\n\n        if (heading > 0 && this.activeHeading !== heading) {\n\n            const command = setBlockType(schema.nodes.heading, {level: heading});\n            if (command(this.editor.state)) {\n                command(this.editor.state, (tr) => {\n                    this.editor.view.dispatch(tr);\n                });\n            }\n\n        } else {\n            setBlockType(schema.nodes.paragraph)(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n\n        const active = findParentNodeOfType(schema.nodes.heading)(this.editor.state.selection);\n        if (active) {\n            this.activeHeading = active.node.attrs.level;\n        }\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {AbstractControl, ValidationErrors, ValidatorFn, Validators} from \"@angular/forms\";\nimport {MessageRef} from \"@co.mmons/js-intl\";\n\nexport abstract class LinkType {\n\n    protected constructor(public readonly type: string) {\n    }\n\n    abstract get label(): MessageRef;\n\n    abstract get inputType(): string;\n\n    abstract get inputComponent(): any;\n\n    abstract get inputValidators(): ValidatorFn[];\n\n    abstract get inputHint(): MessageRef;\n\n    abstract get inputLabel(): MessageRef;\n\n    abstract uri(fromLink: string): string;\n\n    toString() {\n        return this.type;\n    }\n}\n\nexport class DefaultLinkType extends LinkType {\n\n    static readonly www = new DefaultLinkType(\"www\");\n    static readonly email = new DefaultLinkType(\"email\");\n    static readonly tel = new DefaultLinkType(\"tel\");\n    static readonly sms = new DefaultLinkType(\"sms\");\n    static readonly other = new DefaultLinkType(\"other\");\n\n    constructor(type: string) {\n        super(type);\n\n        this.label = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/type/\" + type);\n\n        if (type === \"www\") {\n            this.inputType = \"url\";\n        } else if (type === \"other\") {\n            this.inputType = \"text\";\n        } else if (type === \"sms\") {\n            this.inputType = \"sms\";\n        } else {\n            this.inputType = type;\n        }\n\n        if (type === \"www\") {\n            this.inputValidators = [urlValidator];\n            this.inputLabel = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/Web page url\");\n        }\n\n        if (type === \"email\") {\n            this.inputValidators = [Validators.email];\n            this.inputLabel = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/E-mail address\");\n        }\n\n        if (type === \"tel\" || type === \"sms\") {\n            this.inputLabel = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/Phone number\");\n            this.inputHint = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/phoneNumberHint\");\n        }\n    }\n\n\n    readonly label: MessageRef;\n\n    readonly inputType: string;\n\n    readonly inputValidators: ValidatorFn[];\n\n    readonly inputComponent = undefined;\n\n    readonly inputLabel: MessageRef;\n\n    readonly inputHint: MessageRef;\n\n    uri(fromLink: string) {\n\n        if (this.type === \"www\" || this.type === \"other\") {\n            return fromLink;\n        } else if (this.type === \"tel\") {\n            return `tel:${fromLink}`;\n        } else if (this.type === \"sms\") {\n            return `sms:${fromLink}`;\n        } else if (this.type === \"email\") {\n            return `mailto:${fromLink}`;\n        }\n\n        return fromLink;\n    }\n\n}\n\nconst urlValidatorRegex = /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i;\n\nfunction urlValidator(control: AbstractControl): ValidationErrors {\n\n    const value = control.value;\n\n    if (urlValidatorRegex.test(value)) {\n        return undefined;\n    }\n\n    return {\n        invalidUrl: new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"link/invalidUrlError\")\n    };\n}\n","import {findMarks} from \"./find-marks\";\nimport {MarkType} from \"prosemirror-model\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport function findMarksInSelection(state: EditorState, markType: MarkType, attrs?: {[key: string]: any}) {\n    const doc = state.doc;\n    const {from, to} = state.selection;\n    return findMarks(doc, from, to, markType, attrs);\n}\n","import {deepEqual} from \"fast-equals\";\nimport {Mark, MarkType, Node} from \"prosemirror-model\";\n\nexport function findMarks(doc: Node, from: number, to: number, markType: MarkType, attrs?: {[key: string]: any}) {\n\n    const marks: Mark[] = [];\n\n    doc.nodesBetween(from, to, node => {\n\n        for (let i = 0; i < node.marks.length; i++) {\n            if (node.marks[i].type === markType && (!attrs || deepEqual(node.marks[i].attrs, attrs))) {\n                marks.push(node.marks[i]);\n            }\n        }\n\n    });\n\n    return marks;\n}\n","import {Node} from \"prosemirror-model\";\n\nexport function findNodeStartEnd(doc: Node, pos: number) {\n\n    const $pos = doc.resolve(pos);\n    const start = pos - $pos.textOffset;\n    const end = start + $pos.parent.child($pos.index()).nodeSize;\n\n    return {start, end};\n}\n","import {Component, Input, OnDestroy, OnInit, ViewChild} from \"@angular/core\";\nimport {AbstractControl, FormControl, FormGroup, ValidationErrors, Validators} from \"@angular/forms\";\nimport {FormHelper} from \"@co.mmons/ionic-extensions/form-helper\";\nimport {sleep} from \"@co.mmons/js-utils/core\";\nimport {unsubscribe} from \"@co.mmons/rxjs-utils\";\nimport {ModalController} from \"@ionic/angular\";\nimport {toggleMark} from \"prosemirror-commands\";\nimport {Subscription} from \"rxjs\";\nimport {HtmlEditor} from \"./editor\";\nimport {DefaultLinkType, LinkType} from \"./link-type\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findMarksInSelection} from \"./prosemirror/utils/find-marks-in-selection\";\nimport {findNodeStartEnd} from \"./prosemirror/utils/find-node-start-end\";\n\n@Component({\n    template: `\n        <ion-header>\n            \n            <ion-toolbar>\n\n                <ionx-buttons slot=\"start\">\n                    <ion-back-button style=\"display: inline-block\" [icon]=\"('tablet' | matchGreaterWidth) ? 'close' : 'arrow-back'\" (click)=\"$event.preventDefault(); close()\"></ion-back-button>\n                </ionx-buttons>\n                \n                <ion-title style=\"margin: 0; padding: 0;\">{{\"@co.mmons/ionic-extensions/html-editor#link/Link\" | intlMessage}}</ion-title>\n\n                <ionx-buttons slot=\"end\">\n\n                    <ion-button fill=\"clear\" color=\"dark\" (click)=\"unlink()\" *ngIf=\"existing\">\n                        <ion-icon name=\"trash\" slot=\"start\"></ion-icon>\n                        <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#link/Unlink\" | intlMessage}}</ion-label>\n                    </ion-button>\n\n                    <ion-button fill=\"clear\" color=\"primary\" (click)=\"ok()\">\n                        <ion-icon name=\"checkmark\" slot=\"start\"></ion-icon>\n                        <ion-label>{{\"@co.mmons/js-intl#Done\" | intlMessage}}</ion-label>\n                    </ion-button>\n                    \n                </ionx-buttons>\n                \n            </ion-toolbar>\n            \n        </ion-header>\n        <ion-content>\n            \n            <form ionx-form-helper [formGroup]=\"form\">\n                \n                <ion-grid>\n                    \n                    <ion-row>\n                        \n                        <ion-col [sizeXs]=\"12\">\n                            \n                            <ionx-form-item>\n\n                                <ion-item>\n                                    <ion-label position=\"stacked\">{{\"@co.mmons/ionic-extensions/html-editor#link/Link type\" | intlMessage}}</ion-label>\n                                    <ionx-select required [compareAsString]=\"true\" formControlName=\"type\">\n                                        <ionx-select-option *ngFor=\"let type of types\" [value]=\"type\">{{type.label | intlMessage}}</ionx-select-option>\n                                    </ionx-select>\n                                </ion-item>\n    \n                            </ionx-form-item>\n                            \n                        </ion-col>\n\n                        <ion-col [sizeXs]=\"12\">\n                            \n                            <ionx-form-item>\n    \n                                <ion-item>\n                                    <ion-label position=\"stacked\">{{(form.controls['type'].value.inputLabel || \"@co.mmons/ionic-extensions/html-editor#link/Link\") | intlMessage}}</ion-label>\n                                    <ion-input formControlName=\"link\" type=\"form.controls['type'].value.inputType\"></ion-input>\n                                </ion-item>\n                                \n                                <ionx-form-item-error control=\"link\" markedAs=\"dirty\"></ionx-form-item-error>\n                                \n                                <ionx-form-item-hint *ngIf=\"form.controls['type'].value.inputHint\">\n                                    <span [innerHTML]=\"form.controls['type'].value.inputHint | intlMessage\"></span>\n                                </ionx-form-item-hint>\n\n                            </ionx-form-item>\n\n                        </ion-col>\n                        \n                    </ion-row>\n                    \n                    \n                </ion-grid>\n                \n            </form>\n            \n        </ion-content>\n    `,\n    styles: [\n        `:host ion-item:not(.ion-dirty) { --highlight-height: 0px; }`\n    ]\n})\nexport class LinkModal implements OnInit, OnDestroy {\n\n    static async present(modalController: ModalController, editor: HtmlEditor) {\n\n        const modal = await modalController.create({component: LinkModal, componentProps: {editor: editor}});\n        modal.present();\n    }\n\n    constructor(private modalController: ModalController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    existing: boolean;\n\n    types: LinkType[];\n\n    form: FormGroup;\n\n    @ViewChild(FormHelper, {static: false})\n    formHelper: FormHelper;\n\n    async close() {\n        await this.modalController.dismiss();\n        this.editor.focus();\n    }\n\n    async unlink() {\n\n        await this.modalController.dismiss();\n\n        const selection = this.editor.state.selection;\n\n        if (selection.empty) {\n\n            const tr = this.editor.state.tr;\n\n            tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n                if (node.isText) {\n                    const $pos = tr.doc.resolve(pos);\n                    const start = pos - $pos.textOffset;\n                    const end = start + $pos.parent.child($pos.index()).nodeSize;\n\n                    tr.removeMark(start, end, schema.marks.link);\n                }\n            });\n\n            this.editor.view.dispatch(tr);\n\n        } else {\n            toggleMark(schema.marks.link)(this.editor.state, tr => this.editor.view.dispatch(tr));\n        }\n    }\n\n    async ok() {\n        this.formHelper.validateAll(\"dirty\");\n\n        if (this.form.valid) {\n            await this.modalController.dismiss();\n\n            const linkType = this.form.controls.type.value as LinkType;\n            const selection = this.editor.state.selection;\n\n            const tr = this.editor.state.tr;\n\n            if (selection.empty) {\n\n                tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n                    if (node.isText) {\n                        const {start, end} = findNodeStartEnd(tr.doc, pos);\n                        tr.addMark(start, end, schema.mark(schema.marks.link, {href: linkType.uri(this.form.controls.link.value)}));\n                    }\n                });\n\n            } else {\n\n                // usuwamy poprzedni link\n                tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n                    if (node.isText) {\n                        const {start, end} = findNodeStartEnd(tr.doc, pos);\n                        tr.removeMark(start, end, schema.marks.link);\n                    }\n                });\n\n                tr.addMark(selection.from, selection.to, schema.mark(schema.marks.link, {href: linkType.uri(this.form.controls.link.value)}));\n            }\n\n            this.editor.view.dispatch(tr);\n        }\n    }\n\n    private async typeChanged() {\n\n        if (this.form.controls.link.value) {\n            this.form.controls.link.markAsDirty();\n            this.form.controls.link.updateValueAndValidity();\n        }\n\n        await sleep(50); // we must wait for closing type selector\n\n        this.formHelper.focus(\"link\", false);\n    }\n\n    private parseLink(uri: string): {type: LinkType, link: string} {\n\n        const prefixes = {\n            \"http:\": DefaultLinkType.www,\n            \"https:\": DefaultLinkType.www,\n            \"tel:\": DefaultLinkType.tel,\n            \"sms:\": DefaultLinkType.sms,\n            \"mailto:\": DefaultLinkType.email\n        };\n\n        const lowerCasedUri = uri.trim().toLowerCase();\n\n        for (const prefix of Object.keys(prefixes)) {\n            if (lowerCasedUri.startsWith(prefix)) {\n\n                const link = {type: prefixes[prefix], link: uri.trim()};\n\n                if (prefixes[prefix] !== DefaultLinkType.www) {\n                    link.link = uri.substring(prefix.length).trim();\n                }\n\n                return link;\n            }\n        }\n\n        return {type: DefaultLinkType.other, link: uri};\n    }\n\n    private linkValidator(control: AbstractControl): ValidationErrors {\n\n        const required = Validators.required(control);\n        if (required) {\n            return required;\n        }\n\n        const type = this.form.controls.type.value as LinkType;\n        const validators = type.inputValidators;\n\n        if (validators) {\n            for (const validator of validators) {\n                const r = validator(control);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n    }\n\n    async ionViewDidEnter() {\n        this.formHelper.focus(\"link\", false);\n    }\n\n    async ionViewWillLeave() {\n        this.editor.focus();\n    }\n\n    private typeChangesSubscription: Subscription;\n\n    ngOnInit() {\n        this.types = [DefaultLinkType.www, DefaultLinkType.email, DefaultLinkType.tel, DefaultLinkType.sms, DefaultLinkType.other];\n\n        this.form = new FormGroup({\n            type: new FormControl(DefaultLinkType.www),\n            link: new FormControl()\n        });\n\n        this.form.controls.link.setValidators(control => this.linkValidator(control));\n\n        this.typeChangesSubscription = this.form.controls[\"type\"].valueChanges.subscribe(() => this.typeChanged());\n        this.typeChanged();\n\n        this.existing = undefined;\n        MARKS: for (const mark of findMarksInSelection(this.editor.state, schema.marks.link)) {\n            const parsed = this.parseLink(mark.attrs.href);\n            if (parsed) {\n                this.form.controls[\"type\"].setValue(parsed.type);\n                this.form.controls[\"link\"].setValue(parsed.link);\n                this.existing = true;\n            }\n        }\n    }\n\n    ngOnDestroy() {\n        unsubscribe(this.typeChangesSubscription);\n    }\n\n}\n","import {Component, Input, OnInit, ViewChild} from \"@angular/core\";\nimport {sleep, waitTill} from \"@co.mmons/js-utils/core\";\nimport {IonInput, ModalController, PopoverController} from \"@ionic/angular\";\nimport {OverlayEventDetail} from \"@ionic/core\";\nimport {HtmlEditor} from \"./editor\";\nimport {LinkModal} from \"./link-modal\";\n\n@Component({\n    styles: [\n        `:host ion-list { margin: 0px; padding: 0px }`,\n        `:host ion-item:last-child { --border-width: 0px; }`,\n        `:host ion-item { --highlight-height: 0px; }`\n    ],\n    template: `\n        <ion-list lines=\"full\">\n            \n            <ng-template [ngIf]=\"!inputView\">\n                \n                <ion-item button=\"true\" detail=\"false\" (click)=\"insertLink()\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#link/Link\" | intlMessage}}</ion-label>\n                    <ion-icon name=\"link\" slot=\"start\"></ion-icon>\n                </ion-item>\n    \n                <ion-item button=\"true\" detail=\"false\" (click)=\"insertYoutube()\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#youtube/YouTube video\" | intlMessage}}</ion-label>\n                    <ion-icon name=\"logo-youtube\" slot=\"start\"></ion-icon>\n                </ion-item>\n                \n            </ng-template>\n            \n            <ng-template [ngIf]=\"inputView == 'youtube'\">\n\n                <ion-item>\n                    <ion-icon name=\"logo-youtube\" slot=\"start\"></ion-icon>\n                    <ion-input #youtubeInput [placeholder]=\"'@co.mmons/ionic-extensions/html-editor#youtube/Paste YouTube video url' | intlMessage\" (keydown.enter)=\"applyYoutube()\"></ion-input>\n                </ion-item>\n                \n                <ion-item>\n                    <ionx-buttons slot=\"end\">\n                        <ion-button fill=\"clear\" color=\"dark\" (click)=\"cancel()\">\n                            <ion-label>{{\"@co.mmons/js-intl#Cancel\" | intlMessage}}</ion-label>\n                        </ion-button>\n                        \n                        <ion-button fill=\"clear\" color=\"primary\" (click)=\"applyYoutube()\">\n                            <ion-label>{{\"@co.mmons/js-intl#Ok\" | intlMessage}}</ion-label>\n                        </ion-button>\n                    </ionx-buttons>\n                </ion-item>\n    \n            </ng-template>\n            \n        </ion-list>\n    `\n})\nexport class InsertMenu implements OnInit {\n\n    // @ts-ignore\n    constructor(private popoverController: PopoverController, private modalController: ModalController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    inputView: \"youtube\";\n\n    // @ts-ignore\n    private editorLastSelection: [number, number];\n\n\n    async insertLink() {\n\n        this.popoverController.dismiss(undefined, \"link\");\n\n        LinkModal.present(this.modalController, this.editor);\n    }\n\n    @ViewChild(\"youtubeInput\", {static: false})\n    private youtubeInput: IonInput;\n\n    async insertYoutube() {\n\n        this.inputView = \"youtube\";\n\n        await waitTill(() => !!this.youtubeInput, undefined, 2000);\n        this.youtubeInput.setFocus();\n    }\n\n    // @ts-ignore\n    private parseYoutube(value: string): {id: string, start?: string} {\n        // https://www.youtube.com/watch?v=NqMgaHUNSQc\n        // https://youtu.be/NqMgaHUNSQc\n        // https://www.youtube.com/embed/NqMgaHUNSQc\n        // https://www.youtube-nocookie.com/embed/NqMgaHUNSQc\n        // https://youtu.be/NqMgaHUNSQc?t=17\n\n        value = value.replace(\"-nocookie.com/\", \".com/\");\n        value = value.replace(\"/embed/\", \"/\");\n        value = value.replace(\"youtu.be/\", \"youtube.com/\");\n        value = value.replace(\"watch?v=\", \"\");\n        value = value.replace(\"?\", \"&\");\n\n        const info = {id: undefined, start: undefined};\n\n        if (value.indexOf(\"youtube.com/\") > -1) {\n            value = value.split(\"youtube.com/\").splice(1, 1)[0];\n\n            for (const param of value.split(\"&\")) {\n                if (param.indexOf(\"=\") < 0) {\n                    info.id = param;\n                } else if (param.startsWith(\"t=\")) {\n                    info.start = param.substring(2);\n                } else if (param.startsWith(\"start=\")) {\n                    info.start = param.substring(6);\n                }\n            }\n\n        } else  {\n        }\n\n        if (info.id) {\n            return info;\n        }\n    }\n\n\n    applyYoutube() {\n\n\n        const info = this.parseYoutube(this.youtubeInput.value);\n        if (info) {\n            const tr = this.editor.state.tr.replaceSelectionWith(this.editor.state.schema.nodes.youtube.create({id: info.id, start: info.start || 0}));\n            this.editor.view.dispatch(tr);\n        }\n\n        this.popoverController.dismiss(undefined, \"youtube\");\n    }\n\n    cancel() {\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n    }\n\n    async ionViewWillLeave(event: OverlayEventDetail<any>) {\n\n        if (!this.inputView && !event.role) {\n            this.editor.focus();\n        }\n    }\n\n    async ionViewDidLeave(event: OverlayEventDetail<any>) {\n\n        if (this.inputView) {\n            await sleep(50);\n            this.editor.focus();\n\n        } else if (!event.role) {\n            this.editor.focus();\n        }\n    }\n}\n","import {Command} from \"../command\";\nimport {Predicate} from \"../predicate\";\n\nexport const filter = (predicates: Predicate[] | Predicate, cmd: Command): Command => {\n\n    return function(state, dispatch, view): boolean {\n        if (!Array.isArray(predicates)) {\n            predicates = [predicates];\n        }\n\n        if (predicates.some(pred => !pred(state, view))) {\n            return false;\n        }\n\n        return cmd(state, dispatch, view) || false;\n    };\n};\n","import {GapCursor} from \"prosemirror-gapcursor\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport const isEmptySelectionAtStart = (state: EditorState): boolean => {\n    const {empty, $from} = state.selection;\n    return (\n        empty &&\n        ($from.parentOffset === 0 || state.selection instanceof GapCursor)\n    );\n};\n\n","import {Fragment, NodeRange, Slice} from \"prosemirror-model\";\nimport {EditorState, Selection, TextSelection, Transaction,} from \"prosemirror-state\";\nimport {liftTarget, ReplaceAroundStep} from \"prosemirror-transform\";\n\nfunction liftListItem(\n    state: EditorState,\n    selection: Selection,\n    tr: Transaction,\n): Transaction {\n    const { $from, $to } = selection;\n    const nodeType = state.schema.nodes.listItem;\n    let range = $from.blockRange(\n        $to,\n        node =>\n            !!node.childCount &&\n            !!node.firstChild &&\n            node.firstChild.type === nodeType,\n    );\n    if (\n        !range ||\n        range.depth < 2 ||\n        $from.node(range.depth - 1).type !== nodeType\n    ) {\n        return tr;\n    }\n    const end = range.end;\n    const endOfList = $to.end(range.depth);\n    if (end < endOfList) {\n        tr.step(\n            new ReplaceAroundStep(\n                end - 1,\n                endOfList,\n                end,\n                endOfList,\n                new Slice(\n                    Fragment.from(nodeType.create(undefined, range.parent.copy())),\n                    1,\n                    0,\n                ),\n                1,\n                true,\n            ),\n        );\n\n        range = new NodeRange(\n            tr.doc.resolve($from.pos),\n            tr.doc.resolve(endOfList),\n            range.depth,\n        );\n    }\n    return tr.lift(range, liftTarget(range) as number).scrollIntoView();\n}\n\nexport function liftFollowingList(\n    state: EditorState,\n    from: number,\n    to: number,\n    rootListDepth: number,\n    tr: Transaction,\n): Transaction {\n    const { listItem } = state.schema.nodes;\n    let lifted = false;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!lifted && node.type === listItem && pos > from) {\n            lifted = true;\n            let listDepth = rootListDepth + 3;\n            while (listDepth > rootListDepth + 2) {\n                const start = tr.doc.resolve(tr.mapping.map(pos));\n                listDepth = start.depth;\n                const end = tr.doc.resolve(\n                    tr.mapping.map(pos + node.textContent.length),\n                );\n                const sel = new TextSelection(start, end);\n                tr = liftListItem(state, sel, tr);\n            }\n        }\n    });\n    return tr;\n}\n","import {ResolvedPos, Schema} from \"prosemirror-model\";\n\n// This will return (depth - 1) for root list parent of a list.\nexport const getListLiftTarget = (\n    schema: Schema,\n    resPos: ResolvedPos,\n): number => {\n    let target = resPos.depth;\n    const { bulletList, orderedList, listItem } = schema.nodes;\n    for (let i = resPos.depth; i > 0; i--) {\n        const node = resPos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            target = i;\n        }\n        if (\n            node.type !== bulletList &&\n            node.type !== orderedList &&\n            node.type !== listItem\n        ) {\n            break;\n        }\n    }\n    return target - 1;\n};\n","import { Node, Mark, MarkType } from \"prosemirror-model\";\nimport { SelectionRange, EditorState, Transaction } from \"prosemirror-state\";\n\nexport const isMarkAllowedInRange = (\n    doc: Node,\n    ranges: Array<SelectionRange>,\n    type: MarkType,\n): boolean => {\n    for (let i = 0; i < ranges.length; i++) {\n        const { $from, $to } = ranges[i];\n        let can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, node => {\n            if (can) {\n                return false;\n            }\n            can = node.inlineContent && node.type.allowsMarkType(type);\n            return;\n        });\n        if (can) {\n            return can;\n        }\n    }\n    return false;\n};\n\nexport const isMarkExcluded = (\n    type: MarkType,\n    marks?: Array<Mark> | null,\n): boolean => {\n    if (marks) {\n        return marks.some(mark => mark.type !== type && mark.type.excludes(type));\n    }\n    return false;\n};\n\nconst not = <T>(fn: ((args: T) => boolean)) => (arg: T) => !fn(arg);\n\nexport const removeBlockMarks = (\n    state: EditorState,\n    marks: Array<MarkType | undefined>,\n): Transaction | undefined => {\n    const { selection, schema } = state;\n    let { tr } = state;\n\n    // Marks might not exist in Schema\n    const marksToRemove = marks.filter(Boolean);\n    if (marksToRemove.length === 0) {\n        return undefined;\n    }\n\n    /** Saves an extra dispatch */\n    let blockMarksExists = false;\n\n    const hasMark = (mark: Mark) => marksToRemove.indexOf(mark.type) > -1;\n    /**\n     * When you need to toggle the selection\n     * when another type which does not allow alignment is applied\n     */\n    state.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n        if (node.type === schema.nodes.paragraph && node.marks.some(hasMark)) {\n            blockMarksExists = true;\n            const resolvedPos = state.doc.resolve(pos);\n            const withoutBlockMarks = node.marks.filter(not(hasMark));\n            tr = tr.setNodeMarkup(\n                resolvedPos.pos,\n                undefined,\n                node.attrs,\n                withoutBlockMarks,\n            );\n        }\n    });\n    return blockMarksExists ? tr : undefined;\n};\n\n/**\n * Removes marks from nodes in the current selection that are not supported\n */\nexport const sanitizeSelectionMarks = (\n    state: EditorState,\n): Transaction | undefined => {\n    let tr: Transaction | undefined;\n    const { $from, $to } = state.tr.selection;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n        node.marks.forEach(mark => {\n            if (!node.type.allowsMarkType(mark.type)) {\n                const filteredMarks = node.marks.filter(m => m.type !== mark.type);\n                const position = pos > 0 ? pos - 1 : 0;\n                tr = (tr || state.tr).setNodeMarkup(\n                    position,\n                    undefined,\n                    node.attrs,\n                    filteredMarks,\n                );\n            }\n        });\n    });\n    return tr;\n};\n","import { toggleMark } from \"prosemirror-commands\";\nimport {GapCursor} from \"prosemirror-gapcursor\";\nimport {\n    Fragment,\n    Mark as PMMark,\n    MarkType,\n    Node,\n    NodeType,\n    ResolvedPos,\n    Slice,\n    Schema,\n    NodeRange,\n    Mark,\n} from \"prosemirror-model\";\nimport { EditorView } from \"prosemirror-view\";\nimport {\n    EditorState,\n    NodeSelection,\n    Selection,\n    TextSelection,\n    Transaction,\n} from \"prosemirror-state\";\nimport { liftTarget, findWrapping } from \"prosemirror-transform\";\nimport { hasParentNodeOfType } from \"prosemirror-utils\";\nimport { isNodeEmpty } from \"./document-utils\";\n\nexport {\n    isEmptyParagraph,\n    hasVisibleContent,\n    isNodeEmpty,\n    isEmptyDocument,\n    getStepRange,\n    findFarthestParentNode,\n    isSelectionEndOfParagraph,\n    nodesBetweenChanged,\n} from \"./document-utils\";\n\n\nexport const ZeroWidthSpace = \"\\u200b\";\n\nfunction validateNode(_node: Node): boolean {\n    return false;\n}\n\nfunction isMarkTypeCompatibleWithMark(\n    markType: MarkType,\n    mark: PMMark,\n): boolean {\n    return !mark.type.excludes(markType) && !markType.excludes(mark.type);\n}\n\nfunction isMarkTypeAllowedInNode(\n    markType: MarkType,\n    state: EditorState,\n): boolean {\n    return toggleMark(markType)(state);\n}\n\nfunction closest(\n    node: HTMLElement | null | undefined,\n    s: string,\n): HTMLElement | null {\n    let el = node as HTMLElement;\n    if (!el) {\n        return null;\n    }\n    if (!document.documentElement || !document.documentElement.contains(el)) {\n        return null;\n    }\n    const matches = el.matches ? \"matches\" : \"msMatchesSelector\";\n\n    do {\n        // @ts-ignore\n        if (el[matches] && el[matches](s)) {\n            return el;\n        }\n        el = (el.parentElement || el.parentNode) as HTMLElement;\n    } while (el !== null && el.nodeType === 1);\n    return null;\n}\n\nexport const isImage = (fileType?: string): boolean => {\n    return (\n        !!fileType &&\n        (fileType.indexOf(\"image/\") > -1 || fileType.indexOf(\"video/\") > -1)\n    );\n};\n\nexport function canMoveUp(state: EditorState): boolean {\n    const { selection, doc } = state;\n\n    /**\n     * If there\"s a media element on the selection,\n     * add text blocks with arrow navigation.\n     * Also, the selection could be media | mediaGroup.\n     */\n    if (selection instanceof NodeSelection) {\n        if (selection.node.type.name === \"media\") {\n            /** Weird way of checking if the previous element is a paragraph */\n            const mediaAncestorNode = doc.nodeAt(selection.anchor - 3);\n            return !!(\n                mediaAncestorNode && mediaAncestorNode.type.name === \"paragraph\"\n            );\n        } else if (selection.node.type.name === \"mediaGroup\") {\n            const mediaGroupAncestorNode = selection.$anchor.nodeBefore;\n            return !!(\n                mediaGroupAncestorNode &&\n                mediaGroupAncestorNode.type.name === \"paragraph\"\n            );\n        }\n    }\n\n    if (selection instanceof TextSelection) {\n        if (!selection.empty) {\n            return true;\n        }\n    }\n\n    return !atTheBeginningOfDoc(state);\n}\n\nexport function canMoveDown(state: EditorState): boolean {\n    const { selection, doc } = state;\n\n    /**\n     * If there\"s a media element on the selection,\n     * add text blocks with arrow navigation.\n     * Also, the selection could be media | mediaGroup.\n     */\n    if (selection instanceof NodeSelection) {\n        if (selection.node.type.name === \"media\") {\n            const nodeAfter = doc.nodeAt(selection.$head.after());\n            return !!(nodeAfter && nodeAfter.type.name === \"paragraph\");\n        } else if (selection.node.type.name === \"mediaGroup\") {\n            return !(\n                selection.$head.parentOffset === selection.$anchor.parent.content.size\n            );\n        }\n    }\n    if (selection instanceof TextSelection) {\n        if (!selection.empty) {\n            return true;\n        }\n    }\n\n    return !atTheEndOfDoc(state);\n}\n\nexport function isSelectionInsideLastNodeInDocument(\n    selection: Selection,\n): boolean {\n    const docNode = selection.$anchor.node(0);\n    const rootNode = selection.$anchor.node(1);\n\n    return docNode.lastChild === rootNode;\n}\n\nexport function atTheEndOfDoc(state: EditorState): boolean {\n    const { selection, doc } = state;\n    return doc.nodeSize - selection.$to.pos - 2 === selection.$to.depth;\n}\n\nexport function atTheBeginningOfDoc(state: EditorState): boolean {\n    const { selection } = state;\n    return selection.$from.pos === selection.$from.depth;\n}\n\nexport function atTheEndOfBlock(state: EditorState): boolean {\n    const { selection } = state;\n    const { $to } = selection;\n    if (selection instanceof GapCursor) {\n        return false;\n    }\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n        return true;\n    }\n    return endPositionOfParent($to) === $to.pos + 1;\n}\n\nexport function atTheBeginningOfBlock(state: EditorState): boolean {\n    const { selection } = state;\n    const { $from } = selection;\n    if (selection instanceof GapCursor) {\n        return false;\n    }\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n        return true;\n    }\n    return startPositionOfParent($from) === $from.pos;\n}\n\nexport function startPositionOfParent(resolvedPos: ResolvedPos): number {\n    return resolvedPos.start(resolvedPos.depth);\n}\n\nexport function endPositionOfParent(resolvedPos: ResolvedPos): number {\n    return resolvedPos.end(resolvedPos.depth) + 1;\n}\n\nexport function getCursor(selection: Selection): ResolvedPos | undefined {\n    return (selection as TextSelection).$cursor || undefined;\n}\n\n/**\n * Check if a mark is allowed at the current selection / cursor based on a given state.\n * This method looks at both the currently active marks on the transaction, as well as\n * the node and marks at the current selection to determine if the given mark type is\n * allowed.\n */\nexport function isMarkTypeAllowedInCurrentSelection(\n    markType: MarkType,\n    state: EditorState,\n) {\n\n    if (!isMarkTypeAllowedInNode(markType, state)) {\n        return false;\n    }\n\n    const { empty, $cursor, ranges } = state.selection as TextSelection;\n    if (empty && !$cursor) {\n        return false;\n    }\n\n    const isCompatibleMarkType = (mark: PMMark) =>\n        isMarkTypeCompatibleWithMark(markType, mark);\n\n    // Handle any new marks in the current transaction\n    if (\n        state.tr.storedMarks &&\n        !state.tr.storedMarks.every(isCompatibleMarkType)\n    ) {\n        return false;\n    }\n\n    if ($cursor) {\n        return $cursor.marks().every(isCompatibleMarkType);\n    }\n\n    // Check every node in a selection - ensuring that it is compatible with the current mark type\n    return ranges.every(({ $from, $to }) => {\n        let allowedInActiveMarks =\n            $from.depth === 0 ? state.doc.marks.every(isCompatibleMarkType) : true;\n\n        state.doc.nodesBetween($from.pos, $to.pos, node => {\n            allowedInActiveMarks =\n                allowedInActiveMarks && node.marks.every(isCompatibleMarkType);\n        });\n\n        return allowedInActiveMarks;\n    });\n}\n\n/**\n * Step through block-nodes between $from and $to and returns false if a node is\n * found that isn\"t of the specified type\n */\nexport function isRangeOfType(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n    nodeType: NodeType,\n): boolean {\n    return (\n        getAncestorNodesBetween(doc, $from, $to).filter(\n            node => node.type !== nodeType,\n        ).length === 0\n    );\n}\n\nexport function createSliceWithContent(content: string, state: EditorState) {\n    return new Slice(Fragment.from(state.schema.text(content)), 0, 0);\n}\n\n/**\n * Determines if content inside a selection can be joined with the next block.\n * We need this check since the built-in method for \"joinDown\" will join a orderedList with bulletList.\n */\nexport function canJoinDown(\n    selection: Selection,\n    doc: any,\n    nodeType: NodeType,\n): boolean {\n    return checkNodeDown(selection, doc, node => node.type === nodeType);\n}\n\nexport function checkNodeDown(\n    selection: Selection,\n    doc: Node,\n    filter: (node: Node) => boolean,\n): boolean {\n    const res = doc.resolve(\n        selection.$to.after(findAncestorPosition(doc, selection.$to).depth),\n    );\n    return res.nodeAfter ? filter(res.nodeAfter) : false;\n}\n\nexport const setNodeSelection = (view: EditorView, pos: number) => {\n    const { state, dispatch } = view;\n\n    if (!isFinite(pos)) {\n        return;\n    }\n\n    const tr = state.tr.setSelection(NodeSelection.create(state.doc, pos));\n    dispatch(tr);\n};\n\nexport function setTextSelection(\n    view: EditorView,\n    anchor: number,\n    head?: number,\n) {\n    const { state } = view;\n    const tr = state.tr.setSelection(\n        TextSelection.create(state.doc, anchor, head),\n    );\n    view.dispatch(tr);\n}\n\n/**\n * Determines if content inside a selection can be joined with the previous block.\n * We need this check since the built-in method for \"joinUp\" will join a orderedList with bulletList.\n */\nexport function canJoinUp(\n    selection: Selection,\n    doc: any,\n    nodeType: NodeType,\n): boolean {\n    const res = doc.resolve(\n        selection.$from.before(findAncestorPosition(doc, selection.$from).depth),\n    );\n    return res.nodeBefore && res.nodeBefore.type === nodeType;\n}\n\n/**\n * Returns all top-level ancestor-nodes between $from and $to\n */\nexport function getAncestorNodesBetween(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n): Node[] {\n    const nodes = Array<Node>();\n    const maxDepth = findAncestorPosition(doc, $from).depth;\n    let current = doc.resolve($from.start(maxDepth));\n\n    while (current.pos <= $to.start($to.depth)) {\n        const depth = Math.min(current.depth, maxDepth);\n        const node = current.node(depth);\n\n        if (node) {\n            nodes.push(node);\n        }\n\n        if (depth === 0) {\n            break;\n        }\n\n        let next: ResolvedPos = doc.resolve(current.after(depth));\n        if (next.start(depth) >= doc.nodeSize - 2) {\n            break;\n        }\n\n        if (next.depth !== current.depth) {\n            next = doc.resolve(next.pos + 2);\n        }\n\n        if (next.depth) {\n            current = doc.resolve(next.start(next.depth));\n        } else {\n            current = doc.resolve(next.end(next.depth));\n        }\n    }\n\n    return nodes;\n}\n\n/**\n * Finds all \"selection-groups\" within a range. A selection group is based on ancestors.\n *\n * Example:\n * Given the following document and selection ({<} = start of selection and {>} = end)\n *  doc\n *    blockquote\n *      ul\n *        li\n *        li{<}\n *        li\n *     p\n *     p{>}\n *\n * The output will be two selection-groups. One within the ul and one with the two paragraphs.\n */\nexport function getGroupsInRange(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n    isNodeValid: (node: Node) => boolean = validateNode,\n): Array<{ $from: ResolvedPos; $to: ResolvedPos }> {\n    const groups = Array<{ $from: ResolvedPos; $to: ResolvedPos }>();\n    const commonAncestor = hasCommonAncestor(doc, $from, $to);\n    const fromAncestor = findAncestorPosition(doc, $from);\n\n    if (\n        commonAncestor ||\n        (fromAncestor.depth === 1 && isNodeValid($from.node(1)))\n    ) {\n        groups.push({ $from, $to });\n    } else {\n        let current = $from;\n\n        while (current.pos < $to.pos) {\n            let ancestorPos = findAncestorPosition(doc, current);\n            while (ancestorPos.depth > 1) {\n                ancestorPos = findAncestorPosition(doc, ancestorPos);\n            }\n\n            const endPos = doc.resolve(\n                Math.min(\n                    // should not be smaller then start position in case of an empty paragraph for example.\n                    Math.max(\n                        ancestorPos.start(ancestorPos.depth),\n                        ancestorPos.end(ancestorPos.depth) - 3,\n                    ),\n                    $to.pos,\n                ),\n            );\n\n            groups.push({\n                $from: current,\n                $to: endPos,\n            });\n\n            current = doc.resolve(Math.min(endPos.after(1) + 1, doc.nodeSize - 2));\n        }\n    }\n\n    return groups;\n}\n\n/**\n * Traverse the document until an \"ancestor\" is found. Any nestable block can be an ancestor.\n */\nexport function findAncestorPosition(doc: Node, pos: any): any {\n    const nestableBlocks = [\"blockquote\", \"bulletList\", \"orderedList\"];\n\n    if (pos.depth === 1) {\n        return pos;\n    }\n\n    let node: Node | undefined = pos.node(pos.depth);\n    let newPos = pos;\n    while (pos.depth >= 1) {\n        pos = doc.resolve(pos.before(pos.depth));\n        node = pos.node(pos.depth);\n\n        if (node && nestableBlocks.indexOf(node.type.name) !== -1) {\n            newPos = pos;\n        }\n    }\n\n    return newPos;\n}\n\n/**\n * Determine if two positions have a common ancestor.\n */\nexport function hasCommonAncestor(\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n): boolean {\n    let current;\n    let target;\n\n    if ($from.depth > $to.depth) {\n        current = findAncestorPosition(doc, $from);\n        target = findAncestorPosition(doc, $to);\n    } else {\n        current = findAncestorPosition(doc, $to);\n        target = findAncestorPosition(doc, $from);\n    }\n\n    while (current.depth > target.depth && current.depth > 1) {\n        current = findAncestorPosition(doc, current);\n    }\n\n    return current.node(current.depth) === target.node(target.depth);\n}\n\n/**\n * Takes a selection $from and $to and lift all text nodes from their parents to document-level\n */\nexport function liftSelection(\n    tr: Transaction,\n    doc: Node,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n) {\n    let startPos = $from.start($from.depth);\n    let endPos = $to.end($to.depth);\n    const target = Math.max(0, findAncestorPosition(doc, $from).depth - 1);\n\n    tr.doc.nodesBetween(startPos, endPos, (node, pos) => {\n        if (\n            node.isText || // Text node\n            (node.isTextblock && !node.textContent) // Empty paragraph\n        ) {\n            const res = tr.doc.resolve(tr.mapping.map(pos));\n            const sel = new NodeSelection(res);\n            const range = sel.$from.blockRange(sel.$to);\n\n            if (liftTarget(range as NodeRange) !== undefined) {\n                tr.lift(range, target);\n            }\n        }\n    });\n\n    startPos = tr.mapping.map(startPos);\n    endPos = tr.mapping.map(endPos);\n    endPos = tr.doc.resolve(endPos).end(tr.doc.resolve(endPos).depth); // We want to select the entire node\n\n    tr.setSelection(\n        new TextSelection(tr.doc.resolve(startPos), tr.doc.resolve(endPos)),\n    );\n\n    return {\n        tr: tr,\n        $from: tr.doc.resolve(startPos),\n        $to: tr.doc.resolve(endPos),\n    };\n}\n\n/**\n * Lift nodes in block to one level above.\n */\nexport function liftSiblingNodes(view: EditorView) {\n    const { tr } = view.state;\n    const { $from, $to } = view.state.selection;\n    const blockStart = tr.doc.resolve($from.start($from.depth - 1));\n    const blockEnd = tr.doc.resolve($to.end($to.depth - 1));\n    const range = blockStart.blockRange(blockEnd);\n    view.dispatch(tr.lift(range as NodeRange, blockStart.depth - 1));\n}\n\n/**\n * Lift sibling nodes to document-level and select them.\n */\nexport function liftAndSelectSiblingNodes(view: EditorView): Transaction {\n    const { tr } = view.state;\n    const { $from, $to } = view.state.selection;\n    const blockStart = tr.doc.resolve($from.start($from.depth - 1));\n    const blockEnd = tr.doc.resolve($to.end($to.depth - 1));\n    // TODO: [ts30] handle void and null properly\n    const range = blockStart.blockRange(blockEnd) as NodeRange;\n    tr.setSelection(new TextSelection(blockStart, blockEnd));\n    tr.lift(range as NodeRange, blockStart.depth - 1);\n    return tr;\n}\n\nexport function wrapIn(\n    nodeType: NodeType,\n    tr: Transaction,\n    $from: ResolvedPos,\n    $to: ResolvedPos,\n): Transaction {\n    const range = $from.blockRange($to) as any;\n    const wrapping = range && (findWrapping(range, nodeType) as any);\n    if (wrapping) {\n        tr = tr.wrap(range, wrapping).scrollIntoView();\n    }\n    return tr;\n}\n\n/**\n * Repeating string for multiple times\n */\nexport function stringRepeat(text: string, length: number): string {\n    let result = \"\";\n    for (let x = 0; x < length; x++) {\n        result += text;\n    }\n    return result;\n}\n\n/**\n * A replacement for `Array.from` until it becomes widely implemented.\n */\nexport function arrayFrom(obj: any): any[] {\n    return Array.prototype.slice.call(obj);\n}\n\n/**\n * Replacement for Element.closest, until it becomes widely implemented\n * Returns the ancestor element of a particular type if exists or null\n */\nexport function closestElement(\n    node: HTMLElement | null | undefined,\n    s: string,\n): HTMLElement | null {\n    return closest(node, s);\n}\n\n/*\n * From Modernizr\n * Returns the kind of transitionevent available for the element\n */\nexport function whichTransitionEvent<TransitionEventName extends string>() {\n    const el = document.createElement(\"fakeelement\");\n    const transitions: Record<string, string> = {\n        transition: \"transitionend\",\n        MozTransition: \"transitionend\",\n        OTransition: \"oTransitionEnd\",\n        WebkitTransition: \"webkitTransitionEnd\",\n    };\n\n    for (const t in transitions) {\n        if (el.style[t as keyof CSSStyleDeclaration] !== undefined) {\n            // Use a generic as the return type because TypeScript doesnt know\n            // about cross browser features, so we cast here to align to the\n            // standard Event spec and propagate the type properly to the callbacks\n            // of `addEventListener` and `removeEventListener`.\n            return transitions[t] as TransitionEventName;\n        }\n    }\n\n    return;\n}\n\n/**\n * Function will create a list of wrapper blocks present in a selection.\n */\nfunction getSelectedWrapperNodes(state: EditorState): NodeType[] {\n    const nodes: Array<NodeType> = [];\n    if (state.selection) {\n        const { $from, $to } = state.selection;\n        const {\n            blockquote,\n            panel,\n            orderedList,\n            bulletList,\n            listItem,\n            codeBlock,\n        } = state.schema.nodes;\n        state.doc.nodesBetween($from.pos, $to.pos, node => {\n            if (\n                (node.isBlock &&\n                    [blockquote, panel, orderedList, bulletList, listItem].indexOf(\n                        node.type,\n                    ) >= 0) ||\n                node.type === codeBlock\n            ) {\n                nodes.push(node.type);\n            }\n        });\n    }\n    return nodes;\n}\n\n/**\n * Function will check if changing block types: Paragraph, Heading is enabled.\n */\nexport function areBlockTypesDisabled(state: EditorState): boolean {\n    const nodesTypes: NodeType[] = getSelectedWrapperNodes(state);\n    const { panel } = state.schema.nodes;\n    return nodesTypes.filter(type => type !== panel).length > 0;\n}\n\nexport const isTemporary = (id: string): boolean => {\n    return id.indexOf(\"temporary:\") === 0;\n};\n\n\nexport const isEmptyNode = (schema: Schema) => {\n    const {\n        doc,\n        paragraph,\n        codeBlock,\n        blockquote,\n        panel,\n        heading,\n        listItem,\n        bulletList,\n        orderedList,\n        taskList,\n        taskItem,\n        decisionList,\n        decisionItem,\n        media,\n        mediaGroup,\n        mediaSingle,\n    } = schema.nodes;\n    const innerIsEmptyNode = (node: Node): boolean => {\n        switch (node.type) {\n            case media:\n            case mediaGroup:\n            case mediaSingle:\n                return false;\n            case paragraph:\n            case codeBlock:\n            case heading:\n            case taskItem:\n            case decisionItem:\n                return node.content.size === 0;\n            case blockquote:\n            case panel:\n            case listItem:\n                return (\n                    node.content.size === 2 && innerIsEmptyNode(node.content.firstChild)\n                );\n            case bulletList:\n            case orderedList:\n                return (\n                    node.content.size === 4 && innerIsEmptyNode(node.content.firstChild)\n                );\n            case taskList:\n            case decisionList:\n                return (\n                    node.content.size === 2 && innerIsEmptyNode(node.content.firstChild)\n                );\n            case doc:\n                let isEmpty = true;\n                node.content.forEach(child => {\n                    isEmpty = isEmpty && innerIsEmptyNode(child);\n                });\n                return isEmpty;\n            default:\n                return isNodeEmpty(node);\n        }\n    };\n    return innerIsEmptyNode;\n};\n\nexport const insideTable = (state: EditorState): Boolean => {\n    const { table, tableCell } = state.schema.nodes;\n\n    return hasParentNodeOfType([table, tableCell])(state.selection);\n};\n\nexport const insideTableCell = (state: EditorState) => {\n    const { tableCell, tableHeader } = state.schema.nodes;\n    return hasParentNodeOfType([tableCell, tableHeader])(state.selection);\n};\n\nexport const isElementInTableCell = (\n    element: HTMLElement | null,\n): HTMLElement | null => {\n    return closest(element, \"td\") || closest(element, \"th\");\n};\n\nexport const isLastItemMediaGroup = (node: Node): boolean => {\n    const { content } = node;\n    return !!content.lastChild && content.lastChild.type.name === \"mediaGroup\";\n};\n\nexport const isInListItem = (state: EditorState): boolean => {\n    return hasParentNodeOfType(state.schema.nodes.listItem)(state.selection);\n};\n\nexport const hasOpenEnd = (slice: Slice): boolean => {\n    return slice.openStart > 0 || slice.openEnd > 0;\n};\n\nexport function filterChildrenBetween(\n    doc: Node,\n    from: number,\n    to: number,\n    predicate: (node: Node, pos: number, parent: Node) => boolean | undefined,\n) {\n    const results = [] as { node: Node; pos: number }[];\n    doc.nodesBetween(from, to, (node, pos, parent) => {\n        if (predicate(node, pos, parent)) {\n            results.push({ node, pos });\n        }\n    });\n    return results;\n}\n\nexport function dedupe<T>(\n    list: T[] = [],\n    iteratee?: (p: T) => T[keyof T] | T,\n): T[] {\n    const transformed = iteratee ? list.map(iteratee) : list;\n\n    return transformed\n        .map((item, index, list) => (list.indexOf(item) === index ? item : null))\n        .reduce<T[]>(\n            (acc, item, index) => (!!item ? acc.concat(list[index]) : acc),\n            [],\n        );\n}\n\nexport const isTextSelection = (\n    selection: Selection,\n): selection is TextSelection => selection instanceof TextSelection;\n\n/** Helper type for single arg function */\ntype Func<A, B> = (a: A) => B;\ntype FuncN<A extends any[], B> = (...args: A) => B;\n\n/**\n * Compose 1 to n functions.\n * @param func first function\n * @param funcs additional functions\n */\nexport function compose<\n    F1 extends Func<any, any>,\n    FN extends Array<Func<any, any>>,\n    R extends FN extends []\n        ? F1\n        : FN extends [Func<infer A, any>]\n            ? (a: A) => ReturnType<F1>\n            : FN extends [any, Func<infer A, any>]\n                ? (a: A) => ReturnType<F1>\n                : FN extends [any, any, Func<infer A, any>]\n                    ? (a: A) => ReturnType<F1>\n                    : FN extends [any, any, any, Func<infer A, any>]\n                        ? (a: A) => ReturnType<F1>\n                        : FN extends [any, any, any, any, Func<infer A, any>]\n                            ? (a: A) => ReturnType<F1>\n                            : Func<any, ReturnType<F1>> // Doubtful we\"d ever want to pipe this many functions, but in the off chance someone does, we can still infer the return type\n    >(func: F1, ...funcs: FN): R {\n    const allFuncs = [func, ...funcs];\n    return function composed(raw: any) {\n        return allFuncs.reduceRight((memo, func) => func(memo), raw);\n    } as R;\n}\n\nexport function pipe(): <R>(a: R) => R;\n\nexport function pipe<F extends Function>(f: F): F;\n\n// one function\nexport function pipe<F1 extends FuncN<any, any>>(\n    f1: F1,\n): (...args: Parameters<F1>) => ReturnType<F1>;\n\n// two function\nexport function pipe<\n    F1 extends FuncN<any, any>,\n    F2 extends Func<ReturnType<F1>, any>\n    >(f1: F1, f2: F2): (...args: Parameters<F1>) => ReturnType<F2>;\n\n// three function\nexport function pipe<\n    F1 extends FuncN<any, any>,\n    F2 extends Func<ReturnType<F1>, any>,\n    F3 extends Func<ReturnType<F2>, any>\n    >(f1: F1, f2: F2, f3: F3): (...args: Parameters<F1>) => ReturnType<F3>;\n// If needed add more than 3 function\n// Generic\nexport function pipe<\n    F1 extends FuncN<any, any>,\n    F2 extends Func<ReturnType<F1>, any>,\n    F3 extends Func<ReturnType<F2>, any>,\n    FN extends Array<Func<any, any>>\n    >(f1: F1, f2: F2, f3: F3, ...fn: FN): (...args: Parameters<F1>) => any;\n\n// rest\nexport function pipe(...fns: Function[]) {\n    if (fns.length === 0) {\n        return (a: any) => a;\n    }\n\n    if (fns.length === 1) {\n        return fns[0];\n    }\n\n    return fns.reduce((prevFn, nextFn) => (...args: any[]) =>\n        nextFn(prevFn(...args)),\n    );\n}\n\nexport const normaliseNestedLayout = (state: EditorState, node: Node) => {\n    if (state.selection.$from.depth > 1) {\n        if (node.attrs.layout && node.attrs.layout !== \"default\") {\n            return node.type.createChecked(\n                {\n                    ...node.attrs,\n                    layout: \"default\",\n                },\n                node.content,\n                node.marks,\n            );\n        }\n\n        // If its a breakout layout, we can remove the mark\n        // Since default isn\"t a valid breakout mode.\n        const breakoutMark: Mark = state.schema.marks.breakout;\n        if (breakoutMark && breakoutMark.isInSet(node.marks)) {\n            const newMarks = breakoutMark.removeFromSet(node.marks);\n            return node.type.createChecked(node.attrs, node.content, newMarks);\n        }\n    }\n\n    return node;\n};\n","// https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js#L90\n// Keep going left up the tree, without going across isolating boundaries, until we\n// can go along the tree at that same level\n//\n// You can think of this as, if you could construct each document like we do in the tests,\n// return the position of the first ) backwards from the current selection.\nimport {ResolvedPos} from \"prosemirror-model\";\n\nexport function findCutBefore($pos: ResolvedPos): ResolvedPos | null {\n\n    // parent is non-isolating, so we can look across this boundary\n    if (!$pos.parent.type.spec.isolating) {\n        // search up the tree from the pos\"s *parent*\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            // starting from the inner most node\"s parent, find out\n            // if we\"re not its first child\n            if ($pos.index(i) > 0) {\n                return $pos.doc.resolve($pos.before(i + 1));\n            }\n\n            if ($pos.node(i).type.spec.isolating) {\n                break;\n            }\n        }\n    }\n\n    return null;\n}\n","import * as baseCommand from \"prosemirror-commands\";\nimport {GapCursor} from \"prosemirror-gapcursor\";\nimport {Fragment, Node, NodeRange, NodeType, ResolvedPos, Slice} from \"prosemirror-model\";\nimport * as baseListCommand from \"prosemirror-schema-list\";\nimport {EditorState, NodeSelection, TextSelection, Transaction} from \"prosemirror-state\";\nimport {liftTarget, ReplaceAroundStep} from \"prosemirror-transform\";\nimport {findPositionOfNodeBefore, hasParentNodeOfType} from \"prosemirror-utils\";\nimport {EditorView} from \"prosemirror-view\";\nimport {Command} from \"./command\";\nimport {filter} from \"./commands/filter\";\nimport {isEmptySelectionAtStart} from \"./commands/is-empty-selection-at-start\";\nimport {isFirstChildOfParent} from \"./commands/is-first-child-of-parent\";\nimport {hasVisibleContent, isNodeEmpty} from \"./document-utils\";\nimport {liftFollowingList} from \"./list/transforms/lift-following-list\";\nimport {liftSelectionList} from \"./list/transforms/lift-selection-list\";\nimport {sanitizeSelectionMarks} from \"./mark-utils\";\nimport {compose, isRangeOfType} from \"./utils\";\nimport {findCutBefore} from \"./utils/find-cut-before\";\n\nconst maxIndentation = 5;\n\nconst deletePreviousEmptyListItem: Command = (state, dispatch) => {\n    const { $from } = state.selection;\n    const { listItem } = state.schema.nodes;\n\n    const $cut = findCutBefore($from);\n    if (!$cut || !$cut.nodeBefore || !($cut.nodeBefore.type === listItem)) {\n        return false;\n    }\n\n    const previousListItemEmpty = $cut.nodeBefore.childCount === 1 && $cut.nodeBefore.firstChild && $cut.nodeBefore.firstChild.nodeSize <= 2;\n\n    if (previousListItemEmpty) {\n        const { tr } = state;\n\n        if (dispatch) {\n            dispatch(\n                tr\n                    .delete($cut.pos - $cut.nodeBefore.nodeSize, $from.pos)\n                    .scrollIntoView(),\n            );\n        }\n        return true;\n    }\n\n    return false;\n};\n\nconst joinToPreviousListItem: Command = (state, dispatch) => {\n    const { $from } = state.selection;\n    const {\n        paragraph,\n        listItem,\n        codeBlock,\n        bulletList,\n        orderedList,\n    } = state.schema.nodes;\n    const isGapCursorShown = state.selection instanceof GapCursor;\n    const $cutPos = isGapCursorShown ? state.doc.resolve($from.pos + 1) : $from;\n    const $cut = findCutBefore($cutPos);\n    if (!$cut) {\n        return false;\n    }\n\n    // see if the containing node is a list\n    if (\n        $cut.nodeBefore &&\n        [bulletList, orderedList].indexOf($cut.nodeBefore.type) > -1\n    ) {\n        // and the node after this is a paragraph or a codeBlock\n        if (\n            $cut.nodeAfter &&\n            ($cut.nodeAfter.type === paragraph || $cut.nodeAfter.type === codeBlock)\n        ) {\n            // find the nearest paragraph that precedes this node\n            let $lastNode = $cut.doc.resolve($cut.pos - 1);\n\n            while ($lastNode.parent.type !== paragraph) {\n                $lastNode = state.doc.resolve($lastNode.pos - 1);\n            }\n\n            let { tr } = state;\n            if (isGapCursorShown) {\n                const nodeBeforePos = findPositionOfNodeBefore(tr.selection);\n                if (typeof nodeBeforePos !== \"number\") {\n                    return false;\n                }\n                // append the codeblock to the list node\n                const list = $cut.nodeBefore.copy(\n                    $cut.nodeBefore.content.append(\n                        Fragment.from(listItem.createChecked({}, $cut.nodeAfter)),\n                    ),\n                );\n                tr.replaceWith(\n                    nodeBeforePos,\n                    $from.pos + $cut.nodeAfter.nodeSize,\n                    list,\n                );\n            } else {\n                // take the text content of the paragraph and insert after the paragraph up until before the the cut\n                tr = state.tr.step(\n                    new ReplaceAroundStep(\n                        $lastNode.pos,\n                        $cut.pos + $cut.nodeAfter.nodeSize,\n                        $cut.pos + 1,\n                        $cut.pos + $cut.nodeAfter.nodeSize - 1,\n                        state.tr.doc.slice($lastNode.pos, $cut.pos),\n                        0,\n                        true,\n                    ),\n                );\n            }\n\n            // find out if there\"s now another list following and join them\n            // as in, [list, p, list] => [list with p, list], and we want [joined list]\n            const $postCut = tr.doc.resolve(\n                tr.mapping.map($cut.pos + $cut.nodeAfter.nodeSize),\n            );\n            if (\n                $postCut.nodeBefore &&\n                $postCut.nodeAfter &&\n                $postCut.nodeBefore.type === $postCut.nodeAfter.type &&\n                [bulletList, orderedList].indexOf($postCut.nodeBefore.type) > -1\n            ) {\n                tr = tr.join($postCut.pos);\n            }\n\n            if (dispatch) {\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n\n    return false;\n};\n\nconst isInsideListItem = (state: EditorState): boolean => {\n    const { $from } = state.selection;\n    const { listItem, paragraph } = state.schema.nodes;\n\n    if (state.selection instanceof GapCursor) {\n        return $from.parent.type === listItem;\n    }\n\n    return (\n        hasParentNodeOfType(listItem)(state.selection) &&\n        $from.parent.type === paragraph\n    );\n};\n\nconst canToJoinToPreviousListItem = (state: EditorState): boolean => {\n    const { $from } = state.selection;\n    const { bulletList, orderedList } = state.schema.nodes;\n\n    const $before = state.doc.resolve($from.pos - 1);\n    let nodeBefore = $before ? $before.nodeBefore : null;\n\n    if (state.selection instanceof GapCursor) {\n        nodeBefore = $from.nodeBefore;\n    }\n\n    return (\n        !!nodeBefore && [bulletList, orderedList].indexOf(nodeBefore.type) > -1\n    );\n};\n\nconst canOutdent = (state: EditorState): boolean => {\n    const { parent } = state.selection.$from;\n    const { listItem, paragraph } = state.schema.nodes;\n\n    if (state.selection instanceof GapCursor) {\n        return parent.type === listItem;\n    }\n\n    return (\n        parent.type === paragraph && hasParentNodeOfType(listItem)(state.selection)\n    );\n};\n\nexport const enterKeyCommand: Command = (state, dispatch): boolean => {\n    const { selection } = state;\n    if (selection.empty) {\n        const { $from } = selection;\n        const { listItem, codeBlock } = state.schema.nodes;\n        const node = $from.node($from.depth);\n        const wrapper = $from.node($from.depth - 1);\n\n        if (wrapper && wrapper.type === listItem) {\n            /** Check if the wrapper has any visible content */\n            const wrapperHasContent = hasVisibleContent(wrapper);\n            if (isNodeEmpty(node) && !wrapperHasContent) {\n                return outdentList()(state, dispatch);\n            } else if (!hasParentNodeOfType(codeBlock)(selection)) {\n                return splitListItem(listItem)(state, dispatch);\n            }\n        }\n    }\n    return false;\n};\n\nexport const backspaceKeyCommand = baseCommand.chainCommands(\n    // if we\"re at the start of a list item, we need to either backspace\n    // directly to an empty list item above, or outdent this node\n    filter(\n        [\n            isEmptySelectionAtStart,\n\n            // list items might have multiple paragraphs; only do this at the first one\n            isFirstChildOfParent,\n            canOutdent,\n        ],\n        baseCommand.chainCommands(deletePreviousEmptyListItem, outdentList()),\n    ),\n\n    // if we\"re just inside a paragraph node (or gapcursor is shown) and backspace, then try to join\n    // the text to the previous list item, if one exists\n    filter(\n        [isEmptySelectionAtStart, canToJoinToPreviousListItem],\n        joinToPreviousListItem,\n    ),\n);\n\n/**\n * Implemetation taken and modified for our needs from PM\n * @param itemType Node\n * Splits the list items, specific implementation take from PM\n */\nfunction splitListItem(itemType: NodeType): Command {\n    return function(state, dispatch) {\n        const ref = state.selection as NodeSelection;\n        const $from = ref.$from;\n        const $to = ref.$to;\n        const node = ref.node;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        const grandParent = $from.node(-1);\n        if (grandParent.type !== itemType) {\n            return false;\n        }\n        /** --> The following line changed from the original PM implementation to allow list additions with multiple paragraphs */\n        if (\n            (grandParent.content as any).content.length <= 1 &&\n            $from.parent.content.size === 0 &&\n            !(grandParent.content.size === 0)\n        ) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if (\n                $from.depth === 2 ||\n                $from.node(-3).type !== itemType ||\n                $from.index(-2) !== $from.node(-2).childCount - 1\n            ) {\n                return false;\n            }\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                const keepItem = $from.index(-1) > 0;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (\n                    let d = $from.depth - (keepItem ? 1 : 2);\n                    d >= $from.depth - 3;\n                    d--\n                ) {\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                }\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                const tr$1 = state.tr.replace(\n                    $from.before(keepItem ? undefined : -1),\n                    $from.after(-3),\n                    new Slice(wrap, keepItem ? 3 : 2, 2),\n                );\n                tr$1.setSelection(\n                    (state.selection.constructor as any).near(\n                        tr$1.doc.resolve($from.pos + (keepItem ? 3 : 2)),\n                    ),\n                );\n                dispatch(tr$1.scrollIntoView());\n            }\n            return true;\n        }\n        const nextType =\n            $to.pos === $from.end()\n                ? grandParent.contentMatchAt(0).defaultType\n                : undefined;\n        const tr = state.tr.delete($from.pos, $to.pos);\n        const types = nextType && [undefined, { type: nextType }];\n\n        if (dispatch) {\n            dispatch(tr.split($from.pos, 2, types as any).scrollIntoView());\n        }\n        return true;\n    };\n}\n\n/**\n * Merge closest bullet list blocks into one\n */\nfunction mergeLists(listItem: NodeType, range: NodeRange) {\n    return (command: Command): Command => {\n        return (state, dispatch) =>\n            command(state, tr => {\n                /* we now need to handle the case that we lifted a sublist out,\n                 * and any listItems at the current level get shifted out to\n                 * their own new list; e.g.:\n                 *\n                 * unorderedList\n                 *  listItem(A)\n                 *  listItem\n                 *    unorderedList\n                 *      listItem(B)\n                 *  listItem(C)\n                 *\n                 * becomes, after unindenting the first, top level listItem, A:\n                 *\n                 * content of A\n                 * unorderedList\n                 *  listItem(B)\n                 * unorderedList\n                 *  listItem(C)\n                 *\n                 * so, we try to merge these two lists if they\"re of the same type, to give:\n                 *\n                 * content of A\n                 * unorderedList\n                 *  listItem(B)\n                 *  listItem(C)\n                 */\n\n                const $start: ResolvedPos = state.doc.resolve(range.start);\n                const $end: ResolvedPos = state.doc.resolve(range.end);\n                const $join = tr.doc.resolve(tr.mapping.map(range.end - 1));\n\n                if (\n                    $join.nodeBefore &&\n                    $join.nodeAfter &&\n                    $join.nodeBefore.type === $join.nodeAfter.type\n                ) {\n                    if (\n                        $end.nodeAfter &&\n                        $end.nodeAfter.type === listItem &&\n                        $end.parent.type === $start.parent.type\n                    ) {\n                        tr.join($join.pos);\n                    }\n                }\n\n                if (dispatch) {\n                    dispatch(tr.scrollIntoView());\n                }\n            });\n    };\n}\n\nexport function outdentList(): Command {\n    return function(state, dispatch) {\n        const { listItem } = state.schema.nodes;\n        const { $from, $to } = state.selection;\n        if (isInsideListItem(state)) {\n            // if we\"re backspacing at the start of a list item, unindent it\n            // take the the range of nodes we might be lifting\n\n            // the predicate is for when you\"re backspacing a top level list item:\n            // we don\"t want to go up past the doc node, otherwise the range\n            // to clear will include everything\n            const range = $from.blockRange(\n                $to,\n                node => node.childCount > 0 && node.firstChild && node.firstChild.type === listItem,\n            );\n\n            if (!range) {\n                return false;\n            }\n            return compose(\n                mergeLists(listItem, range), // 2. Check if I need to merge nearest list\n                baseListCommand.liftListItem, // 1. First lift list item\n            )(listItem)(state, dispatch);\n        }\n\n        return false;\n    };\n}\n\n/**\n * Check if we can sink the list.\n *\n * @returns true if we can sink the list, false if we reach the max indentation level\n */\nfunction canSink(initialIndentationLevel: number, state: EditorState): boolean {\n    /*\n        - Keep going forward in document until indentation of the node is < than the initial\n        - If indentation is EVER > max indentation, return true and don\"t sink the list\n        */\n    let currentIndentationLevel: number;\n    let currentPos = state.tr.selection.$to.pos;\n    do {\n        const resolvedPos = state.doc.resolve(currentPos);\n        currentIndentationLevel = numberNestedLists(\n            resolvedPos,\n            state.schema.nodes,\n        );\n        if (currentIndentationLevel > maxIndentation) {\n            // Cancel sink list.\n            // If current indentation less than the initial, it won\"t be\n            // larger than the max, and the loop will terminate at end of this iteration\n            return false;\n        }\n        currentPos++;\n    } while (currentIndentationLevel >= initialIndentationLevel);\n\n    return true;\n}\n\nexport function indentList(): Command {\n    return function(state, dispatch) {\n        const { listItem } = state.schema.nodes;\n        if (isInsideListItem(state)) {\n            // Record initial list indentation\n            const initialIndentationLevel = numberNestedLists(\n                state.selection.$from,\n                state.schema.nodes,\n            );\n\n            if (canSink(initialIndentationLevel, state)) {\n                compose(\n                    baseListCommand.sinkListItem,\n                )(listItem)(state, dispatch);\n            }\n            return true;\n        }\n        return false;\n    };\n}\n\nexport function liftListItems(): Command {\n    return function(state, dispatch) {\n        const { tr } = state;\n        const { $from, $to } = state.selection;\n\n        tr.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            // Following condition will ensure that block types paragraph, heading, codeBlock, blockquote, panel are lifted.\n            // isTextblock is true for paragraph, heading, codeBlock.\n            if (\n                node.isTextblock ||\n                node.type.name === \"blockquote\" ||\n                node.type.name === \"panel\"\n            ) {\n                const sel = new NodeSelection(tr.doc.resolve(tr.mapping.map(pos)));\n                const range = sel.$from.blockRange(sel.$to);\n\n                if (!range || sel.$from.parent.type !== state.schema.nodes.listItem) {\n                    return false;\n                }\n\n                const target = range && liftTarget(range);\n\n                if (target === undefined || target === null) {\n                    return false;\n                }\n\n                tr.lift(range, target);\n            }\n            return;\n        });\n\n        if (dispatch) {\n            dispatch(tr);\n        }\n\n        return true;\n    };\n}\n\n/**\n * Sometimes a selection in the editor can be slightly offset, for example:\n * it\"s possible for a selection to start or end at an empty node at the very end of\n * a line. This isn\"t obvious by looking at the editor and it\"s likely not what the\n * user intended - so we need to adjust the selection a bit in scenarios like that.\n */\nexport function adjustSelectionInList(\n    doc: Node,\n    selection: TextSelection,\n): TextSelection {\n    const { $from, $to } = selection;\n\n    const isSameLine = $from.pos === $to.pos;\n\n    let startPos = $from.pos;\n    const endPos = $to.pos;\n\n    if (isSameLine && startPos === doc.nodeSize - 3) {\n        // Line is empty, don\"t do anything\n        return selection;\n    }\n\n    // Selection started at the very beginning of a line and therefor points to the previous line.\n    if ($from.nodeBefore && !isSameLine) {\n        startPos++;\n        let node = doc.nodeAt(startPos);\n        while (!node || (node && !node.isText)) {\n            startPos++;\n            node = doc.nodeAt(startPos);\n        }\n    }\n\n    if (endPos === startPos) {\n        return new TextSelection(doc.resolve(startPos));\n    }\n\n    return new TextSelection(doc.resolve(startPos), doc.resolve(endPos));\n}\n\n// Get the depth of the nearest ancestor list\nexport const rootListDepth = (\n    pos: ResolvedPos,\n    nodes: Record<string, NodeType>,\n) => {\n    const { bulletList, orderedList, listItem } = nodes;\n    let depth;\n    for (let i = pos.depth - 1; i > 0; i--) {\n        const node = pos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            depth = i;\n        }\n        if (\n            node.type !== bulletList &&\n            node.type !== orderedList &&\n            node.type !== listItem\n        ) {\n            break;\n        }\n    }\n    return depth;\n};\n\n// Returns the number of nested lists that are ancestors of the given selection\nexport const numberNestedLists = (\n    resolvedPos: ResolvedPos,\n    nodes: Record<string, NodeType>,\n) => {\n    const { bulletList, orderedList } = nodes;\n    let count = 0;\n    for (let i = resolvedPos.depth - 1; i > 0; i--) {\n        const node = resolvedPos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            count += 1;\n        }\n    }\n    return count;\n};\n\nexport const toggleList = (\n    state: EditorState,\n    dispatch: (tr: Transaction) => void,\n    view: EditorView,\n    listType: \"bulletList\" | \"orderedList\",\n): boolean => {\n    const { selection } = state;\n    const fromNode = selection.$from.node(selection.$from.depth - 2);\n    const endNode = selection.$to.node(selection.$to.depth - 2);\n    if (\n        !fromNode ||\n        fromNode.type.name !== listType ||\n        (!endNode || endNode.type.name !== listType)\n    ) {\n        return toggleListCommand(listType)(state, dispatch, view);\n    } else {\n        const depth = rootListDepth(selection.$to, state.schema.nodes);\n        let tr = liftFollowingList(\n            state,\n            selection.$to.pos,\n            selection.$to.end(depth),\n            depth || 0,\n            state.tr,\n        );\n        tr = liftSelectionList(state, tr);\n        dispatch(tr);\n        return true;\n    }\n};\n\n/**\n * Check of is selection is inside a list of the specified type\n */\nexport function isInsideList(\n    state: EditorState,\n    listType: \"bulletList\" | \"orderedList\",\n) {\n    const { $from } = state.selection;\n    const parent = $from.node(-2);\n    const grandgrandParent = $from.node(-3);\n\n    return (\n        (parent && parent.type === state.schema.nodes[listType]) ||\n        (grandgrandParent && grandgrandParent.type === state.schema.nodes[listType])\n    );\n}\n\nexport function toggleListCommand(\n    listType: \"bulletList\" | \"orderedList\",\n): Command {\n    return function(state, dispatch, view) {\n        if (dispatch) {\n            dispatch(\n                state.tr.setSelection(\n                    adjustSelectionInList(state.doc, state.selection as TextSelection),\n                ),\n            );\n        }\n\n        if (!view) {\n            return false;\n        }\n\n        state = view.state;\n\n        const { $from, $to } = state.selection;\n        const isRangeOfSingleType = isRangeOfType(\n            state.doc,\n            $from,\n            $to,\n            state.schema.nodes[listType],\n        );\n\n        if (isInsideList(state, listType) && isRangeOfSingleType) {\n            // Untoggles list\n            return liftListItems()(state, dispatch);\n        } else {\n            // Converts list type e.g. bullet_list -> ordered_list if needed\n            if (!isRangeOfSingleType) {\n                liftListItems()(state, dispatch);\n                state = view.state;\n            }\n\n            // Remove any invalid marks that are not supported\n            const tr = sanitizeSelectionMarks(state);\n            if (tr) {\n                if (dispatch) {\n                    dispatch(tr);\n                }\n                state = view.state;\n            }\n            // Wraps selection in list\n            return wrapInList(state.schema.nodes[listType])(state, dispatch);\n        }\n    };\n}\n\nexport function toggleBulletList(view: EditorView) {\n    return toggleList(view.state, view.dispatch, view, \"bulletList\");\n}\n\nexport function toggleOrderedList(view: EditorView) {\n    return toggleList(view.state, view.dispatch, view, \"orderedList\");\n}\n\nexport function wrapInList(nodeType: NodeType): Command {\n    return baseCommand.autoJoin(\n        baseListCommand.wrapInList(nodeType),\n        (before, after) => before.type === after.type && before.type === nodeType,\n    );\n}\n","import {GapCursor} from \"prosemirror-gapcursor\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport const isFirstChildOfParent = (state: EditorState): boolean => {\n    const {$from} = state.selection;\n    return $from.depth > 1\n        ? (state.selection instanceof GapCursor &&\n        $from.parentOffset === 0) ||\n        $from.index($from.depth - 1) === 0\n        : true;\n};\n","import {EditorState, Transaction} from \"prosemirror-state\";\nimport {getListLiftTarget} from \"../utils/get-list-lift-target\";\n\n// The function will list paragraphs in selection out to level 1 below root list.\nexport function liftSelectionList(\n    state: EditorState,\n    tr: Transaction,\n): Transaction {\n    const {from, to} = state.selection;\n    const {paragraph} = state.schema.nodes;\n    const listCol: any[] = [];\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.type === paragraph) {\n            listCol.push({node, pos});\n        }\n    });\n    for (let i = listCol.length - 1; i >= 0; i--) {\n        const paragraph = listCol[i];\n        const start = tr.doc.resolve(tr.mapping.map(paragraph.pos));\n        if (start.depth > 0) {\n            let end;\n            if (paragraph.node.textContent && paragraph.node.textContent.length > 0) {\n                end = tr.doc.resolve(\n                    tr.mapping.map(paragraph.pos + paragraph.node.textContent.length),\n                );\n            } else {\n                end = tr.doc.resolve(tr.mapping.map(paragraph.pos + 1));\n            }\n            const range = start.blockRange(end);\n            if (range) {\n                tr.lift(range, getListLiftTarget(state.schema, start));\n            }\n        }\n    }\n    return tr;\n}\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {HtmlEditor} from \"./editor\";\nimport {Command} from \"./prosemirror/command\";\nimport {indentList, outdentList, toggleList} from \"./prosemirror/list-commands\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findParentNode} from \"prosemirror-utils\";\n\n@Component({\n    styles: [`\n        :host { user-select: none; }\n        :host ion-list { margin: 0px; padding: 0px; }\n        :host ion-item:last-child { --border-width: 0px; }\n        :host ion-item-divider { --background: transparent; font-size: small }\n        :host ion-item-divider ion-label { margin-top: 20px; opacity: 0.8; }\n    `],\n    template: `\n        <ion-list lines=\"full\">\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleList('bulletList')\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Bulleted list\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeUnnumberedList\"></ion-icon>\n                <ion-icon src=\"assets/html-editor/list-bulleted.svg\" slot=\"start\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleList('orderedList')\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Numbered list\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeNumberedList\"></ion-icon>\n                <ion-icon src=\"assets/html-editor/list-numbered.svg\" slot=\"start\"></ion-icon>\n            </ion-item>\n\n            <ng-template [ngIf]=\"activeUnnumberedList || activeNumberedList\">\n\n                <ion-item-divider>\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Indent\" | intlMessage}}</ion-label>\n                </ion-item-divider>\n\n                <ion-item button=\"true\" detail=\"false\" (click)=\"level(-1)\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Decrease indent\" | intlMessage}}</ion-label>\n                    <ion-icon src=\"assets/html-editor/indent-decrease.svg\" slot=\"start\"></ion-icon>\n                </ion-item>\n\n                <ion-item button=\"true\" detail=\"false\" (click)=\"level(1)\">\n                    <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/Increase indent\" | intlMessage}}</ion-label>\n                    <ion-icon src=\"assets/html-editor/indent-increase.svg\" slot=\"start\"></ion-icon>\n                </ion-item>\n\n            </ng-template>\n\n        </ion-list>\n    `\n})\nexport class ListMenu implements OnInit {\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    @Input()\n    private editor: HtmlEditor;\n\n    activeUnnumberedList: boolean;\n    activeNumberedList: boolean;\n\n    level(level: number) {\n\n        const command: Command = level < 0 ? outdentList() : indentList();\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    toggleList(type: \"bulletList\" | \"orderedList\") {\n        toggleList(this.editor.state, (tr) => this.editor.view.dispatch(tr), this.editor.view, type);\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n        this.activeUnnumberedList = !!findParentNode(predicate => predicate.hasMarkup(schema.nodes.bulletList))(this.editor.state.selection);\n        this.activeNumberedList = !!findParentNode(predicate => predicate.hasMarkup(schema.nodes.orderedList))(this.editor.state.selection);\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {MessageRef} from \"@co.mmons/js-intl\";\n\nexport class FontSize {\n\n    private static _sizes: FontSize[] = [];\n\n    static sizes() {\n        return FontSize._sizes.slice();\n    }\n\n    static readonly small = new FontSize(\"small\");\n    static readonly large = new FontSize(\"large\");\n\n    private constructor(public readonly size: string) {\n\n        FontSize._sizes.push(this);\n\n        this.label = new MessageRef(\"@co.mmons/ionic-extensions/html-editor\", \"textMenu/fontSize/\" + size.toUpperCase()[0] + size.substring(1));\n    }\n\n    readonly label: MessageRef;\n}\n","import {shallowEqual} from \"fast-equals\";\nimport {MarkType, Node} from \"prosemirror-model\";\nimport {Command} from \"../command\";\n\nfunction markApplies(doc: Node, from: number, to: number, type: MarkType) {\n\n    let applies = false;\n\n    doc.nodesBetween(from, to, (node, pos, parent) => {\n\n        if (applies) {\n            return false;\n        }\n\n        applies = node.isInline && parent.type.allowsMarkType(type);\n    });\n\n    return applies;\n}\n\n// return true iff all nodes in range have the mark with the same attrs\nfunction rangeHasMark(doc, from, to, type, attrs) {\n\n    let hasMark = null;\n\n    doc.nodesBetween(from, to, node => {\n\n        for (let i = 0; i < node.marks.length; i++) {\n            const markMatch = node.marks[i].type === type && (!attrs || shallowEqual(node.marks[i].attrs, attrs));\n            hasMark = (markMatch && (hasMark === null || hasMark === true));\n        }\n\n        return hasMark;\n    });\n\n    return !!hasMark;\n}\n\nexport function toggleInlineMark(markType: MarkType, attrs?: {[key: string]: any}): Command {\n\n    return function(state, dispatch) {\n\n        const { empty, from, to, $from } = state.selection;\n\n        if (!markApplies(state.doc, from, to, markType)) {\n            console.log(\"not applies\");\n            return false;\n        }\n\n        if (dispatch) {\n\n            if (empty) {\n\n                const markInSet = markType.isInSet(state.storedMarks || $from.marks());\n\n                if (markInSet && (!attrs || shallowEqual(markInSet.attrs, attrs))) {\n                    dispatch(state.tr.removeStoredMark(markType));\n                } else {\n                    dispatch(state.tr.addStoredMark(markType.create(attrs)));\n                }\n\n            } else {\n\n                if (rangeHasMark(state.doc, from, to, markType, attrs)) {\n                    dispatch(state.tr.removeMark(from, to, markType).scrollIntoView());\n                } else {\n                    dispatch(state.tr.addMark(from, to, markType.create(attrs)).scrollIntoView());\n                }\n            }\n        }\n\n        return true;\n    };\n}\n\n","import {Mark, MarkType, NodeType} from \"prosemirror-model\";\nimport {EditorState, NodeSelection} from \"prosemirror-state\";\n\nexport function isActive(state: EditorState, nodeType: NodeType, attrs?: {[key: string]: any}, marks?: Array<Mark<any>>) {\n\n    const selection = state.selection;\n\n    if (selection instanceof NodeSelection && selection.node) {\n        return selection.node.hasMarkup(nodeType, attrs, marks);\n    }\n\n    return selection.to <= selection.$from.end() && selection.$from.parent.hasMarkup(nodeType, attrs, marks);\n}\n\nexport function isMarkActive(state: EditorState, type: MarkType) {\n    const {from, $from, to, empty} = state.selection;\n\n    if (empty) {\n        return !!(type.isInSet(state.storedMarks || $from.marks()));\n    } else {\n        return state.doc.rangeHasMark(from, to, type);\n    }\n}\n\nexport function anyMarkActive(state: EditorState, types: MarkType[]) {\n\n    const {from, $from, to, empty} = state.selection;\n\n    if (empty) {\n\n        for (const type of types) {\n            if (type.isInSet(state.storedMarks || $from.marks())) {\n                return true;\n            }\n        }\n\n    } else {\n\n        for (const type of types) {\n            if (state.doc.rangeHasMark(from, to, type)) {\n                return true;\n            }\n        }\n\n    }\n\n    return false;\n}\n","import {Component, Input, OnInit} from \"@angular/core\";\nimport {PopoverController} from \"@ionic/angular\";\nimport {toggleMark} from \"prosemirror-commands\";\nimport {HtmlEditor} from \"./editor\";\nimport {FontSize} from \"./font-sizes\";\nimport {Command} from \"./prosemirror/command\";\nimport {toggleInlineMark} from \"./prosemirror/commands/toogle-inline-mark\";\nimport {isMarkActive} from \"./prosemirror/is-active\";\nimport {schema} from \"./prosemirror/schema\";\nimport {findMarksInSelection} from \"./prosemirror/utils/find-marks-in-selection\";\n\n@Component({\n    styles: [`\n        :host { user-select: none; }\n        :host ion-list { margin: 0px; padding: 0px; }\n        :host ion-item:last-child { --border-width: 0px; }\n        :host ion-item-divider { --background: transparent; font-size: small }\n        :host ion-item-divider ion-label { margin-top: 20px; opacity: 0.8; }\n    `],\n    template: `\n        <ion-list lines=\"full\">\n            \n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggle('bold')\">\n                <ion-label style=\"font-weight: bold\">{{\"@co.mmons/ionic-extensions/html-editor#textMenu/Bold\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"boldActivated\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggle('italic')\">\n                <ion-label style=\"font-style: italic\">{{\"@co.mmons/ionic-extensions/html-editor#textMenu/Italic\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"italicActivated\"></ion-icon>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggle('underline')\">\n                <ion-label style=\"text-decoration: underline\">{{\"@co.mmons/ionic-extensions/html-editor#textMenu/Underline\" | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"underlineActivated\"></ion-icon>\n            </ion-item>\n            \n            <ion-item-divider>\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#textMenu/fontSize/Text size\" | intlMessage}}</ion-label>\n            </ion-item-divider>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"resetFontSize()\" *ngIf=\"activeFontSize\">\n                <ion-label>{{\"@co.mmons/ionic-extensions/html-editor#textMenu/fontSize/Default\" | intlMessage}}</ion-label>\n            </ion-item>\n\n            <ion-item button=\"true\" detail=\"false\" (click)=\"toggleFontSize(fontSize)\" *ngFor=\"let fontSize of FontSize.sizes()\">\n                <ion-label [style.fontSize]=\"fontSize.size\">{{fontSize.label | intlMessage}}</ion-label>\n                <ion-icon name=\"checkmark\" slot=\"end\" *ngIf=\"activeFontSize === fontSize\"></ion-icon>\n            </ion-item>\n\n        </ion-list>\n    `\n})\nexport class TextFormatMenu implements OnInit {\n\n    readonly FontSize = FontSize;\n\n    constructor(private popoverController: PopoverController) {\n    }\n\n    @Input()\n    editor: HtmlEditor;\n\n    boldActivated: boolean;\n\n    italicActivated: boolean;\n\n    underlineActivated: boolean;\n\n    activeFontSize: FontSize;\n\n\n    toggle(name: string) {\n\n        let command: Command;\n\n        if (name === \"bold\") {\n            command = toggleMark(schema.marks.strong);\n        } else if (name === \"italic\") {\n            command = toggleMark(schema.marks.em);\n        } else if (name === \"underline\") {\n            command = toggleMark(schema.marks.underline);\n        }\n\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    resetFontSize() {\n        toggleMark(schema.marks.fontSize)(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        this.popoverController.dismiss();\n    }\n\n    toggleFontSize(size: FontSize) {\n\n        const command = toggleInlineMark(schema.marks.fontSize, {fontSize: size.size});\n        if (command(this.editor.state)) {\n            command(this.editor.state, (tr) => this.editor.view.dispatch(tr));\n        }\n\n        this.popoverController.dismiss();\n    }\n\n    ngOnInit() {\n        this.boldActivated = isMarkActive(this.editor.state, schema.marks.strong);\n        this.italicActivated = isMarkActive(this.editor.state, schema.marks.em);\n        this.underlineActivated = isMarkActive(this.editor.state, schema.marks.underline);\n\n        this.activeFontSize = undefined;\n        MARKS: for (const mark of findMarksInSelection(this.editor.state, schema.marks.fontSize)) {\n\n            for (const size of FontSize.sizes()) {\n                if (size.size === mark.attrs.fontSize) {\n\n                    // ups, mamy rÃ³Å¼ne rozmiary w zaznaczeniu\n                    if (this.activeFontSize && size !== this.activeFontSize) {\n                        this.activeFontSize = undefined;\n                        break MARKS;\n                    }\n\n                    this.activeFontSize = size;\n                }\n            }\n        }\n    }\n\n    ionViewWillLeave() {\n        this.editor.focus();\n    }\n}\n","import {Component, OnDestroy, OnInit} from \"@angular/core\";\nimport {EventManager} from \"@angular/platform-browser\";\nimport {unsubscribe} from \"@co.mmons/rxjs-utils\";\nimport {ModalController, Platform, PopoverController} from \"@ionic/angular\";\nimport {redo, redoDepth, undo, undoDepth} from \"prosemirror-history\";\nimport {findParentNode, findParentNodeOfType} from \"prosemirror-utils\";\nimport {Subscription} from \"rxjs\";\nimport {AlignmentMenu} from \"./alignment-menu\";\nimport {HtmlEditor} from \"./editor\";\nimport {HeadingMenu} from \"./heading-menu\";\nimport {InsertMenu} from \"./insert-menu\";\nimport {LinkModal} from \"./link-modal\";\nimport {ListMenu} from \"./list-menu\";\nimport {anyMarkActive, isMarkActive} from \"./prosemirror/is-active\";\nimport {schema} from \"./prosemirror/schema\";\nimport {isBlockMarkActive} from \"./prosemirror/utils/selection/is-block-mark-active\";\nimport {TextFormatMenu} from \"./text-format-menu\";\n\n@Component({\n    selector: \"ionx-html-editor-toolbar\",\n    template: `\n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.text\" (click)=\"showMenu($event, 'text')\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Text\" | intlMessage}}</span>\n        </ion-button>\n\n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.alignment\" (click)=\"showMenu($event, 'alignment')\" *ngIf=\"!editor.features || editor.features.alignment\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Alignment\" | intlMessage}}</span>\n        </ion-button>\n\n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.heading\" (click)=\"showMenu($event, 'heading')\" *ngIf=\"!editor.features || editor.features.heading\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Heading\" | intlMessage}}</span>\n        </ion-button>\n        \n        <ion-button size=\"small\" fill=\"clear\" [class.active-feature]=\"activeFeatures.list\" (click)=\"showMenu($event, 'list')\" *ngIf=\"!editor.features || editor.features.list\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#listMenu/List\" | intlMessage}}</span>\n        </ion-button>\n\n        <ion-button size=\"small\" fill=\"clear\" (click)=\"showMenu($event, 'insert')\" *ngIf=\"!editor.features || editor.features.link || editor.features.multimedia\">\n            <ion-icon name=\"md-arrow-dropdown\" slot=\"end\"></ion-icon>\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#Insert\" | intlMessage}}</span>\n        </ion-button>\n        \n        <ion-button size=\"small\" fill=\"clear\" class=\"active-feature\" (click)=\"editLink()\" *ngIf=\"activeFeatures.link\">\n            <span>{{\"@co.mmons/ionic-extensions/html-editor#link/Link\" | intlMessage}}</span>\n        </ion-button>\n        \n        <div ionx--buttons-group>\n            <ion-button size=\"small\" fill=\"clear\" tabindex=\"-1\" title=\"{{'@co.mmons/ionic-extensions/html-editor#Undo' | intlMessage}}\" [disabled]=\"!canUndo\" (click)=\"undo()\">\n                <ion-icon name=\"undo\" slot=\"icon-only\"></ion-icon>\n            </ion-button>\n    \n            <ion-button size=\"small\" fill=\"clear\" title=\"{{'@co.mmons/ionic-extensions/html-editor#Redo' | intlMessage}}\" [disabled]=\"!canRedo\" (click)=\"redo()\">\n                <ion-icon name=\"redo\" slot=\"icon-only\"></ion-icon>\n            </ion-button>\n        </div>\n    `,\n    styles: [`\n        :host { outline: none; display: flex; justify-content: center; flex-wrap: wrap; position: sticky; position: -webkit-sticky; top: 0px; background-color: var(--background); }\n        :host-context(.ion-focused) { background-color: var(--background-focused); }\n        :host ion-button { margin: 0px 4px; --padding-end: 2px; --padding-start: 4px; }\n        :host ion-button.active-feature span { font-weight: 800; }\n        :host ion-icon[slot=\"end\"] { margin: 0px; }\n        :host ion-button[disabled] { opacity: 0.5; }\n        :host [ionx--buttons-group] { display: flex; }\n        :host [ionx--buttons-group] ion-button:not(:last-child) { margin-right: 0px; }\n    `]\n})\nexport class Toolbar implements OnInit, OnDestroy {\n\n    constructor(\n        private popoverController: PopoverController,\n        private platform: Platform,\n        public readonly editor: HtmlEditor,\n        protected eventManager: EventManager,\n        private modalController: ModalController\n    ) {\n\n    }\n\n    async showMenu(event: Event, menu: string) {\n\n        const components = {\n            text: TextFormatMenu,\n            list: ListMenu,\n            alignment: AlignmentMenu,\n            insert: InsertMenu,\n            heading: HeadingMenu\n        };\n\n        const popover = await this.popoverController.create({\n            component: components[menu],\n            componentProps: {\n                editor: this.editor\n            },\n            event: event,\n            showBackdrop: this.platform.is(\"ios\")\n        });\n\n        popover.present();\n    }\n\n    activeFeatures: {\n        link?: boolean,\n        text?: boolean,\n        alignment?: boolean,\n        heading?: boolean;\n        list?: boolean\n    } = {};\n\n    async editLink() {\n        LinkModal.present(this.modalController, this.editor);\n    }\n\n    canUndo: boolean;\n\n    canRedo: boolean;\n\n    undo() {\n        undo(this.editor.view.state, (transaction) => this.editor.view.updateState(this.editor.view.state.apply(transaction)));\n        this.editor.focus();\n    }\n\n    redo() {\n        redo(this.editor.view.state, (transaction) => this.editor.view.updateState(this.editor.view.state.apply(transaction)));\n        this.editor.focus();\n\n    }\n\n    private editorSelectionChanged() {\n\n        this.canUndo = undoDepth(this.editor.view.state) > 0;\n        this.canRedo = redoDepth(this.editor.view.state) > 0;\n\n        this.activeFeatures = {};\n\n        this.activeFeatures.text = anyMarkActive(this.editor.view.state, [schema.marks.strong, schema.marks.em, schema.marks.underline, schema.marks.fontSize]);\n        this.activeFeatures.list = !!findParentNode(predicate => predicate.hasMarkup(schema.nodes.orderedList) || predicate.hasMarkup(schema.nodes.bulletList))(this.editor.state.selection);\n        this.activeFeatures.alignment = isBlockMarkActive(this.editor.view.state, schema.marks.alignment);\n        this.activeFeatures.heading = !!findParentNodeOfType(schema.nodes.heading)(this.editor.state.selection);\n        this.activeFeatures.link = isMarkActive(this.editor.view.state, schema.marks.link);\n    }\n\n    private selectionSubscription: Subscription;\n\n    async ngOnInit() {\n\n        this.selectionSubscription = this.editor.selectionChange.subscribe(() => this.editorSelectionChanged());\n\n        this.editorSelectionChanged();\n    }\n\n    ngOnDestroy() {\n        unsubscribe(this.selectionSubscription);\n    }\n\n}\n","import {MarkType} from \"prosemirror-model\";\nimport {EditorState} from \"prosemirror-state\";\n\nexport function isBlockMarkActive(state: EditorState, type: MarkType) {\n    const {from, $from, to, empty} = state.selection;\n\n    if (empty) {\n\n        for (const mark of $from.parent.marks) {\n            if (mark.type === type) {\n                return true;\n            }\n        }\n    } else {\n        return state.doc.rangeHasMark(from, to, type);\n    }\n}\n","import {CommonModule} from \"@angular/common\";\nimport {NgModule} from \"@angular/core\";\nimport {FormsModule, ReactiveFormsModule} from \"@angular/forms\";\nimport {MatchMediaModule} from \"@co.mmons/angular-extensions/browser/match-media\";\nimport {IntlModule} from \"@co.mmons/angular-intl\";\nimport {FormHelperModule} from \"@co.mmons/ionic-extensions/form-helper\";\nimport {SelectModule} from \"@co.mmons/ionic-extensions/select\";\nimport {IonicModule} from \"@ionic/angular\";\nimport {ButtonsModule} from \"@co.mmons/ionic-extensions/buttons\";\nimport {AlignmentMenu} from \"./alignment-menu\";\nimport {HtmlEditor} from \"./editor\";\nimport {HeadingMenu} from \"./heading-menu\";\nimport {InsertMenu} from \"./insert-menu\";\nimport {LinkModal} from \"./link-modal\";\nimport {ListMenu} from \"./list-menu\";\nimport {TextFormatMenu} from \"./text-format-menu\";\nimport {Toolbar} from \"./toolbar\";\n\nexport {HtmlEditor} from \"./editor\";\nexport {HtmlEditorFeatures} from \"./editor-features\";\n\n@NgModule({\n    imports: [CommonModule, IonicModule, IntlModule, SelectModule, FormsModule, ReactiveFormsModule, FormHelperModule, ButtonsModule, MatchMediaModule],\n    declarations: [HtmlEditor, AlignmentMenu, HeadingMenu, InsertMenu, LinkModal, ListMenu, TextFormatMenu, Toolbar],\n    exports: [HtmlEditor, IntlModule],\n    entryComponents: [AlignmentMenu, HeadingMenu, InsertMenu, LinkModal, ListMenu, TextFormatMenu]\n})\nexport class HtmlEditorModule {\n}\n"]}